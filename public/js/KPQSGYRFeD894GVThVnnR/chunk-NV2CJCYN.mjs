import { a as vn, b as Bg, c as yr, d as E, e as me, f as tn, g as cf, h as Wt } from "./chunk-JR5VT52U.mjs";
import { a as lf, b as _e, c as I } from "./chunk-RIUMFBNJ.mjs";
var Rt = {};
lf(Rt, {
    Children: () => yn,
    Component: () => ke,
    Fragment: () => bn,
    Profiler: () => $R,
    PureComponent: () => NR,
    StrictMode: () => jR,
    Suspense: () => br,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => HR,
    cloneElement: () => xr,
    createContext: () => be,
    createElement: () => Nr,
    createFactory: () => WR,
    createRef: () => Kg,
    default: () => x,
    forwardRef: () => Ie,
    isValidElement: () => At,
    lazy: () => UR,
    memo: () => ol,
    startTransition: () => at,
    unstable_act: () => GR,
    useCallback: () => Q,
    useContext: () => D,
    useDebugValue: () => qR,
    useDeferredValue: () => XR,
    useEffect: () => H,
    useId: () => wi,
    useImperativeHandle: () => YR,
    useInsertionEffect: () => ht,
    useLayoutEffect: () => ze,
    useMemo: () => ue,
    useReducer: () => KR,
    useRef: () => V,
    useState: () => Ee,
    useSyncExternalStore: () => Qg,
    useTransition: () => QR,
    version: () => ZR
});
var x = {}
    , gs = Symbol.for("react.element")
    , TR = Symbol.for("react.portal")
    , RR = Symbol.for("react.fragment")
    , ER = Symbol.for("react.strict_mode")
    , FR = Symbol.for("react.profiler")
    , PR = Symbol.for("react.provider")
    , _R = Symbol.for("react.context")
    , IR = Symbol.for("react.forward_ref")
    , OR = Symbol.for("react.suspense")
    , MR = Symbol.for("react.memo")
    , LR = Symbol.for("react.lazy")
    , $g = Symbol.iterator;
function VR(e) {
    return e === null || typeof e != "object" ? null : (e = $g && e[$g] || e["@@iterator"],
        typeof e == "function" ? e : null)
}
var Hg = {
    isMounted: function () {
        return !1
    },
    enqueueForceUpdate: function () { },
    enqueueReplaceState: function () { },
    enqueueSetState: function () { }
}
    , Wg = Object.assign
    , Ug = {};
function oo(e, t, n) {
    this.props = e,
        this.context = t,
        this.refs = Ug,
        this.updater = n || Hg
}
oo.prototype.isReactComponent = {};
oo.prototype.setState = function (e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
}
    ;
oo.prototype.forceUpdate = function (e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
    ;
function Gg() { }
Gg.prototype = oo.prototype;
function ff(e, t, n) {
    this.props = e,
        this.context = t,
        this.refs = Ug,
        this.updater = n || Hg
}
var df = ff.prototype = new Gg;
df.constructor = ff;
Wg(df, oo.prototype);
df.isPureReactComponent = !0;
var Ng = Array.isArray
    , qg = Object.prototype.hasOwnProperty
    , hf = {
        current: null
    }
    , Xg = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
function Yg(e, t, n) {
    var r, i = {}, o = null, s = null;
    if (t != null)
        for (r in t.ref !== void 0 && (s = t.ref),
            t.key !== void 0 && (o = "" + t.key),
            t)
            qg.call(t, r) && !Xg.hasOwnProperty(r) && (i[r] = t[r]);
    var a = arguments.length - 2;
    if (a === 1)
        i.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        i.children = l
    }
    if (e && e.defaultProps)
        for (r in a = e.defaultProps,
            a)
            i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: gs,
        type: e,
        key: o,
        ref: s,
        props: i,
        _owner: hf.current
    }
}
function AR(e, t) {
    return {
        $$typeof: gs,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}
function pf(e) {
    return typeof e == "object" && e !== null && e.$$typeof === gs
}
function DR(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function (n) {
        return t[n]
    })
}
var jg = /\/+/g;
function uf(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? DR("" + e.key) : t.toString(36)
}
function rl(e, t, n, r, i) {
    var o = typeof e;
    o !== "undefined" && o !== "boolean" || (e = null);
    var s = !1;
    if (e === null)
        s = !0;
    else
        switch (o) {
            case "string":
            case "number":
                s = !0;
                break;
            case "object":
                switch (e.$$typeof) {
                    case gs:
                    case TR:
                        s = !0
                }
        }
    if (s)
        return s = e,
            i = i(s),
            e = r === "" ? "." + uf(s, 0) : r,
            Ng(i) ? (n = "",
                e != null && (n = e.replace(jg, "$&/") + "/"),
                rl(i, t, n, "", function (c) {
                    return c
                })) : i != null && (pf(i) && (i = AR(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(jg, "$&/") + "/") + e)),
                    t.push(i)),
            1;
    if (s = 0,
        r = r === "" ? "." : r + ":",
        Ng(e))
        for (var a = 0; a < e.length; a++) {
            o = e[a];
            var l = r + uf(o, a);
            s += rl(o, t, n, l, i)
        }
    else if (l = VR(e),
        typeof l == "function")
        for (e = l.call(e),
            a = 0; !(o = e.next()).done;)
            o = o.value,
                l = r + uf(o, a++),
                s += rl(o, t, n, l, i);
    else if (o === "object")
        throw t = String(e),
        Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return s
}
function nl(e, t, n) {
    if (e == null)
        return e;
    var r = []
        , i = 0;
    return rl(e, r, "", "", function (o) {
        return t.call(n, o, i++)
    }),
        r
}
function zR(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(),
            t.then(function (n) {
                e._status !== 0 && e._status !== -1 || (e._status = 1,
                    e._result = n)
            }, function (n) {
                e._status !== 0 && e._status !== -1 || (e._status = 2,
                    e._result = n)
            }),
            e._status === -1 && (e._status = 0,
                e._result = t)
    }
    if (e._status === 1)
        return e._result.default;
    throw e._result
}
var Vt = {
    current: null
}
    , il = {
        transition: null
    }
    , BR = {
        ReactCurrentDispatcher: Vt,
        ReactCurrentBatchConfig: il,
        ReactCurrentOwner: hf
    };
x.Children = {
    map: nl,
    forEach: function (e, t, n) {
        nl(e, function () {
            t.apply(this, arguments)
        }, n)
    },
    count: function (e) {
        var t = 0;
        return nl(e, function () {
            t++
        }),
            t
    },
    toArray: function (e) {
        return nl(e, function (t) {
            return t
        }) || []
    },
    only: function (e) {
        if (!pf(e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
x.Component = oo;
x.Fragment = RR;
x.Profiler = FR;
x.PureComponent = ff;
x.StrictMode = ER;
x.Suspense = OR;
x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = BR;
x.cloneElement = function (e, t, n) {
    if (e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var r = Wg({}, e.props)
        , i = e.key
        , o = e.ref
        , s = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (o = t.ref,
            s = hf.current),
            t.key !== void 0 && (i = "" + t.key),
            e.type && e.type.defaultProps)
            var a = e.type.defaultProps;
        for (l in t)
            qg.call(t, l) && !Xg.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        r.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: gs,
        type: e.type,
        key: i,
        ref: o,
        props: r,
        _owner: s
    }
}
    ;
x.createContext = function (e) {
    return e = {
        $$typeof: _R,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
        e.Provider = {
            $$typeof: PR,
            _context: e
        },
        e.Consumer = e
}
    ;
x.createElement = Yg;
x.createFactory = function (e) {
    var t = Yg.bind(null, e);
    return t.type = e,
        t
}
    ;
x.createRef = function () {
    return {
        current: null
    }
}
    ;
x.forwardRef = function (e) {
    return {
        $$typeof: IR,
        render: e
    }
}
    ;
x.isValidElement = pf;
x.lazy = function (e) {
    return {
        $$typeof: LR,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: zR
    }
}
    ;
x.memo = function (e, t) {
    return {
        $$typeof: MR,
        type: e,
        compare: t === void 0 ? null : t
    }
}
    ;
x.startTransition = function (e) {
    var t = il.transition;
    il.transition = {};
    try {
        e()
    } finally {
        il.transition = t
    }
}
    ;
x.unstable_act = function () {
    throw Error("act(...) is not supported in production builds of React.")
}
    ;
x.useCallback = function (e, t) {
    return Vt.current.useCallback(e, t)
}
    ;
x.useContext = function (e) {
    return Vt.current.useContext(e)
}
    ;
x.useDebugValue = function () { }
    ;
x.useDeferredValue = function (e) {
    return Vt.current.useDeferredValue(e)
}
    ;
x.useEffect = function (e, t) {
    return Vt.current.useEffect(e, t)
}
    ;
x.useId = function () {
    return Vt.current.useId()
}
    ;
x.useImperativeHandle = function (e, t, n) {
    return Vt.current.useImperativeHandle(e, t, n)
}
    ;
x.useInsertionEffect = function (e, t) {
    return Vt.current.useInsertionEffect(e, t)
}
    ;
x.useLayoutEffect = function (e, t) {
    return Vt.current.useLayoutEffect(e, t)
}
    ;
x.useMemo = function (e, t) {
    return Vt.current.useMemo(e, t)
}
    ;
x.useReducer = function (e, t, n) {
    return Vt.current.useReducer(e, t, n)
}
    ;
x.useRef = function (e) {
    return Vt.current.useRef(e)
}
    ;
x.useState = function (e) {
    return Vt.current.useState(e)
}
    ;
x.useSyncExternalStore = function (e, t, n) {
    return Vt.current.useSyncExternalStore(e, t, n)
}
    ;
x.useTransition = function () {
    return Vt.current.useTransition()
}
    ;
x.version = "18.2.0";
var yn = x.Children
    , ke = x.Component
    , bn = x.Fragment
    , $R = x.Profiler
    , NR = x.PureComponent
    , jR = x.StrictMode
    , br = x.Suspense
    , HR = x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
    , xr = x.cloneElement
    , be = x.createContext
    , Nr = x.createElement
    , WR = x.createFactory
    , Kg = x.createRef
    , Ie = x.forwardRef
    , At = x.isValidElement
    , UR = x.lazy
    , ol = x.memo
    , at = x.startTransition
    , GR = x.unstable_act
    , Q = x.useCallback
    , D = x.useContext
    , qR = x.useDebugValue
    , XR = x.useDeferredValue
    , H = x.useEffect
    , wi = x.useId
    , YR = x.useImperativeHandle
    , ht = x.useInsertionEffect
    , ze = x.useLayoutEffect
    , ue = x.useMemo
    , KR = x.useReducer
    , V = x.useRef
    , Ee = x.useState
    , Qg = x.useSyncExternalStore
    , QR = x.useTransition
    , ZR = x.version;
var JR = "default" in Rt ? x : Rt
    , so = {}
    , eE = JR
    , tE = Symbol.for("react.element")
    , nE = Symbol.for("react.fragment")
    , rE = Object.prototype.hasOwnProperty
    , iE = eE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
    , oE = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
function Zg(e, t, n) {
    var r, i = {}, o = null, s = null;
    n !== void 0 && (o = "" + n),
        t.key !== void 0 && (o = "" + t.key),
        t.ref !== void 0 && (s = t.ref);
    for (r in t)
        rE.call(t, r) && !oE.hasOwnProperty(r) && (i[r] = t[r]);
    if (e && e.defaultProps)
        for (r in t = e.defaultProps,
            t)
            i[r] === void 0 && (i[r] = t[r]);
    return {
        $$typeof: tE,
        type: e,
        key: o,
        ref: s,
        props: i,
        _owner: iE.current
    }
}
so.Fragment = nE;
so.jsx = Zg;
so.jsxs = Zg;
var lt = so.Fragment
    , k = so.jsx
    , ge = so.jsxs;
var sE = vn({
    "../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        function t(n) {
            var r = {};
            return function (i) {
                return r[i] === void 0 && (r[i] = n(i)),
                    r[i]
            }
        }
        e.default = t
    }
})
    , aE = vn({
        "../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(e) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            function t(o) {
                return o && typeof o == "object" && "default" in o ? o.default : o
            }
            var n = t(sE())
                , r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
                , i = n(function (o) {
                    return r.test(o) || o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) < 91
                });
            e.default = i
        }
    })
    , wl = {
        skipAnimations: !1,
        useManualTiming: !1
    }
    , wt = e => e;
function lE(e) {
    let t = new Set
        , n = new Set
        , r = !1
        , i = !1
        , o = new WeakSet
        , s = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        };
    function a(c) {
        o.has(c) && (l.schedule(c),
            e()),
            c(s)
    }
    let l = {
        schedule: (c, u = !1, f = !1) => {
            let p = f && r ? t : n;
            return u && o.add(c),
                p.has(c) || p.add(c),
                c
        }
        ,
        cancel: c => {
            n.delete(c),
                o.delete(c)
        }
        ,
        process: c => {
            if (s = c,
                r) {
                i = !0;
                return
            }
            r = !0,
                [t, n] = [n, t],
                n.clear(),
                t.forEach(a),
                r = !1,
                i && (i = !1,
                    l.process(c))
        }
    };
    return l
}
var bs = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
    , cE = 40;
function ky(e, t) {
    let n = !1
        , r = !0
        , i = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        }
        , o = () => n = !0
        , s = bs.reduce((m, h) => (m[h] = lE(o),
            m), {})
        , { read: a, resolveKeyframes: l, update: c, preRender: u, render: f, postRender: d } = s
        , p = () => {
            let m = wl.useManualTiming ? i.timestamp : performance.now();
            n = !1,
                i.delta = r ? 1e3 / 60 : Math.max(Math.min(m - i.timestamp, cE), 1),
                i.timestamp = m,
                i.isProcessing = !0,
                a.process(i),
                l.process(i),
                c.process(i),
                u.process(i),
                f.process(i),
                d.process(i),
                i.isProcessing = !1,
                n && t && (r = !1,
                    e(p))
        }
        , v = () => {
            n = !0,
                r = !0,
                i.isProcessing || e(p)
        }
        ;
    return {
        schedule: bs.reduce((m, h) => {
            let y = s[h];
            return m[h] = (w, C = !1, S = !1) => (n || v(),
                y.schedule(w, C, S)),
                m
        }
            , {}),
        cancel: m => {
            for (let h = 0; h < bs.length; h++)
                s[bs[h]].cancel(m)
        }
        ,
        state: i,
        steps: s
    }
}
var { schedule: J, cancel: Ft, state: qe, steps: cl } = ky(typeof requestAnimationFrame < "u" ? requestAnimationFrame : wt, !0)
    , Cy = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
    , uE = 1e-7
    , fE = 12;
function dE(e, t, n, r, i) {
    let o, s, a = 0;
    do
        s = t + (n - t) / 2,
            o = Cy(s, r, i) - e,
            o > 0 ? n = s : t = s;
    while (Math.abs(o) > uE && ++a < fE);
    return s
}
function go(e, t, n, r) {
    if (e === t && n === r)
        return wt;
    let i = o => dE(o, 0, 1, e, n);
    return o => o === 0 || o === 1 ? o : Cy(i(o), t, r)
}
var Yf = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
    , Kf = e => t => 1 - e(1 - t)
    , Qf = go(.33, 1.53, .69, .99)
    , Sl = Kf(Qf)
    , Zf = Yf(Sl)
    , Jf = e => (e *= 2) < 1 ? .5 * Sl(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
    , kl = e => 1 - Math.sin(Math.acos(e))
    , ed = Kf(kl)
    , td = Yf(kl)
    , vo = wt
    , nn = wt
    , Sr = (e, t, n) => n > t ? t : n < e ? e : n
    , Ms = e => ({
        test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
        parse: parseFloat,
        transform: t => `${t}${e}`
    })
    , jr = Ms("deg")
    , Xn = Ms("%")
    , ee = Ms("px")
    , hE = Ms("vh")
    , pE = Ms("vw")
    , Jg = {
        ...Xn,
        parse: e => Xn.parse(e) / 100,
        transform: e => Xn.transform(e * 100)
    }
    , yo = {
        test: e => typeof e == "number",
        parse: parseFloat,
        transform: e => e
    }
    , Es = {
        ...yo,
        transform: e => Sr(0, 1, e)
    }
    , sl = {
        ...yo,
        default: 1
    }
    , Ss = e => Math.round(e * 1e5) / 1e5
    , nd = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function mE(e) {
    return e == null
}
var gE = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
    , rd = (e, t) => n => !!(typeof n == "string" && gE.test(n) && n.startsWith(e) || t && !mE(n) && Object.prototype.hasOwnProperty.call(n, t))
    , Ty = (e, t, n) => r => {
        if (typeof r != "string")
            return r;
        let [i, o, s, a] = r.match(nd);
        return {
            [e]: parseFloat(i),
            [t]: parseFloat(o),
            [n]: parseFloat(s),
            alpha: a !== void 0 ? parseFloat(a) : 1
        }
    }
    , vE = e => Sr(0, 255, e)
    , mf = {
        ...yo,
        transform: e => Math.round(vE(e))
    }
    , Ti = {
        test: rd("rgb", "red"),
        parse: Ty("red", "green", "blue"),
        transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + mf.transform(e) + ", " + mf.transform(t) + ", " + mf.transform(n) + ", " + Ss(Es.transform(r)) + ")"
    };
function yE(e) {
    let t = ""
        , n = ""
        , r = ""
        , i = "";
    return e.length > 5 ? (t = e.substring(1, 3),
        n = e.substring(3, 5),
        r = e.substring(5, 7),
        i = e.substring(7, 9)) : (t = e.substring(1, 2),
            n = e.substring(2, 3),
            r = e.substring(3, 4),
            i = e.substring(4, 5),
            t += t,
            n += n,
            r += r,
            i += i),
    {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
var Ff = {
    test: rd("#"),
    parse: yE,
    transform: Ti.transform
}
    , ao = {
        test: rd("hsl", "hue"),
        parse: Ty("hue", "saturation", "lightness"),
        transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Xn.transform(Ss(t)) + ", " + Xn.transform(Ss(n)) + ", " + Ss(Es.transform(r)) + ")"
    }
    , xt = {
        test: e => Ti.test(e) || Ff.test(e) || ao.test(e),
        parse: e => Ti.test(e) ? Ti.parse(e) : ao.test(e) ? ao.parse(e) : Ff.parse(e),
        transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Ti.transform(e) : ao.transform(e)
    }
    , bE = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function xE(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(nd)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(bE)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
var Ry = "number"
    , Ey = "color"
    , wE = "var"
    , SE = "var("
    , ev = "${}"
    , kE = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Fs(e) {
    let t = e.toString()
        , n = []
        , r = {
            color: [],
            number: [],
            var: []
        }
        , i = []
        , o = 0
        , a = t.replace(kE, l => (xt.test(l) ? (r.color.push(o),
            i.push(Ey),
            n.push(xt.parse(l))) : l.startsWith(SE) ? (r.var.push(o),
                i.push(wE),
                n.push(l)) : (r.number.push(o),
                    i.push(Ry),
                    n.push(parseFloat(l))),
            ++o,
            ev)).split(ev);
    return {
        values: n,
        split: a,
        indexes: r,
        types: i
    }
}
function Fy(e) {
    return Fs(e).values
}
function Py(e) {
    let { split: t, types: n } = Fs(e)
        , r = t.length;
    return i => {
        let o = "";
        for (let s = 0; s < r; s++)
            if (o += t[s],
                i[s] !== void 0) {
                let a = n[s];
                a === Ry ? o += Ss(i[s]) : a === Ey ? o += xt.transform(i[s]) : o += i[s]
            }
        return o
    }
}
var CE = e => typeof e == "number" ? 0 : e;
function TE(e) {
    let t = Fy(e);
    return Py(e)(t.map(CE))
}
var kr = {
    test: xE,
    parse: Fy,
    createTransformer: Py,
    getAnimatableNone: TE
}
    , Mn = e => e * 1e3
    , Yn = e => e / 1e3
    , gf = .001
    , RE = .01
    , tv = 10
    , EE = .05
    , FE = 1;
function _y({ duration: e = 800, bounce: t = .25, velocity: n = 0, mass: r = 1 }) {
    let i, o;
    vo(e <= Mn(tv), "Spring duration must be 10 seconds or less");
    let s = 1 - t;
    s = Sr(EE, FE, s),
        e = Sr(RE, tv, Yn(e)),
        s < 1 ? (i = c => {
            let u = c * s
                , f = u * e
                , d = u - n
                , p = Pf(c, s)
                , v = Math.exp(-f);
            return gf - d / p * v
        }
            ,
            o = c => {
                let f = c * s * e
                    , d = f * n + n
                    , p = Math.pow(s, 2) * Math.pow(c, 2) * e
                    , v = Math.exp(-f)
                    , g = Pf(Math.pow(c, 2), s);
                return (-i(c) + gf > 0 ? -1 : 1) * ((d - p) * v) / g
            }
        ) : (i = c => {
            let u = Math.exp(-c * e)
                , f = (c - n) * e + 1;
            return -gf + u * f
        }
            ,
            o = c => {
                let u = Math.exp(-c * e)
                    , f = (n - c) * (e * e);
                return u * f
            }
        );
    let a = 5 / e
        , l = _E(i, o, a);
    if (e = Mn(e),
        isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: e
        };
    {
        let c = Math.pow(l, 2) * r;
        return {
            stiffness: c,
            damping: s * 2 * Math.sqrt(r * c),
            duration: e
        }
    }
}
var PE = 12;
function _E(e, t, n) {
    let r = n;
    for (let i = 1; i < PE; i++)
        r = r - e(r) / t(r);
    return r
}
function Pf(e, t) {
    return e * Math.sqrt(1 - t * t)
}
function id(e, t) {
    return t ? e * (1e3 / t) : 0
}
var IE = 5;
function Iy(e, t, n) {
    let r = Math.max(t - IE, 0);
    return id(n - e(r), t - r)
}
var OE = ["duration", "bounce"]
    , ME = ["stiffness", "damping", "mass"];
function nv(e, t) {
    return t.some(n => e[n] !== void 0)
}
function LE(e) {
    let t = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!nv(e, ME) && nv(e, OE)) {
        let n = _y(e);
        t = {
            ...t,
            ...n,
            mass: 1
        },
            t.isResolvedFromDuration = !0
    }
    return t
}
function Ls({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
    let i = e[0]
        , o = e[e.length - 1]
        , s = {
            done: !1,
            value: i
        }
        , { stiffness: a, damping: l, mass: c, duration: u, velocity: f, isResolvedFromDuration: d } = LE({
            ...r,
            velocity: -Yn(r.velocity || 0)
        })
        , p = f || 0
        , v = l / (2 * Math.sqrt(a * c))
        , g = o - i
        , b = Yn(Math.sqrt(a / c))
        , m = Math.abs(g) < 5;
    n || (n = m ? .01 : 2),
        t || (t = m ? .005 : .5);
    let h;
    if (v < 1) {
        let y = Pf(b, v);
        h = w => {
            let C = Math.exp(-v * b * w);
            return o - C * ((p + v * b * g) / y * Math.sin(y * w) + g * Math.cos(y * w))
        }
    } else if (v === 1)
        h = y => o - Math.exp(-b * y) * (g + (p + b * g) * y);
    else {
        let y = b * Math.sqrt(v * v - 1);
        h = w => {
            let C = Math.exp(-v * b * w)
                , S = Math.min(y * w, 300);
            return o - C * ((p + v * b * g) * Math.sinh(S) + y * g * Math.cosh(S)) / y
        }
    }
    return {
        calculatedDuration: d && u || null,
        next: y => {
            let w = h(y);
            if (d)
                s.done = y >= u;
            else {
                let C = 0;
                v < 1 && (C = y === 0 ? Mn(p) : Iy(h, y, w));
                let S = Math.abs(C) <= n
                    , T = Math.abs(o - w) <= t;
                s.done = S && T
            }
            return s.value = s.done ? o : w,
                s
        }
    }
}
function _f({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: c = .5, restSpeed: u }) {
    let f = e[0]
        , d = {
            done: !1,
            value: f
        }
        , p = R => a !== void 0 && R < a || l !== void 0 && R > l
        , v = R => a === void 0 ? l : l === void 0 || Math.abs(a - R) < Math.abs(l - R) ? a : l
        , g = n * t
        , b = f + g
        , m = s === void 0 ? b : s(b);
    m !== b && (g = m - f);
    let h = R => -g * Math.exp(-R / r), y = R => m + h(R), w = R => {
        let F = h(R)
            , P = y(R);
        d.done = Math.abs(F) <= c,
            d.value = d.done ? m : P
    }
        , C, S, T = R => {
            p(d.value) && (C = R,
                S = Ls({
                    keyframes: [d.value, v(d.value)],
                    velocity: Iy(y, R, d.value),
                    damping: i,
                    stiffness: o,
                    restDelta: c,
                    restSpeed: u
                }))
        }
        ;
    return T(0),
    {
        calculatedDuration: null,
        next: R => {
            let F = !1;
            return !S && C === void 0 && (F = !0,
                w(R),
                T(R)),
                C !== void 0 && R >= C ? S.next(R - C) : (!F && w(R),
                    d)
        }
    }
}
var Oy = go(.42, 0, 1, 1)
    , My = go(0, 0, .58, 1)
    , od = go(.42, 0, .58, 1)
    , VE = (e, t) => n => t(e(n))
    , Kn = (...e) => e.reduce(VE)
    , Cr = (e, t, n) => {
        let r = t - e;
        return r === 0 ? 1 : (n - e) / r
    }
    , Le = (e, t, n) => e + (t - e) * n;
function vf(e, t, n) {
    return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function AE({ hue: e, saturation: t, lightness: n, alpha: r }) {
    e /= 360,
        t /= 100,
        n /= 100;
    let i = 0
        , o = 0
        , s = 0;
    if (!t)
        i = o = s = n;
    else {
        let a = n < .5 ? n * (1 + t) : n + t - n * t
            , l = 2 * n - a;
        i = vf(l, a, e + 1 / 3),
            o = vf(l, a, e),
            s = vf(l, a, e - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(o * 255),
        blue: Math.round(s * 255),
        alpha: r
    }
}
function pl(e, t) {
    return n => n > 0 ? t : e
}
var yf = (e, t, n) => {
    let r = e * e
        , i = n * (t * t - r) + r;
    return i < 0 ? 0 : Math.sqrt(i)
}
    , DE = [Ff, Ti, ao]
    , zE = e => DE.find(t => t.test(e));
function rv(e) {
    let t = zE(e);
    if (vo(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`),
        !t)
        return !1;
    let n = t.parse(e);
    return t === ao && (n = AE(n)),
        n
}
var iv = (e, t) => {
    let n = rv(e)
        , r = rv(t);
    if (!n || !r)
        return pl(e, t);
    let i = {
        ...n
    };
    return o => (i.red = yf(n.red, r.red, o),
        i.green = yf(n.green, r.green, o),
        i.blue = yf(n.blue, r.blue, o),
        i.alpha = Le(n.alpha, r.alpha, o),
        Ti.transform(i))
}
    , Ly = e => t => typeof t == "string" && t.startsWith(e)
    , Vy = Ly("--")
    , BE = Ly("var(--")
    , sd = e => BE(e) ? $E.test(e.split("/*")[0].trim()) : !1
    , $E = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
    , If = new Set(["none", "hidden"]);
function NE(e, t) {
    return If.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}
function jE(e, t) {
    return n => Le(e, t, n)
}
function ad(e) {
    return typeof e == "number" ? jE : typeof e == "string" ? sd(e) ? pl : xt.test(e) ? iv : UE : Array.isArray(e) ? Ay : typeof e == "object" ? xt.test(e) ? iv : HE : pl
}
function Ay(e, t) {
    let n = [...e]
        , r = n.length
        , i = e.map((o, s) => ad(o)(o, t[s]));
    return o => {
        for (let s = 0; s < r; s++)
            n[s] = i[s](o);
        return n
    }
}
function HE(e, t) {
    let n = {
        ...e,
        ...t
    }
        , r = {};
    for (let i in n)
        e[i] !== void 0 && t[i] !== void 0 && (r[i] = ad(e[i])(e[i], t[i]));
    return i => {
        for (let o in r)
            n[o] = r[o](i);
        return n
    }
}
function WE(e, t) {
    var n;
    let r = []
        , i = {
            color: 0,
            var: 0,
            number: 0
        };
    for (let o = 0; o < t.values.length; o++) {
        let s = t.types[o]
            , a = e.indexes[s][i[s]]
            , l = (n = e.values[a]) !== null && n !== void 0 ? n : 0;
        r[o] = l,
            i[s]++
    }
    return r
}
var UE = (e, t) => {
    let n = kr.createTransformer(t)
        , r = Fs(e)
        , i = Fs(t);
    return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? If.has(e) && !i.values.length || If.has(t) && !r.values.length ? NE(e, t) : Kn(Ay(WE(r, i), i.values), n) : (vo(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),
        pl(e, t))
}
    ;
function ld(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Le(e, t, n) : ad(e)(e, t)
}
function GE(e, t, n) {
    let r = []
        , i = n || ld
        , o = e.length - 1;
    for (let s = 0; s < o; s++) {
        let a = i(e[s], e[s + 1]);
        if (t) {
            let l = Array.isArray(t) ? t[s] || wt : t;
            a = Kn(l, a)
        }
        r.push(a)
    }
    return r
}
function bo(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
    let o = e.length;
    if (nn(o === t.length, "Both input and output ranges must be the same length"),
        o === 1)
        return () => t[0];
    if (o === 2 && e[0] === e[1])
        return () => t[1];
    e[0] > e[o - 1] && (e = [...e].reverse(),
        t = [...t].reverse());
    let s = GE(t, r, i)
        , a = s.length
        , l = c => {
            let u = 0;
            if (a > 1)
                for (; u < e.length - 2 && !(c < e[u + 1]); u++)
                    ;
            let f = Cr(e[u], e[u + 1], c);
            return s[u](f)
        }
        ;
    return n ? c => l(Sr(e[0], e[o - 1], c)) : l
}
var Dy = e => Array.isArray(e) && typeof e[0] != "number"
    , cd = e => Array.isArray(e) && typeof e[0] == "number"
    , ov = {
        linear: wt,
        easeIn: Oy,
        easeInOut: od,
        easeOut: My,
        circIn: kl,
        circInOut: td,
        circOut: ed,
        backIn: Sl,
        backInOut: Zf,
        backOut: Qf,
        anticipate: Jf
    }
    , Of = e => {
        if (cd(e)) {
            nn(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
            let [t, n, r, i] = e;
            return go(t, n, r, i)
        } else if (typeof e == "string")
            return nn(ov[e] !== void 0, `Invalid easing type '${e}'`),
                ov[e];
        return e
    }
    ;
function zy(e, t) {
    let n = e[e.length - 1];
    for (let r = 1; r <= t; r++) {
        let i = Cr(0, t, r);
        e.push(Le(n, 1, i))
    }
}
function ud(e) {
    let t = [0];
    return zy(t, e.length - 1),
        t
}
function qE(e, t) {
    return e.map(n => n * t)
}
function XE(e, t) {
    return e.map(() => t || od).splice(0, e.length - 1)
}
function Ps({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
    let i = Dy(r) ? r.map(Of) : Of(r)
        , o = {
            done: !1,
            value: t[0]
        }
        , s = qE(n && n.length === t.length ? n : ud(t), e)
        , a = bo(s, t, {
            ease: Array.isArray(i) ? i : XE(t, i)
        });
    return {
        calculatedDuration: e,
        next: l => (o.value = a(l),
            o.done = l >= e,
            o)
    }
}
var Vs = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
    , Wr = new Set(Vs)
    , YE = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
    , sv = e => e === yo || e === ee
    , av = (e, t) => parseFloat(e.split(", ")[t])
    , lv = (e, t) => (n, { transform: r }) => {
        if (r === "none" || !r)
            return 0;
        let i = r.match(/^matrix3d\((.+)\)$/u);
        if (i)
            return av(i[1], t);
        {
            let o = r.match(/^matrix\((.+)\)$/u);
            return o ? av(o[1], e) : 0
        }
    }
    , KE = new Set(["x", "y", "z"])
    , QE = Vs.filter(e => !KE.has(e));
function ZE(e) {
    let t = [];
    return QE.forEach(n => {
        let r = e.getValue(n);
        r !== void 0 && (t.push([n, r.get()]),
            r.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
        t
}
var ho = {
    width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, { top: t }) => parseFloat(t),
    left: (e, { left: t }) => parseFloat(t),
    bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
    right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
    x: lv(4, 13),
    y: lv(5, 14)
};
ho.translateX = ho.x;
ho.translateY = ho.y;
var Ri = new Set
    , Mf = !1
    , Lf = !1;
function By() {
    if (Lf) {
        let e = Array.from(Ri).filter(r => r.needsMeasurement)
            , t = new Set(e.map(r => r.element))
            , n = new Map;
        t.forEach(r => {
            let i = ZE(r);
            i.length && (n.set(r, i),
                r.render())
        }
        ),
            e.forEach(r => r.measureInitialState()),
            t.forEach(r => {
                r.render();
                let i = n.get(r);
                i && i.forEach(([o, s]) => {
                    var a;
                    (a = r.getValue(o)) === null || a === void 0 || a.set(s)
                }
                )
            }
            ),
            e.forEach(r => r.measureEndState()),
            e.forEach(r => {
                r.suspendedScrollY !== void 0 && I.scrollTo(0, r.suspendedScrollY)
            }
            )
    }
    Lf = !1,
        Mf = !1,
        Ri.forEach(e => e.complete()),
        Ri.clear()
}
function $y() {
    Ri.forEach(e => {
        e.readKeyframes(),
            e.needsMeasurement && (Lf = !0)
    }
    )
}
function JE() {
    $y(),
        By()
}
var fd = class {
    constructor(e, t, n, r, i, o = !1) {
        this.isComplete = !1,
            this.isAsync = !1,
            this.needsMeasurement = !1,
            this.isScheduled = !1,
            this.unresolvedKeyframes = [...e],
            this.onComplete = t,
            this.name = n,
            this.motionValue = r,
            this.element = i,
            this.isAsync = o
    }
    scheduleResolve() {
        this.isScheduled = !0,
            this.isAsync ? (Ri.add(this),
                Mf || (Mf = !0,
                    J.read($y),
                    J.resolveKeyframes(By))) : (this.readKeyframes(),
                        this.complete())
    }
    readKeyframes() {
        let { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this;
        for (let i = 0; i < e.length; i++)
            if (e[i] === null)
                if (i === 0) {
                    let o = r?.get()
                        , s = e[e.length - 1];
                    if (o !== void 0)
                        e[0] = o;
                    else if (n && t) {
                        let a = n.readValue(t, s);
                        a != null && (e[0] = a)
                    }
                    e[0] === void 0 && (e[0] = s),
                        r && o === void 0 && r.set(e[0])
                } else
                    e[i] = e[i - 1]
    }
    setFinalKeyframe() { }
    measureInitialState() { }
    renderEndStyles() { }
    measureEndState() { }
    complete() {
        this.isComplete = !0,
            this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
            Ri.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
            Ri.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
    , ul;
function eF() {
    ul = void 0
}
var Qn = {
    now: () => (ul === void 0 && Qn.set(qe.isProcessing || wl.useManualTiming ? qe.timestamp : performance.now()),
        ul),
    set: e => {
        ul = e,
            queueMicrotask(eF)
    }
}
    , ml = {
        current: !1
    };
function Cl(e) {
    return typeof e == "function"
}
var cv = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (kr.test(e) || e === "0") && !e.startsWith("url("));
function tF(e) {
    let t = e[0];
    if (e.length === 1)
        return !0;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t)
            return !0
}
function nF(e, t, n, r) {
    let i = e[0];
    if (i === null)
        return !1;
    if (t === "display" || t === "visibility")
        return !0;
    let o = e[e.length - 1]
        , s = cv(i, t)
        , a = cv(o, t);
    return vo(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`),
        !s || !a ? !1 : tF(e) || (n === "spring" || Cl(n)) && r
}
var rF = e => e !== null;
function Tl(e, { repeat: t, repeatType: n = "loop" }, r) {
    let i = e.filter(rF)
        , o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
    return !o || r === void 0 ? i[o] : r
}
var iF = 40
    , Ny = class {
        constructor({ autoplay: e = !0, delay: t = 0, type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o = "loop", ...s }) {
            this.isStopped = !1,
                this.hasAttemptedResolve = !1,
                this.createdAt = Qn.now(),
                this.options = {
                    autoplay: e,
                    delay: t,
                    type: n,
                    repeat: r,
                    repeatDelay: i,
                    repeatType: o,
                    ...s
                },
                this.updateFinishedPromise()
        }
        calcStartTime() {
            return this.resolvedAt ? this.resolvedAt - this.createdAt > iF ? this.resolvedAt : this.createdAt : this.createdAt
        }
        get resolved() {
            return !this._resolved && !this.hasAttemptedResolve && JE(),
                this._resolved
        }
        onKeyframesResolved(e, t) {
            this.resolvedAt = Qn.now(),
                this.hasAttemptedResolve = !0;
            let { name: n, type: r, velocity: i, delay: o, onComplete: s, onUpdate: a, isGenerator: l } = this.options;
            if (!l && !nF(e, n, r, i))
                if (ml.current || !o) {
                    a?.(Tl(e, this.options, t)),
                        s?.(),
                        this.resolveFinishedPromise();
                    return
                } else
                    this.options.duration = 0;
            let c = this.initPlayback(e, t);
            c !== !1 && (this._resolved = {
                keyframes: e,
                finalKeyframe: t,
                ...c
            },
                this.onPostResolved())
        }
        onPostResolved() { }
        then(e, t) {
            return this.currentFinishedPromise.then(e, t)
        }
        updateFinishedPromise() {
            this.currentFinishedPromise = new Promise(e => {
                this.resolveFinishedPromise = e
            }
            )
        }
    }
    , Vf = 2e4;
function jy(e) {
    let t = 0
        , n = 50
        , r = e.next(t);
    for (; !r.done && t < Vf;)
        t += n,
            r = e.next(t);
    return t >= Vf ? 1 / 0 : t
}
var oF = e => {
    let t = ({ timestamp: n }) => e(n);
    return {
        start: () => J.update(t, !0),
        stop: () => Ft(t),
        now: () => qe.isProcessing ? qe.timestamp : Qn.now()
    }
}
    , sF = {
        decay: _f,
        inertia: _f,
        tween: Ps,
        keyframes: Ps,
        spring: Ls
    }
    , aF = e => e / 100
    , Rl = class extends Ny {
        constructor(e) {
            super(e),
                this.holdTime = null,
                this.cancelTime = null,
                this.currentTime = 0,
                this.playbackSpeed = 1,
                this.pendingPlayState = "running",
                this.startTime = null,
                this.state = "idle",
                this.stop = () => {
                    if (this.resolver.cancel(),
                        this.isStopped = !0,
                        this.state === "idle")
                        return;
                    this.teardown();
                    let { onStop: a } = this.options;
                    a && a()
                }
                ;
            let { name: t, motionValue: n, element: r, keyframes: i } = this.options
                , o = r?.KeyframeResolver || fd
                , s = (a, l) => this.onKeyframesResolved(a, l);
            this.resolver = new o(i, s, t, n, r),
                this.resolver.scheduleResolve()
        }
        initPlayback(e) {
            let { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, s = Cl(t) ? t : sF[t] || Ps, a, l;
            s !== Ps && typeof e[0] != "number" && (a = Kn(aF, ld(e[0], e[1])),
                e = [0, 100]);
            let c = s({
                ...this.options,
                keyframes: e
            });
            i === "mirror" && (l = s({
                ...this.options,
                keyframes: [...e].reverse(),
                velocity: -o
            })),
                c.calculatedDuration === null && (c.calculatedDuration = jy(c));
            let { calculatedDuration: u } = c
                , f = u + r
                , d = f * (n + 1) - r;
            return {
                generator: c,
                mirroredGenerator: l,
                mapPercentToKeyframes: a,
                calculatedDuration: u,
                resolvedDuration: f,
                totalDuration: d
            }
        }
        onPostResolved() {
            let { autoplay: e = !0 } = this.options;
            this.play(),
                this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
        }
        tick(e, t = !1) {
            let { resolved: n } = this;
            if (!n) {
                let { keyframes: T } = this.options;
                return {
                    done: !0,
                    value: T[T.length - 1]
                }
            }
            let { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: s, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n;
            if (this.startTime === null)
                return i.next(0);
            let { delay: f, repeat: d, repeatType: p, repeatDelay: v, onUpdate: g } = this.options;
            this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)),
                t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
            let b = this.currentTime - f * (this.speed >= 0 ? 1 : -1)
                , m = this.speed >= 0 ? b < 0 : b > c;
            this.currentTime = Math.max(b, 0),
                this.state === "finished" && this.holdTime === null && (this.currentTime = c);
            let h = this.currentTime
                , y = i;
            if (d) {
                let T = Math.min(this.currentTime, c) / u
                    , R = Math.floor(T)
                    , F = T % 1;
                !F && T >= 1 && (F = 1),
                    F === 1 && R--,
                    R = Math.min(R, d + 1),
                    !!(R % 2) && (p === "reverse" ? (F = 1 - F,
                        v && (F -= v / u)) : p === "mirror" && (y = o)),
                    h = Sr(0, 1, F) * u
            }
            let w = m ? {
                done: !1,
                value: a[0]
            } : y.next(h);
            s && (w.value = s(w.value));
            let { done: C } = w;
            !m && l !== null && (C = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0);
            let S = this.holdTime === null && (this.state === "finished" || this.state === "running" && C);
            return S && r !== void 0 && (w.value = Tl(a, this.options, r)),
                g && g(w.value),
                S && this.finish(),
                w
        }
        get duration() {
            let { resolved: e } = this;
            return e ? Yn(e.calculatedDuration) : 0
        }
        get time() {
            return Yn(this.currentTime)
        }
        set time(e) {
            e = Mn(e),
                this.currentTime = e,
                this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
        }
        get speed() {
            return this.playbackSpeed
        }
        set speed(e) {
            let t = this.playbackSpeed !== e;
            this.playbackSpeed = e,
                t && (this.time = Yn(this.currentTime))
        }
        play() {
            if (this.resolver.isScheduled || this.resolver.resume(),
                !this._resolved) {
                this.pendingPlayState = "running";
                return
            }
            if (this.isStopped)
                return;
            let { driver: e = oF, onPlay: t, startTime: n } = this.options;
            this.driver || (this.driver = e(i => this.tick(i))),
                t && t();
            let r = this.driver.now();
            this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = r) : this.startTime = n ?? this.calcStartTime(),
                this.state === "finished" && this.updateFinishedPromise(),
                this.cancelTime = this.startTime,
                this.holdTime = null,
                this.state = "running",
                this.driver.start()
        }
        pause() {
            var e;
            if (!this._resolved) {
                this.pendingPlayState = "paused";
                return
            }
            this.state = "paused",
                this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
        }
        complete() {
            this.state !== "running" && this.play(),
                this.pendingPlayState = this.state = "finished",
                this.holdTime = null
        }
        finish() {
            this.teardown(),
                this.state = "finished";
            let { onComplete: e } = this.options;
            e && e()
        }
        cancel() {
            this.cancelTime !== null && this.tick(this.cancelTime),
                this.teardown(),
                this.updateFinishedPromise()
        }
        teardown() {
            this.state = "idle",
                this.stopDriver(),
                this.resolveFinishedPromise(),
                this.updateFinishedPromise(),
                this.startTime = this.cancelTime = null,
                this.resolver.cancel()
        }
        stopDriver() {
            this.driver && (this.driver.stop(),
                this.driver = void 0)
        }
        sample(e) {
            return this.startTime = 0,
                this.tick(e, !0)
        }
    }
    ;
function dd(e) {
    return new Rl(e)
}
var Hy = e => /^0[^.\s]+$/u.test(e);
function lF(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Hy(e) : !0
}
var Wy = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)
    , cF = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function uF(e) {
    let t = cF.exec(e);
    if (!t)
        return [,];
    let [, n, r, i] = t;
    return [`--${n ?? r}`, i]
}
var fF = 4;
function Uy(e, t, n = 1) {
    nn(n <= fF, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
    let [r, i] = uF(e);
    if (!r)
        return;
    let o = I.getComputedStyle(t).getPropertyValue(r);
    if (o) {
        let s = o.trim();
        return Wy(s) ? parseFloat(s) : s
    }
    return sd(i) ? Uy(i, t, n + 1) : i
}
var Gy = e => t => t.test(e)
    , dF = {
        test: e => e === "auto",
        parse: e => e
    }
    , qy = [yo, ee, Xn, jr, pE, hE, dF]
    , uv = e => qy.find(Gy(e))
    , hF = new Set(["brightness", "contrast", "saturate", "opacity"]);
function pF(e) {
    let [t, n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow")
        return e;
    let [r] = n.match(nd) || [];
    if (!r)
        return e;
    let i = n.replace(r, "")
        , o = hF.has(t) ? 1 : 0;
    return r !== n && (o *= 100),
        t + "(" + o + i + ")"
}
var mF = /\b([a-z-]*)\(.*?\)/gu
    , Af = {
        ...kr,
        getAnimatableNone: e => {
            let t = e.match(mF);
            return t ? t.map(pF).join(" ") : e
        }
    }
    , gF = {
        borderWidth: ee,
        borderTopWidth: ee,
        borderRightWidth: ee,
        borderBottomWidth: ee,
        borderLeftWidth: ee,
        borderRadius: ee,
        radius: ee,
        borderTopLeftRadius: ee,
        borderTopRightRadius: ee,
        borderBottomRightRadius: ee,
        borderBottomLeftRadius: ee,
        width: ee,
        maxWidth: ee,
        height: ee,
        maxHeight: ee,
        top: ee,
        right: ee,
        bottom: ee,
        left: ee,
        padding: ee,
        paddingTop: ee,
        paddingRight: ee,
        paddingBottom: ee,
        paddingLeft: ee,
        margin: ee,
        marginTop: ee,
        marginRight: ee,
        marginBottom: ee,
        marginLeft: ee,
        backgroundPositionX: ee,
        backgroundPositionY: ee
    }
    , vF = {
        rotate: jr,
        rotateX: jr,
        rotateY: jr,
        rotateZ: jr,
        scale: sl,
        scaleX: sl,
        scaleY: sl,
        scaleZ: sl,
        skew: jr,
        skewX: jr,
        skewY: jr,
        distance: ee,
        translateX: ee,
        translateY: ee,
        translateZ: ee,
        x: ee,
        y: ee,
        z: ee,
        perspective: ee,
        transformPerspective: ee,
        opacity: Es,
        originX: Jg,
        originY: Jg,
        originZ: ee
    }
    , fv = {
        ...yo,
        transform: Math.round
    }
    , hd = {
        ...gF,
        ...vF,
        zIndex: fv,
        size: ee,
        fillOpacity: Es,
        strokeOpacity: Es,
        numOctaves: fv
    }
    , yF = {
        ...hd,
        color: xt,
        backgroundColor: xt,
        outlineColor: xt,
        fill: xt,
        stroke: xt,
        borderColor: xt,
        borderTopColor: xt,
        borderRightColor: xt,
        borderBottomColor: xt,
        borderLeftColor: xt,
        filter: Af,
        WebkitFilter: Af
    }
    , pd = e => yF[e];
function Xy(e, t) {
    let n = pd(e);
    return n !== Af && (n = kr),
        n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
var bF = new Set(["auto", "none", "0"]);
function xF(e, t, n) {
    let r = 0, i;
    for (; r < e.length && !i;) {
        let o = e[r];
        typeof o == "string" && !bF.has(o) && Fs(o).values.length && (i = e[r]),
            r++
    }
    if (i && n)
        for (let o of t)
            e[o] = Xy(n, i)
}
var Yy = class extends fd {
    constructor(e, t, n, r, i) {
        super(e, t, n, r, i, !0)
    }
    readKeyframes() {
        let { unresolvedKeyframes: e, element: t, name: n } = this;
        if (!t || !t.current)
            return;
        super.readKeyframes();
        for (let a = 0; a < e.length; a++) {
            let l = e[a];
            if (typeof l == "string" && (l = l.trim(),
                sd(l))) {
                let c = Uy(l, t.current);
                c !== void 0 && (e[a] = c),
                    a === e.length - 1 && (this.finalKeyframe = l)
            }
        }
        if (this.resolveNoneKeyframes(),
            !YE.has(n) || e.length !== 2)
            return;
        let [r, i] = e
            , o = uv(r)
            , s = uv(i);
        if (o !== s)
            if (sv(o) && sv(s))
                for (let a = 0; a < e.length; a++) {
                    let l = e[a];
                    typeof l == "string" && (e[a] = parseFloat(l))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        let { unresolvedKeyframes: e, name: t } = this
            , n = [];
        for (let r = 0; r < e.length; r++)
            lF(e[r]) && n.push(r);
        n.length && xF(e, n, t)
    }
    measureInitialState() {
        let { element: e, unresolvedKeyframes: t, name: n } = this;
        if (!e || !e.current)
            return;
        n === "height" && (this.suspendedScrollY = I.pageYOffset),
            this.measuredOrigin = ho[n](e.measureViewportBox(), I.getComputedStyle(e.current)),
            t[0] = this.measuredOrigin;
        let r = t[t.length - 1];
        r !== void 0 && e.getValue(n, r).jump(r, !1)
    }
    measureEndState() {
        var e;
        let { element: t, name: n, unresolvedKeyframes: r } = this;
        if (!t || !t.current)
            return;
        let i = t.getValue(n);
        i && i.jump(this.measuredOrigin, !1);
        let o = r.length - 1
            , s = r[o];
        r[o] = ho[n](t.measureViewportBox(), I.getComputedStyle(t.current)),
            s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s),
            !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([a, l]) => {
                t.getValue(a).set(l)
            }
            ),
            this.resolveNoneKeyframes()
    }
}
    , Ky = new Set(["opacity", "clipPath", "filter", "transform"])
    , wF = 10
    , SF = (e, t) => {
        let n = ""
            , r = Math.max(Math.round(t / wF), 2);
        for (let i = 0; i < r; i++)
            n += e(Cr(0, r - 1, i)) + ", ";
        return `linear(${n.substring(0, n.length - 2)})`
    }
    ;
function md(e) {
    let t;
    return () => (t === void 0 && (t = e()),
        t)
}
var kF = {
    linearEasing: void 0
};
function CF(e, t) {
    let n = md(e);
    return () => {
        var r;
        return (r = kF[t]) !== null && r !== void 0 ? r : n()
    }
}
var gl = CF(() => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
    , "linearEasing");
function Qy(e) {
    return !!(typeof e == "function" && gl() || !e || typeof e == "string" && (e in Df || gl()) || cd(e) || Array.isArray(e) && e.every(Qy))
}
var xs = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`
    , Df = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: xs([0, .65, .55, 1]),
        circOut: xs([.55, 0, 1, .45]),
        backIn: xs([.31, .01, .66, -.59]),
        backOut: xs([.33, 1.53, .69, .99])
    };
function Zy(e, t) {
    if (e)
        return typeof e == "function" && gl() ? SF(e, t) : cd(e) ? xs(e) : Array.isArray(e) ? e.map(n => Zy(n, t) || Df.easeOut) : Df[e]
}
function TF(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) {
    let c = {
        [t]: n
    };
    l && (c.offset = l);
    let u = Zy(a, i);
    return Array.isArray(u) && (c.easing = u),
        e.animate(c, {
            delay: r,
            duration: i,
            easing: Array.isArray(u) ? "linear" : u,
            fill: "both",
            iterations: o + 1,
            direction: s === "reverse" ? "alternate" : "normal"
        })
}
function dv(e, t) {
    e.timeline = t,
        e.onfinish = null
}
var RF = md(() => Object.hasOwnProperty.call(Element.prototype, "animate"))
    , vl = 10
    , EF = 2e4;
function FF(e) {
    return Cl(e.type) || e.type === "spring" || !Qy(e.ease)
}
function PF(e, t) {
    let n = new Rl({
        ...t,
        keyframes: e,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    })
        , r = {
            done: !1,
            value: e[0]
        }
        , i = []
        , o = 0;
    for (; !r.done && o < EF;)
        r = n.sample(o),
            i.push(r.value),
            o += vl;
    return {
        times: void 0,
        keyframes: i,
        duration: o - vl,
        ease: "linear"
    }
}
var Jy = {
    anticipate: Jf,
    backInOut: Zf,
    circInOut: td
};
function _F(e) {
    return e in Jy
}
var zf = class extends Ny {
    constructor(e) {
        super(e);
        let { name: t, motionValue: n, element: r, keyframes: i } = this.options;
        this.resolver = new Yy(i, (o, s) => this.onKeyframesResolved(o, s), t, n, r),
            this.resolver.scheduleResolve()
    }
    initPlayback(e, t) {
        var n;
        let { duration: r = 300, times: i, ease: o, type: s, motionValue: a, name: l, startTime: c } = this.options;
        if (!(!((n = a.owner) === null || n === void 0) && n.current))
            return !1;
        if (typeof o == "string" && gl() && _F(o) && (o = Jy[o]),
            FF(this.options)) {
            let { onComplete: f, onUpdate: d, motionValue: p, element: v, ...g } = this.options
                , b = PF(e, g);
            e = b.keyframes,
                e.length === 1 && (e[1] = e[0]),
                r = b.duration,
                i = b.times,
                o = b.ease,
                s = "keyframes"
        }
        let u = TF(a.owner.current, l, e, {
            ...this.options,
            duration: r,
            times: i,
            ease: o
        });
        return u.startTime = c ?? this.calcStartTime(),
            this.pendingTimeline ? (dv(u, this.pendingTimeline),
                this.pendingTimeline = void 0) : u.onfinish = () => {
                    let { onComplete: f } = this.options;
                    a.set(Tl(e, this.options, t)),
                        f && f(),
                        this.cancel(),
                        this.resolveFinishedPromise()
                }
            ,
        {
            animation: u,
            duration: r,
            times: i,
            type: s,
            ease: o,
            keyframes: e
        }
    }
    get duration() {
        let { resolved: e } = this;
        if (!e)
            return 0;
        let { duration: t } = e;
        return Yn(t)
    }
    get time() {
        let { resolved: e } = this;
        if (!e)
            return 0;
        let { animation: t } = e;
        return Yn(t.currentTime || 0)
    }
    set time(e) {
        let { resolved: t } = this;
        if (!t)
            return;
        let { animation: n } = t;
        n.currentTime = Mn(e)
    }
    get speed() {
        let { resolved: e } = this;
        if (!e)
            return 1;
        let { animation: t } = e;
        return t.playbackRate
    }
    set speed(e) {
        let { resolved: t } = this;
        if (!t)
            return;
        let { animation: n } = t;
        n.playbackRate = e
    }
    get state() {
        let { resolved: e } = this;
        if (!e)
            return "idle";
        let { animation: t } = e;
        return t.playState
    }
    get startTime() {
        let { resolved: e } = this;
        if (!e)
            return null;
        let { animation: t } = e;
        return t.startTime
    }
    attachTimeline(e) {
        if (!this._resolved)
            this.pendingTimeline = e;
        else {
            let { resolved: t } = this;
            if (!t)
                return wt;
            let { animation: n } = t;
            dv(n, e)
        }
        return wt
    }
    play() {
        if (this.isStopped)
            return;
        let { resolved: e } = this;
        if (!e)
            return;
        let { animation: t } = e;
        t.playState === "finished" && this.updateFinishedPromise(),
            t.play()
    }
    pause() {
        let { resolved: e } = this;
        if (!e)
            return;
        let { animation: t } = e;
        t.pause()
    }
    stop() {
        if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
            return;
        this.resolveFinishedPromise(),
            this.updateFinishedPromise();
        let { resolved: e } = this;
        if (!e)
            return;
        let { animation: t, keyframes: n, duration: r, type: i, ease: o, times: s } = e;
        if (t.playState === "idle" || t.playState === "finished")
            return;
        if (this.time) {
            let { motionValue: l, onUpdate: c, onComplete: u, element: f, ...d } = this.options
                , p = new Rl({
                    ...d,
                    keyframes: n,
                    duration: r,
                    type: i,
                    ease: o,
                    times: s,
                    isGenerator: !0
                })
                , v = Mn(this.time);
            l.setWithVelocity(p.sample(v - vl).value, p.sample(v).value, vl)
        }
        let { onStop: a } = this.options;
        a && a(),
            this.cancel()
    }
    complete() {
        let { resolved: e } = this;
        e && e.animation.finish()
    }
    cancel() {
        let { resolved: e } = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        let { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e;
        return RF() && n && Ky.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && s !== "inertia"
    }
}
    ;
function gd(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}
function El(e, t) {
    let n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
function IF([...e], t, n) {
    let r = t < 0 ? e.length + t : t;
    if (r >= 0 && r < e.length) {
        let i = n < 0 ? e.length + n : n
            , [o] = e.splice(t, 1);
        e.splice(i, 0, o)
    }
    return e
}
var vd = class {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return gd(this.subscriptions, e),
            () => El(this.subscriptions, e)
    }
    notify(e, t, n) {
        let r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](e, t, n);
            else
                for (let i = 0; i < r; i++) {
                    let o = this.subscriptions[i];
                    o && o(e, t, n)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
    , hv = 30
    , OF = e => !isNaN(parseFloat(e))
    , ks = {
        current: void 0
    }
    , Fl = class {
        constructor(e, t = {}) {
            this.version = "11.11.7",
                this.canTrackVelocity = null,
                this.events = {},
                this.updateAndNotify = (n, r = !0) => {
                    let i = Qn.now();
                    this.updatedAt !== i && this.setPrevFrameValue(),
                        this.prev = this.current,
                        this.setCurrent(n),
                        this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
                        r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                }
                ,
                this.hasAnimated = !1,
                this.setCurrent(e),
                this.owner = t.owner
        }
        setCurrent(e) {
            this.current = e,
                this.updatedAt = Qn.now(),
                this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = OF(this.current))
        }
        setPrevFrameValue(e = this.current) {
            this.prevFrameValue = e,
                this.prevUpdatedAt = this.updatedAt
        }
        onChange(e) {
            return this.on("change", e)
        }
        on(e, t) {
            this.events[e] || (this.events[e] = new vd);
            let n = this.events[e].add(t);
            return e === "change" ? () => {
                n(),
                    J.read(() => {
                        this.events.change.getSize() || this.stop()
                    }
                    )
            }
                : n
        }
        clearListeners() {
            for (let e in this.events)
                this.events[e].clear()
        }
        attach(e, t) {
            this.passiveEffect = e,
                this.stopPassiveEffect = t
        }
        set(e, t = !0) {
            !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
        }
        setWithVelocity(e, t, n) {
            this.set(t),
                this.prev = void 0,
                this.prevFrameValue = e,
                this.prevUpdatedAt = this.updatedAt - n
        }
        jump(e, t = !0) {
            this.updateAndNotify(e),
                this.prev = e,
                this.prevUpdatedAt = this.prevFrameValue = void 0,
                t && this.stop(),
                this.stopPassiveEffect && this.stopPassiveEffect()
        }
        get() {
            return ks.current && ks.current.push(this),
                this.current
        }
        getPrevious() {
            return this.prev
        }
        getVelocity() {
            let e = Qn.now();
            if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > hv)
                return 0;
            let t = Math.min(this.updatedAt - this.prevUpdatedAt, hv);
            return id(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
        }
        start(e) {
            return this.stop(),
                new Promise(t => {
                    this.hasAnimated = !0,
                        this.animation = e(t),
                        this.events.animationStart && this.events.animationStart.notify()
                }
                ).then(() => {
                    this.events.animationComplete && this.events.animationComplete.notify(),
                        this.clearAnimation()
                }
                )
        }
        stop() {
            this.animation && (this.animation.stop(),
                this.events.animationCancel && this.events.animationCancel.notify()),
                this.clearAnimation()
        }
        isAnimating() {
            return !!this.animation
        }
        clearAnimation() {
            delete this.animation
        }
        destroy() {
            this.clearListeners(),
                this.stop(),
                this.stopPassiveEffect && this.stopPassiveEffect()
        }
    }
    ;
function Xe(e, t) {
    return new Fl(e, t)
}
var Pl = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
    , MF = "framerAppearId"
    , _l = "data-" + Pl(MF)
    , Be = e => !!(e && e.getVelocity);
function pv(e) {
    let t = [{}, {}];
    return e?.values.forEach((n, r) => {
        t[0][r] = n.get(),
            t[1][r] = n.getVelocity()
    }
    ),
        t
}
function yd(e, t, n, r) {
    if (typeof t == "function") {
        let [i, o] = pv(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]),
        typeof t == "function") {
        let [i, o] = pv(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    return t
}
function Il(e, t, n) {
    let r = e.getProps();
    return yd(r, t, n !== void 0 ? n : r.custom, e)
}
var LF = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
    , VF = e => ({
        type: "spring",
        stiffness: 550,
        damping: e === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    })
    , AF = {
        type: "keyframes",
        duration: .8
    }
    , DF = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    }
    , zF = (e, { keyframes: t }) => t.length > 2 ? AF : Wr.has(e) ? e.startsWith("scale") ? VF(t[1]) : LF : DF;
function bd(e, t) {
    return e ? e[t] || e.default || e : void 0
}
var e0 = md(() => I.ScrollTimeline !== void 0)
    , t0 = class {
        constructor(e) {
            this.stop = () => this.runAll("stop"),
                this.animations = e.filter(Boolean)
        }
        then(e, t) {
            return Promise.all(this.animations).then(e).catch(t)
        }
        getAll(e) {
            return this.animations[0][e]
        }
        setAll(e, t) {
            for (let n = 0; n < this.animations.length; n++)
                this.animations[n][e] = t
        }
        attachTimeline(e, t) {
            let n = this.animations.map(r => e0() && r.attachTimeline ? r.attachTimeline(e) : t(r));
            return () => {
                n.forEach((r, i) => {
                    r && r(),
                        this.animations[i].stop()
                }
                )
            }
        }
        get time() {
            return this.getAll("time")
        }
        set time(e) {
            this.setAll("time", e)
        }
        get speed() {
            return this.getAll("speed")
        }
        set speed(e) {
            this.setAll("speed", e)
        }
        get startTime() {
            return this.getAll("startTime")
        }
        get duration() {
            let e = 0;
            for (let t = 0; t < this.animations.length; t++)
                e = Math.max(e, this.animations[t].duration);
            return e
        }
        runAll(e) {
            this.animations.forEach(t => t[e]())
        }
        play() {
            this.runAll("play")
        }
        pause() {
            this.runAll("pause")
        }
        cancel() {
            this.runAll("cancel")
        }
        complete() {
            this.runAll("complete")
        }
    }
    ;
function BF({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) {
    return !!Object.keys(u).length
}
var xd = (e, t, n, r = {}, i, o) => s => {
    let a = bd(r, e) || {}
        , l = a.delay || r.delay || 0
        , { elapsed: c = 0 } = r;
    c = c - Mn(l);
    let u = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: t.getVelocity(),
        ...a,
        delay: -c,
        onUpdate: d => {
            t.set(d),
                a.onUpdate && a.onUpdate(d)
        }
        ,
        onComplete: () => {
            s(),
                a.onComplete && a.onComplete()
        }
        ,
        name: e,
        motionValue: t,
        element: o ? void 0 : i
    };
    BF(a) || (u = {
        ...u,
        ...zF(e, u)
    }),
        u.duration && (u.duration = Mn(u.duration)),
        u.repeatDelay && (u.repeatDelay = Mn(u.repeatDelay)),
        u.from !== void 0 && (u.keyframes[0] = u.from);
    let f = !1;
    if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0,
        u.delay === 0 && (f = !0)),
        (ml.current || wl.skipAnimations) && (f = !0,
            u.duration = 0,
            u.delay = 0),
        f && !o && t.get() !== void 0) {
        let d = Tl(u.keyframes, a);
        if (d !== void 0)
            return J.update(() => {
                u.onUpdate(d),
                    u.onComplete()
            }
            ),
                new t0([])
    }
    return !o && zf.supports(u) ? new zf(u) : new Rl(u)
}
    , Bf = e => Array.isArray(e)
    , $F = e => !!(e && typeof e == "object" && e.mix && e.toValue)
    , NF = e => Bf(e) ? e[e.length - 1] || 0 : e;
function jF(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Xe(n))
}
function wd(e, t) {
    let n = Il(e, t)
        , { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
    o = {
        ...o,
        ...r
    };
    for (let s in o) {
        let a = NF(o[s]);
        jF(e, s, a)
    }
}
function n0(e) {
    return e.props[_l]
}
function HF(e) {
    return !!(Be(e) && e.add)
}
function r0(e) {
    if (Wr.has(e))
        return "transform";
    if (Ky.has(e))
        return Pl(e)
}
function $f(e, t) {
    var n;
    if (!e.applyWillChange)
        return;
    let r = e.getValue("willChange");
    if (HF(r))
        return r.add(t);
    !(!((n = e.props.style) === null || n === void 0) && n.willChange) && r0(t) && e.setStaticValue("willChange", "transform")
}
function WF({ protectedKeys: e, needsAnimating: t }, n) {
    let r = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1,
        r
}
function Sd(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
    var o;
    let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t;
    r && (s = r);
    let c = []
        , u = i && e.animationState && e.animationState.getState()[i];
    for (let f in l) {
        let d = e.getValue(f, (o = e.latestValues[f]) !== null && o !== void 0 ? o : null)
            , p = l[f];
        if (p === void 0 || u && WF(u, f))
            continue;
        let v = {
            delay: n,
            ...bd(s || {}, f)
        }
            , g = !1;
        if (I.MotionHandoffAnimation) {
            let m = n0(e);
            if (m) {
                let h = I.MotionHandoffAnimation(m, f, J);
                h !== null && (v.startTime = h,
                    g = !0)
            }
        }
        $f(e, f),
            d.start(xd(f, d, p, e.shouldReduceMotion && Wr.has(f) ? {
                type: !1
            } : v, e, g));
        let b = d.animation;
        b && c.push(b)
    }
    return a && Promise.all(c).then(() => {
        J.update(() => {
            a && wd(e, a)
        }
        )
    }
    ),
        c
}
function Nf(e, t, n = {}) {
    var r;
    let i = Il(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0)
        , { transition: o = e.getDefaultTransition() || {} } = i || {};
    n.transitionOverride && (o = n.transitionOverride);
    let s = i ? () => Promise.all(Sd(e, i, n)) : () => Promise.resolve()
        , a = e.variantChildren && e.variantChildren.size ? (c = 0) => {
            let { delayChildren: u = 0, staggerChildren: f, staggerDirection: d } = o;
            return UF(e, t, u + c, f, d, n)
        }
            : () => Promise.resolve()
        , { when: l } = o;
    if (l) {
        let [c, u] = l === "beforeChildren" ? [s, a] : [a, s];
        return c().then(() => u())
    } else
        return Promise.all([s(), a(n.delay)])
}
function UF(e, t, n = 0, r = 0, i = 1, o) {
    let s = []
        , a = (e.variantChildren.size - 1) * r
        , l = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r;
    return Array.from(e.variantChildren).sort(GF).forEach((c, u) => {
        c.notify("AnimationStart", t),
            s.push(Nf(c, t, {
                ...o,
                delay: n + l(u)
            }).then(() => c.notify("AnimationComplete", t)))
    }
    ),
        Promise.all(s)
}
function GF(e, t) {
    return e.sortNodePosition(t)
}
function kd(e, t, n = {}) {
    e.notify("AnimationStart", t);
    let r;
    if (Array.isArray(t)) {
        let i = t.map(o => Nf(e, o, n));
        r = Promise.all(i)
    } else if (typeof t == "string")
        r = Nf(e, t, n);
    else {
        let i = typeof t == "function" ? Il(e, t, n.custom) : t;
        r = Promise.all(Sd(e, i, n))
    }
    return r.then(() => {
        e.notify("AnimationComplete", t)
    }
    )
}
function _s(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
}
function i0(e, t) {
    if (!Array.isArray(t))
        return !1;
    let n = t.length;
    if (n !== e.length)
        return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function Is(e) {
    return typeof e == "string" || Array.isArray(e)
}
var Cd = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
    , Td = ["initial", ...Cd]
    , qF = Td.length;
function o0(e) {
    if (!e)
        return;
    if (!e.isControllingVariants) {
        let n = e.parent ? o0(e.parent) || {} : {};
        return e.props.initial !== void 0 && (n.initial = e.props.initial),
            n
    }
    let t = {};
    for (let n = 0; n < qF; n++) {
        let r = Td[n]
            , i = e.props[r];
        (Is(i) || i === !1) && (t[r] = i)
    }
    return t
}
var XF = [...Cd].reverse()
    , YF = Cd.length;
function KF(e) {
    return t => Promise.all(t.map(({ animation: n, options: r }) => kd(e, n, r)))
}
function QF(e) {
    let t = KF(e)
        , n = mv()
        , r = !0
        , i = l => (c, u) => {
            var f;
            let d = Il(e, u, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0);
            if (d) {
                let { transition: p, transitionEnd: v, ...g } = d;
                c = {
                    ...c,
                    ...g,
                    ...v
                }
            }
            return c
        }
        ;
    function o(l) {
        t = l(e)
    }
    function s(l) {
        let { props: c } = e
            , u = o0(e.parent) || {}
            , f = []
            , d = new Set
            , p = {}
            , v = 1 / 0;
        for (let b = 0; b < YF; b++) {
            let m = XF[b]
                , h = n[m]
                , y = c[m] !== void 0 ? c[m] : u[m]
                , w = Is(y)
                , C = m === l ? h.isActive : null;
            C === !1 && (v = b);
            let S = y === u[m] && y !== c[m] && w;
            if (S && r && e.manuallyAnimateOnMount && (S = !1),
                h.protectedKeys = {
                    ...p
                },
                !h.isActive && C === null || !y && !h.prevProp || _s(y) || typeof y == "boolean")
                continue;
            let T = ZF(h.prevProp, y)
                , R = T || m === l && h.isActive && !S && w || b > v && w
                , F = !1
                , P = Array.isArray(y) ? y : [y]
                , B = P.reduce(i(m), {});
            C === !1 && (B = {});
            let { prevResolvedValues: $ = {} } = h
                , N = {
                    ...$,
                    ...B
                }
                , U = te => {
                    R = !0,
                        d.has(te) && (F = !0,
                            d.delete(te)),
                        h.needsAnimating[te] = !0;
                    let Y = e.getValue(te);
                    Y && (Y.liveStyle = !1)
                }
                ;
            for (let te in N) {
                let Y = B[te]
                    , ne = $[te];
                if (p.hasOwnProperty(te))
                    continue;
                let G = !1;
                Bf(Y) && Bf(ne) ? G = !i0(Y, ne) : G = Y !== ne,
                    G ? Y != null ? U(te) : d.add(te) : Y !== void 0 && d.has(te) ? U(te) : h.protectedKeys[te] = !0
            }
            h.prevProp = y,
                h.prevResolvedValues = B,
                h.isActive && (p = {
                    ...p,
                    ...B
                }),
                r && e.blockInitialAnimation && (R = !1),
                R && (!(S && T) || F) && f.push(...P.map(te => ({
                    animation: te,
                    options: {
                        type: m
                    }
                })))
        }
        if (d.size) {
            let b = {};
            d.forEach(m => {
                let h = e.getBaseTarget(m)
                    , y = e.getValue(m);
                y && (y.liveStyle = !0),
                    b[m] = h ?? null
            }
            ),
                f.push({
                    animation: b
                })
        }
        let g = !!f.length;
        return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1),
            r = !1,
            g ? t(f) : Promise.resolve()
    }
    function a(l, c) {
        var u;
        if (n[l].isActive === c)
            return Promise.resolve();
        (u = e.variantChildren) === null || u === void 0 || u.forEach(d => {
            var p;
            return (p = d.animationState) === null || p === void 0 ? void 0 : p.setActive(l, c)
        }
        ),
            n[l].isActive = c;
        let f = s(l);
        for (let d in n)
            n[d].protectedKeys = {};
        return f
    }
    return {
        animateChanges: s,
        setActive: a,
        setAnimateFunction: o,
        getState: () => n,
        reset: () => {
            n = mv(),
                r = !0
        }
    }
}
function ZF(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !i0(t, e) : !1
}
function Si(e = !1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function mv() {
    return {
        animate: Si(!0),
        whileInView: Si(),
        whileHover: Si(),
        whileTap: Si(),
        whileDrag: Si(),
        whileFocus: Si(),
        exit: Si()
    }
}
var Ur = class {
    constructor(e) {
        this.isMounted = !1,
            this.node = e
    }
    update() { }
}
    , JF = class extends Ur {
        constructor(e) {
            super(e),
                e.animationState || (e.animationState = QF(e))
        }
        updateAnimationControlsSubscription() {
            let { animate: e } = this.node.getProps();
            _s(e) && (this.unmountControls = e.subscribe(this.node))
        }
        mount() {
            this.updateAnimationControlsSubscription()
        }
        update() {
            let { animate: e } = this.node.getProps()
                , { animate: t } = this.node.prevProps || {};
            e !== t && this.updateAnimationControlsSubscription()
        }
        unmount() {
            var e;
            this.node.animationState.reset(),
                (e = this.unmountControls) === null || e === void 0 || e.call(this)
        }
    }
    , eP = 0
    , tP = class extends Ur {
        constructor() {
            super(...arguments),
                this.id = eP++
        }
        update() {
            if (!this.node.presenceContext)
                return;
            let { isPresent: e, onExitComplete: t } = this.node.presenceContext
                , { isPresent: n } = this.node.prevPresenceContext || {};
            if (!this.node.animationState || e === n)
                return;
            let r = this.node.animationState.setActive("exit", !e);
            t && !e && r.then(() => t(this.id))
        }
        mount() {
            let { register: e } = this.node.presenceContext || {};
            e && (this.unmount = e(this.id))
        }
        unmount() { }
    }
    , Ol = {
        animation: {
            Feature: JF
        },
        exit: {
            Feature: tP
        }
    }
    , s0 = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function Ml(e, t = "page") {
    return {
        point: {
            x: e[`${t}X`],
            y: e[`${t}Y`]
        }
    }
}
var a0 = e => t => s0(t) && e(t, Ml(t));
function wr(e, t, n, r = {
    passive: !0
}) {
    return e.addEventListener(t, n, r),
        () => e.removeEventListener(t, n)
}
function Zn(e, t, n, r) {
    return wr(e, t, a0(n), r)
}
var jf = (e, t) => Math.abs(e - t);
function l0(e, t) {
    let n = jf(e.x, t.x)
        , r = jf(e.y, t.y);
    return Math.sqrt(n ** 2 + r ** 2)
}
function c0(e) {
    let t = null;
    return () => {
        let n = () => {
            t = null
        }
            ;
        return t === null ? (t = e,
            n) : !1
    }
}
var gv = c0("dragHorizontal")
    , vv = c0("dragVertical");
function u0(e) {
    let t = !1;
    if (e === "y")
        t = vv();
    else if (e === "x")
        t = gv();
    else {
        let n = gv()
            , r = vv();
        n && r ? t = () => {
            n(),
                r()
        }
            : (n && n(),
                r && r())
    }
    return t
}
function Rd() {
    let e = u0(!0);
    return e ? (e(),
        !1) : !0
}
var f0 = 1e-4
    , nP = 1 - f0
    , rP = 1 + f0
    , d0 = .01
    , iP = 0 - d0
    , oP = 0 + d0;
function Ut(e) {
    return e.max - e.min
}
function sP(e, t, n) {
    return Math.abs(e - t) <= n
}
function yv(e, t, n, r = .5) {
    e.origin = r,
        e.originPoint = Le(t.min, t.max, e.origin),
        e.scale = Ut(n) / Ut(t),
        e.translate = Le(n.min, n.max, e.origin) - e.originPoint,
        (e.scale >= nP && e.scale <= rP || isNaN(e.scale)) && (e.scale = 1),
        (e.translate >= iP && e.translate <= oP || isNaN(e.translate)) && (e.translate = 0)
}
function Cs(e, t, n, r) {
    yv(e.x, t.x, n.x, r ? r.originX : void 0),
        yv(e.y, t.y, n.y, r ? r.originY : void 0)
}
function bv(e, t, n) {
    e.min = n.min + t.min,
        e.max = e.min + Ut(t)
}
function aP(e, t, n) {
    bv(e.x, t.x, n.x),
        bv(e.y, t.y, n.y)
}
function xv(e, t, n) {
    e.min = t.min - n.min,
        e.max = e.min + Ut(t)
}
function Ts(e, t, n) {
    xv(e.x, t.x, n.x),
        xv(e.y, t.y, n.y)
}
var wv = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
    , lo = () => ({
        x: wv(),
        y: wv()
    })
    , Sv = () => ({
        min: 0,
        max: 0
    })
    , je = () => ({
        x: Sv(),
        y: Sv()
    })
    , xo = be(null);
function Ed() {
    let e = D(xo);
    if (e === null)
        return [!0, null];
    let { isPresent: t, onExitComplete: n, register: r } = e
        , i = wi();
    H(() => r(i), []);
    let o = Q(() => n && n(i), [i, n]);
    return !t && n ? [!1, o] : [!0]
}
var Os = be({})
    , Ll = be({})
    , yl = {};
function Fd(e) {
    Object.assign(yl, e)
}
var lP = (e, t) => e.depth - t.depth
    , h0 = class {
        constructor() {
            this.children = [],
                this.isDirty = !1
        }
        add(e) {
            gd(this.children, e),
                this.isDirty = !0
        }
        remove(e) {
            El(this.children, e),
                this.isDirty = !0
        }
        forEach(e) {
            this.isDirty && this.children.sort(lP),
                this.isDirty = !1,
                this.children.forEach(e)
        }
    }
    ;
function Et(e) {
    let t = Be(e) ? e.get() : e;
    return $F(t) ? t.toValue() : t
}
function p0(e, t) {
    let n = Qn.now()
        , r = ({ timestamp: i }) => {
            let o = i - n;
            o >= t && (Ft(r),
                e(o - t))
        }
        ;
    return J.read(r, !0),
        () => Ft(r)
}
var Jn = be({
    transformPagePoint: e => e,
    isStatic: !1,
    reducedMotion: "never"
})
    , As = be({})
    , Vl = typeof I < "u"
    , Gr = Vl ? ze : H
    , m0 = be({
        strict: !1
    })
    , { schedule: Pd, cancel: x6 } = ky(queueMicrotask, !1);
function co(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}
function cP(e, t, n, r, i) {
    var o, s;
    let { visualElement: a } = D(As)
        , l = D(m0)
        , c = D(xo)
        , u = D(Jn).reducedMotion
        , f = V();
    r = r || l.renderer,
        !f.current && r && (f.current = r(e, {
            visualState: t,
            parent: a,
            props: n,
            presenceContext: c,
            blockInitialAnimation: c ? c.initial === !1 : !1,
            reducedMotionConfig: u
        }));
    let d = f.current
        , p = D(Ll);
    d && !d.projection && i && (d.type === "html" || d.type === "svg") && uP(f.current, n, i, p),
        ht(() => {
            d && d.update(n, c)
        }
        );
    let v = n[_l]
        , g = V(!!v && !(!((o = I.MotionHandoffIsComplete) === null || o === void 0) && o.call(I, v)) && ((s = I.MotionHasOptimisedAnimation) === null || s === void 0 ? void 0 : s.call(I, v)));
    return Gr(() => {
        d && (I.MotionIsMounted = !0,
            d.updateFeatures(),
            Pd.render(d.render),
            g.current && d.animationState && d.animationState.animateChanges())
    }
    ),
        H(() => {
            d && (!g.current && d.animationState && d.animationState.animateChanges(),
                g.current && (queueMicrotask(() => {
                    var b;
                    (b = I.MotionHandoffMarkAsComplete) === null || b === void 0 || b.call(I, v)
                }
                ),
                    g.current = !1))
        }
        ),
        d
}
function uP(e, t, n, r) {
    let { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t;
    e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : g0(e.parent)),
        e.projection.setOptions({
            layoutId: i,
            layout: o,
            alwaysMeasureLayout: !!s || a && co(a),
            visualElement: e,
            animationType: typeof o == "string" ? o : "both",
            initialPromotionConfig: r,
            layoutScroll: l,
            layoutRoot: c
        })
}
function g0(e) {
    if (e)
        return e.options.allowProjection !== !1 ? e.projection : g0(e.parent)
}
function fP(e, t, n) {
    return Q(r => {
        r && e.mount && e.mount(r),
            t && (r ? t.mount(r) : t.unmount()),
            n && (typeof n == "function" ? n(r) : co(n) && (n.current = r))
    }
        , [t])
}
function Al(e) {
    return _s(e.animate) || Td.some(t => Is(e[t]))
}
function v0(e) {
    return !!(Al(e) || e.variants)
}
function dP(e, t) {
    if (Al(e)) {
        let { initial: n, animate: r } = e;
        return {
            initial: n === !1 || Is(n) ? n : void 0,
            animate: Is(r) ? r : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}
function hP(e) {
    let { initial: t, animate: n } = dP(e, D(As));
    return ue(() => ({
        initial: t,
        animate: n
    }), [kv(t), kv(n)])
}
function kv(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
var Cv = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
    , po = {};
for (let e in Cv)
    po[e] = {
        isEnabled: t => Cv[e].some(n => !!t[n])
    };
function pP(e) {
    for (let t in e)
        po[t] = {
            ...po[t],
            ...e[t]
        }
}
var _d = Symbol.for("motionComponentSymbol");
function y0({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) {
    e && pP(e);
    function o(a, l) {
        let c, u = {
            ...D(Jn),
            ...a,
            layoutId: mP(a)
        }, { isStatic: f } = u, d = hP(a), p = r(a, f);
        if (!f && Vl) {
            gP(u, e);
            let v = vP(u);
            c = v.MeasureLayout,
                d.visualElement = cP(i, p, u, t, v.ProjectionNode)
        }
        return ge(As.Provider, {
            value: d,
            children: [c && d.visualElement ? k(c, {
                visualElement: d.visualElement,
                ...u
            }) : null, n(i, a, fP(p, d.visualElement, l), p, f, d.visualElement)]
        })
    }
    let s = Ie(o);
    return s[_d] = i,
        s
}
function mP({ layoutId: e }) {
    let t = D(Os).id;
    return t && e !== void 0 ? t + "-" + e : e
}
function gP(e, t) {
    let n = D(m0).strict
}
function vP(e) {
    let { drag: t, layout: n } = po;
    if (!t && !n)
        return {};
    let r = {
        ...t,
        ...n
    };
    return {
        MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0,
        ProjectionNode: r.ProjectionNode
    }
}
function tr(e) {
    let t = V(null);
    return t.current === null && (t.current = e()),
        t.current
}
function yP({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r }, i, o, s, a) {
    let l = {
        latestValues: bP(i, o, s, a ? !1 : e, t),
        renderState: n()
    };
    return r && (l.mount = c => r(i, c, l)),
        l
}
var Dl = e => (t, n) => {
    let r = D(As)
        , i = D(xo)
        , o = () => yP(e, t, r, i, n);
    return n ? o() : tr(o)
}
    ;
function Tv(e, t, n) {
    let r = Array.isArray(t) ? t : [t];
    for (let i = 0; i < r.length; i++) {
        let o = yd(e, r[i]);
        if (o) {
            let { transitionEnd: s, transition: a, ...l } = o;
            n(l, s)
        }
    }
}
function bP(e, t, n, r, i) {
    var o;
    let s = {}
        , a = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0
        , l = i(e, {});
    for (let g in l)
        s[g] = Et(l[g]);
    let { initial: c, animate: u } = e
        , f = Al(e)
        , d = v0(e);
    t && d && !f && e.inherit !== !1 && (c === void 0 && (c = t.initial),
        u === void 0 && (u = t.animate));
    let p = n ? n.initial === !1 : !1;
    p = p || c === !1;
    let v = p ? u : c;
    return v && typeof v != "boolean" && !_s(v) && Tv(e, v, (g, b) => {
        for (let m in g) {
            let h = g[m];
            if (Array.isArray(h)) {
                let y = p ? h.length - 1 : 0;
                h = h[y]
            }
            h !== null && (s[m] = h)
        }
        for (let m in b)
            s[m] = b[m]
    }
    ),
        a && u && c !== !1 && !_s(u) && Tv(e, u, g => {
            for (let b in g)
                if (r0(b)) {
                    s.willChange = "transform";
                    return
                }
        }
        ),
        s
}
var b0 = (e, t) => t && typeof e == "number" ? t.transform(e) : e
    , xP = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    }
    , wP = Vs.length;
function x0(e, t, n) {
    let r = ""
        , i = !0;
    for (let o = 0; o < wP; o++) {
        let s = Vs[o]
            , a = e[s];
        if (a === void 0)
            continue;
        let l = !0;
        if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0,
            !l || n) {
            let c = b0(a, hd[s]);
            if (!l) {
                i = !1;
                let u = xP[s] || s;
                r += `${u}(${c}) `
            }
            n && (t[s] = c)
        }
    }
    return r = r.trim(),
        n ? r = n(t, i ? "" : r) : i && (r = "none"),
        r
}
var SP = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function mo(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || SP.has(e)
}
var w0 = e => !mo(e);
function S0(e) {
    e && (w0 = t => t.startsWith("on") ? !mo(t) : e(t))
}
try {
    S0(aE().default)
} catch { }
function k0(e, t, n) {
    let r = {};
    for (let i in e)
        i === "values" && typeof e.values == "object" || (w0(i) || n === !0 && mo(i) || !t && !mo(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
    return r
}
var er = new WeakMap
    , bl = {
        current: null
    }
    , Id = {
        current: !1
    };
function C0() {
    if (Id.current = !0,
        !!Vl)
        if (I.matchMedia) {
            let e = I.matchMedia("(prefers-reduced-motion)")
                , t = () => bl.current = e.matches;
            e.addListener(t),
                t()
        } else
            bl.current = !1
}
function kP(e, t, n) {
    for (let r in t) {
        let i = t[r]
            , o = n[r];
        if (Be(i))
            e.addValue(r, i);
        else if (Be(o))
            e.addValue(r, Xe(i, {
                owner: e
            }));
        else if (o !== i)
            if (e.hasValue(r)) {
                let s = e.getValue(r);
                s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i)
            } else {
                let s = e.getStaticValue(r);
                e.addValue(r, Xe(s !== void 0 ? s : i, {
                    owner: e
                }))
            }
    }
    for (let r in n)
        t[r] === void 0 && e.removeValue(r);
    return t
}
var CP = [...qy, xt, kr]
    , TP = e => CP.find(Gy(e))
    , Rv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
    , Od = class {
        scrapeMotionValuesFromProps(e, t, n) {
            return {}
        }
        constructor({ parent: e, props: t, presenceContext: n, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o }, s = {}) {
            this.applyWillChange = !1,
                this.current = null,
                this.children = new Set,
                this.isVariantNode = !1,
                this.isControllingVariants = !1,
                this.shouldReduceMotion = null,
                this.values = new Map,
                this.KeyframeResolver = fd,
                this.features = {},
                this.valueSubscriptions = new Map,
                this.prevMotionValues = {},
                this.events = {},
                this.propEventSubscriptions = {},
                this.notifyUpdate = () => this.notify("Update", this.latestValues),
                this.render = () => {
                    this.current && (this.triggerBuild(),
                        this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                }
                ,
                this.renderScheduledAt = 0,
                this.scheduleRender = () => {
                    let f = Qn.now();
                    this.renderScheduledAt < f && (this.renderScheduledAt = f,
                        J.render(this.render, !1, !0))
                }
                ;
            let { latestValues: a, renderState: l } = o;
            this.latestValues = a,
                this.baseTarget = {
                    ...a
                },
                this.initialValues = t.initial ? {
                    ...a
                } : {},
                this.renderState = l,
                this.parent = e,
                this.props = t,
                this.presenceContext = n,
                this.depth = e ? e.depth + 1 : 0,
                this.reducedMotionConfig = r,
                this.options = s,
                this.blockInitialAnimation = !!i,
                this.isControllingVariants = Al(t),
                this.isVariantNode = v0(t),
                this.isVariantNode && (this.variantChildren = new Set),
                this.manuallyAnimateOnMount = !!(e && e.current);
            let { willChange: c, ...u } = this.scrapeMotionValuesFromProps(t, {}, this);
            for (let f in u) {
                let d = u[f];
                a[f] !== void 0 && Be(d) && d.set(a[f], !1)
            }
        }
        mount(e) {
            this.current = e,
                er.set(e, this),
                this.projection && !this.projection.instance && this.projection.mount(e),
                this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
                this.values.forEach((t, n) => this.bindToMotionValue(n, t)),
                Id.current || C0(),
                this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : bl.current,
                this.parent && this.parent.children.add(this),
                this.update(this.props, this.presenceContext)
        }
        unmount() {
            er.delete(this.current),
                this.projection && this.projection.unmount(),
                Ft(this.notifyUpdate),
                Ft(this.render),
                this.valueSubscriptions.forEach(e => e()),
                this.valueSubscriptions.clear(),
                this.removeFromVariantTree && this.removeFromVariantTree(),
                this.parent && this.parent.children.delete(this);
            for (let e in this.events)
                this.events[e].clear();
            for (let e in this.features) {
                let t = this.features[e];
                t && (t.unmount(),
                    t.isMounted = !1)
            }
            this.current = null
        }
        bindToMotionValue(e, t) {
            this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
            let n = Wr.has(e), r = t.on("change", s => {
                this.latestValues[e] = s,
                    this.props.onUpdate && J.preRender(this.notifyUpdate),
                    n && this.projection && (this.projection.isTransformDirty = !0)
            }
            ), i = t.on("renderRequest", this.scheduleRender), o;
            I.MotionCheckAppearSync && (o = I.MotionCheckAppearSync(this, e, t)),
                this.valueSubscriptions.set(e, () => {
                    r(),
                        i(),
                        o && o(),
                        t.owner && t.stop()
                }
                )
        }
        sortNodePosition(e) {
            return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
        }
        updateFeatures() {
            let e = "animation";
            for (e in po) {
                let t = po[e];
                if (!t)
                    continue;
                let { isEnabled: n, Feature: r } = t;
                if (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)),
                    this.features[e]) {
                    let i = this.features[e];
                    i.isMounted ? i.update() : (i.mount(),
                        i.isMounted = !0)
                }
            }
        }
        triggerBuild() {
            this.build(this.renderState, this.latestValues, this.props)
        }
        measureViewportBox() {
            return this.current ? this.measureInstanceViewportBox(this.current, this.props) : je()
        }
        getStaticValue(e) {
            return this.latestValues[e]
        }
        setStaticValue(e, t) {
            this.latestValues[e] = t
        }
        update(e, t) {
            (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
                this.prevProps = this.props,
                this.props = e,
                this.prevPresenceContext = this.presenceContext,
                this.presenceContext = t;
            for (let n = 0; n < Rv.length; n++) {
                let r = Rv[n];
                this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
                    delete this.propEventSubscriptions[r]);
                let i = "on" + r
                    , o = e[i];
                o && (this.propEventSubscriptions[r] = this.on(r, o))
            }
            this.prevMotionValues = kP(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
                this.handleChildMotionValue && this.handleChildMotionValue()
        }
        getProps() {
            return this.props
        }
        getVariant(e) {
            return this.props.variants ? this.props.variants[e] : void 0
        }
        getDefaultTransition() {
            return this.props.transition
        }
        getTransformPagePoint() {
            return this.props.transformPagePoint
        }
        getClosestVariantNode() {
            return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
        }
        addVariantChild(e) {
            let t = this.getClosestVariantNode();
            if (t)
                return t.variantChildren && t.variantChildren.add(e),
                    () => t.variantChildren.delete(e)
        }
        addValue(e, t) {
            let n = this.values.get(e);
            t !== n && (n && this.removeValue(e),
                this.bindToMotionValue(e, t),
                this.values.set(e, t),
                this.latestValues[e] = t.get())
        }
        removeValue(e) {
            this.values.delete(e);
            let t = this.valueSubscriptions.get(e);
            t && (t(),
                this.valueSubscriptions.delete(e)),
                delete this.latestValues[e],
                this.removeValueFromRenderState(e, this.renderState)
        }
        hasValue(e) {
            return this.values.has(e)
        }
        getValue(e, t) {
            if (this.props.values && this.props.values[e])
                return this.props.values[e];
            let n = this.values.get(e);
            return n === void 0 && t !== void 0 && (n = Xe(t === null ? void 0 : t, {
                owner: this
            }),
                this.addValue(e, n)),
                n
        }
        readValue(e, t) {
            var n;
            let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
            return r != null && (typeof r == "string" && (Wy(r) || Hy(r)) ? r = parseFloat(r) : !TP(r) && kr.test(t) && (r = Xy(e, t)),
                this.setBaseTarget(e, Be(r) ? r.get() : r)),
                Be(r) ? r.get() : r
        }
        setBaseTarget(e, t) {
            this.baseTarget[e] = t
        }
        getBaseTarget(e) {
            var t;
            let { initial: n } = this.props, r;
            if (typeof n == "string" || typeof n == "object") {
                let o = yd(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom);
                o && (r = o[e])
            }
            if (n && r !== void 0)
                return r;
            let i = this.getBaseTargetFromProps(this.props, e);
            return i !== void 0 && !Be(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e]
        }
        on(e, t) {
            return this.events[e] || (this.events[e] = new vd),
                this.events[e].add(t)
        }
        notify(e, ...t) {
            this.events[e] && this.events[e].notify(...t)
        }
    }
    ;
function RP(e) {
    if (typeof Proxy > "u")
        return e;
    let t = new Map
        , n = (...r) => e(...r);
    return new Proxy(n, {
        get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)),
            t.get(i))
    })
}
var T0 = class {
    constructor(e, t, { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = {}) {
        if (this.startEvent = null,
            this.lastMoveEvent = null,
            this.lastMoveEventInfo = null,
            this.handlers = {},
            this.contextWindow = I,
            this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                let u = xf(this.lastMoveEventInfo, this.history)
                    , f = this.startEvent !== null
                    , d = l0(u.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!f && !d)
                    return;
                let { point: p } = u
                    , { timestamp: v } = qe;
                this.history.push({
                    ...p,
                    timestamp: v
                });
                let { onStart: g, onMove: b } = this.handlers;
                f || (g && g(this.lastMoveEvent, u),
                    this.startEvent = this.lastMoveEvent),
                    b && b(this.lastMoveEvent, u)
            }
            ,
            this.handlePointerMove = (u, f) => {
                this.lastMoveEvent = u,
                    this.lastMoveEventInfo = bf(f, this.transformPagePoint),
                    J.update(this.updatePoint, !0)
            }
            ,
            this.handlePointerUp = (u, f) => {
                this.end();
                let { onEnd: d, onSessionEnd: p, resumeAnimation: v } = this.handlers;
                if (this.dragSnapToOrigin && v && v(),
                    !(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                let g = xf(u.type === "pointercancel" ? this.lastMoveEventInfo : bf(f, this.transformPagePoint), this.history);
                this.startEvent && d && d(u, g),
                    p && p(u, g)
            }
            ,
            !s0(e))
            return;
        this.dragSnapToOrigin = i,
            this.handlers = t,
            this.transformPagePoint = n,
            this.contextWindow = r || I;
        let o = Ml(e)
            , s = bf(o, this.transformPagePoint)
            , { point: a } = s
            , { timestamp: l } = qe;
        this.history = [{
            ...a,
            timestamp: l
        }];
        let { onSessionStart: c } = t;
        c && c(e, xf(s, this.history)),
            this.removeListeners = Kn(Zn(this.contextWindow, "pointermove", this.handlePointerMove), Zn(this.contextWindow, "pointerup", this.handlePointerUp), Zn(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
            Ft(this.updatePoint)
    }
}
    ;
function bf(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}
function Ev(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}
function xf({ point: e }, t) {
    return {
        point: e,
        delta: Ev(e, R0(t)),
        offset: Ev(e, EP(t)),
        velocity: FP(t, .1)
    }
}
function EP(e) {
    return e[0]
}
function R0(e) {
    return e[e.length - 1]
}
function FP(e, t) {
    if (e.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = e.length - 1
        , r = null
        , i = R0(e);
    for (; n >= 0 && (r = e[n],
        !(i.timestamp - r.timestamp > Mn(t)));)
        n--;
    if (!r)
        return {
            x: 0,
            y: 0
        };
    let o = Yn(i.timestamp - r.timestamp);
    if (o === 0)
        return {
            x: 0,
            y: 0
        };
    let s = {
        x: (i.x - r.x) / o,
        y: (i.y - r.y) / o
    };
    return s.x === 1 / 0 && (s.x = 0),
        s.y === 1 / 0 && (s.y = 0),
        s
}
function PP(e, { min: t, max: n }, r) {
    return t !== void 0 && e < t ? e = r ? Le(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Le(n, e, r.max) : Math.min(e, n)),
        e
}
function Fv(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}
function _P(e, { top: t, left: n, bottom: r, right: i }) {
    return {
        x: Fv(e.x, n, i),
        y: Fv(e.y, t, r)
    }
}
function Pv(e, t) {
    let n = t.min - e.min
        , r = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n, r] = [r, n]),
    {
        min: n,
        max: r
    }
}
function IP(e, t) {
    return {
        x: Pv(e.x, t.x),
        y: Pv(e.y, t.y)
    }
}
function OP(e, t) {
    let n = .5
        , r = Ut(e)
        , i = Ut(t);
    return i > r ? n = Cr(t.min, t.max - r, e.min) : r > i && (n = Cr(e.min, e.max - i, t.min)),
        Sr(0, 1, n)
}
function MP(e, t) {
    let n = {};
    return t.min !== void 0 && (n.min = t.min - e.min),
        t.max !== void 0 && (n.max = t.max - e.min),
        n
}
var Hf = .35;
function LP(e = Hf) {
    return e === !1 ? e = 0 : e === !0 && (e = Hf),
    {
        x: _v(e, "left", "right"),
        y: _v(e, "top", "bottom")
    }
}
function _v(e, t, n) {
    return {
        min: Iv(e, t),
        max: Iv(e, n)
    }
}
function Iv(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
function wn(e) {
    return [e("x"), e("y")]
}
function E0({ top: e, left: t, right: n, bottom: r }) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: r
        }
    }
}
function VP({ x: e, y: t }) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}
function AP(e, t) {
    if (!t)
        return e;
    let n = t({
        x: e.left,
        y: e.top
    })
        , r = t({
            x: e.right,
            y: e.bottom
        });
    return {
        top: n.y,
        left: n.x,
        bottom: r.y,
        right: r.x
    }
}
function wf(e) {
    return e === void 0 || e === 1
}
function Wf({ scale: e, scaleX: t, scaleY: n }) {
    return !wf(e) || !wf(t) || !wf(n)
}
function ki(e) {
    return Wf(e) || F0(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function F0(e) {
    return Ov(e.x) || Ov(e.y)
}
function Ov(e) {
    return e && e !== "0%"
}
function xl(e, t, n) {
    let r = e - n
        , i = t * r;
    return n + i
}
function Mv(e, t, n, r, i) {
    return i !== void 0 && (e = xl(e, i, r)),
        xl(e, n, r) + t
}
function Uf(e, t = 0, n = 1, r, i) {
    e.min = Mv(e.min, t, n, r, i),
        e.max = Mv(e.max, t, n, r, i)
}
function P0(e, { x: t, y: n }) {
    Uf(e.x, t.translate, t.scale, t.originPoint),
        Uf(e.y, n.translate, n.scale, n.originPoint)
}
var Lv = .999999999999
    , Vv = 1.0000000000001;
function DP(e, t, n, r = !1) {
    let i = n.length;
    if (!i)
        return;
    t.x = t.y = 1;
    let o, s;
    for (let a = 0; a < i; a++) {
        o = n[a],
            s = o.projectionDelta;
        let { visualElement: l } = o.options;
        l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && fo(e, {
            x: -o.scroll.offset.x,
            y: -o.scroll.offset.y
        }),
            s && (t.x *= s.x.scale,
                t.y *= s.y.scale,
                P0(e, s)),
            r && ki(o.latestValues) && fo(e, o.latestValues))
    }
    t.x < Vv && t.x > Lv && (t.x = 1),
        t.y < Vv && t.y > Lv && (t.y = 1)
}
function uo(e, t) {
    e.min = e.min + t,
        e.max = e.max + t
}
function Av(e, t, n, r, i = .5) {
    let o = Le(e.min, e.max, i);
    Uf(e, t, n, o, r)
}
function fo(e, t) {
    Av(e.x, t.x, t.scaleX, t.scale, t.originX),
        Av(e.y, t.y, t.scaleY, t.scale, t.originY)
}
function _0(e, t) {
    return E0(AP(e.getBoundingClientRect(), t))
}
function zP(e, t, n) {
    let r = _0(e, n)
        , { scroll: i } = t;
    return i && (uo(r.x, i.offset.x),
        uo(r.y, i.offset.y)),
        r
}
var I0 = ({ current: e }) => e ? e.ownerDocument.defaultView : null
    , BP = new WeakMap
    , $P = class {
        constructor(e) {
            this.openGlobalLock = null,
                this.isDragging = !1,
                this.currentDirection = null,
                this.originPoint = {
                    x: 0,
                    y: 0
                },
                this.constraints = !1,
                this.hasMutatedConstraints = !1,
                this.elastic = je(),
                this.visualElement = e
        }
        start(e, { snapToCursor: t = !1 } = {}) {
            let { presenceContext: n } = this.visualElement;
            if (n && n.isPresent === !1)
                return;
            let r = c => {
                let { dragSnapToOrigin: u } = this.getProps();
                u ? this.pauseAnimation() : this.stopAnimation(),
                    t && this.snapToCursor(Ml(c, "page").point)
            }
                , i = (c, u) => {
                    let { drag: f, dragPropagation: d, onDragStart: p } = this.getProps();
                    if (f && !d && (this.openGlobalLock && this.openGlobalLock(),
                        this.openGlobalLock = u0(f),
                        !this.openGlobalLock))
                        return;
                    this.isDragging = !0,
                        this.currentDirection = null,
                        this.resolveConstraints(),
                        this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
                            this.visualElement.projection.target = void 0),
                        wn(g => {
                            let b = this.getAxisMotionValue(g).get() || 0;
                            if (Xn.test(b)) {
                                let { projection: m } = this.visualElement;
                                if (m && m.layout) {
                                    let h = m.layout.layoutBox[g];
                                    h && (b = Ut(h) * (parseFloat(b) / 100))
                                }
                            }
                            this.originPoint[g] = b
                        }
                        ),
                        p && J.postRender(() => p(c, u)),
                        $f(this.visualElement, "transform");
                    let { animationState: v } = this.visualElement;
                    v && v.setActive("whileDrag", !0)
                }
                , o = (c, u) => {
                    let { dragPropagation: f, dragDirectionLock: d, onDirectionLock: p, onDrag: v } = this.getProps();
                    if (!f && !this.openGlobalLock)
                        return;
                    let { offset: g } = u;
                    if (d && this.currentDirection === null) {
                        this.currentDirection = NP(g),
                            this.currentDirection !== null && p && p(this.currentDirection);
                        return
                    }
                    this.updateAxis("x", u.point, g),
                        this.updateAxis("y", u.point, g),
                        this.visualElement.render(),
                        v && v(c, u)
                }
                , s = (c, u) => this.stop(c, u)
                , a = () => wn(c => {
                    var u;
                    return this.getAnimationState(c) === "paused" && ((u = this.getAxisMotionValue(c).animation) === null || u === void 0 ? void 0 : u.play())
                }
                )
                , { dragSnapToOrigin: l } = this.getProps();
            this.panSession = new T0(e, {
                onSessionStart: r,
                onStart: i,
                onMove: o,
                onSessionEnd: s,
                resumeAnimation: a
            }, {
                transformPagePoint: this.visualElement.getTransformPagePoint(),
                dragSnapToOrigin: l,
                contextWindow: I0(this.visualElement)
            })
        }
        stop(e, t) {
            let n = this.isDragging;
            if (this.cancel(),
                !n)
                return;
            let { velocity: r } = t;
            this.startAnimation(r);
            let { onDragEnd: i } = this.getProps();
            i && J.postRender(() => i(e, t))
        }
        cancel() {
            this.isDragging = !1;
            let { projection: e, animationState: t } = this.visualElement;
            e && (e.isAnimationBlocked = !1),
                this.panSession && this.panSession.end(),
                this.panSession = void 0;
            let { dragPropagation: n } = this.getProps();
            !n && this.openGlobalLock && (this.openGlobalLock(),
                this.openGlobalLock = null),
                t && t.setActive("whileDrag", !1)
        }
        updateAxis(e, t, n) {
            let { drag: r } = this.getProps();
            if (!n || !al(e, r, this.currentDirection))
                return;
            let i = this.getAxisMotionValue(e)
                , o = this.originPoint[e] + n[e];
            this.constraints && this.constraints[e] && (o = PP(o, this.constraints[e], this.elastic[e])),
                i.set(o)
        }
        resolveConstraints() {
            var e;
            let { dragConstraints: t, dragElastic: n } = this.getProps()
                , r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout
                , i = this.constraints;
            t && co(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = _P(r.layoutBox, t) : this.constraints = !1,
                this.elastic = LP(n),
                i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && wn(o => {
                    this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = MP(r.layoutBox[o], this.constraints[o]))
                }
                )
        }
        resolveRefConstraints() {
            let { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
            if (!e || !co(e))
                return !1;
            let n = e.current;
            nn(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
            let { projection: r } = this.visualElement;
            if (!r || !r.layout)
                return !1;
            let i = zP(n, r.root, this.visualElement.getTransformPagePoint())
                , o = IP(r.layout.layoutBox, i);
            if (t) {
                let s = t(VP(o));
                this.hasMutatedConstraints = !!s,
                    s && (o = E0(s))
            }
            return o
        }
        startAnimation(e) {
            let { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: s } = this.getProps()
                , a = this.constraints || {}
                , l = wn(c => {
                    if (!al(c, t, this.currentDirection))
                        return;
                    let u = a && a[c] || {};
                    o && (u = {
                        min: 0,
                        max: 0
                    });
                    let f = r ? 200 : 1e6
                        , d = r ? 40 : 1e7
                        , p = {
                            type: "inertia",
                            velocity: n ? e[c] : 0,
                            bounceStiffness: f,
                            bounceDamping: d,
                            timeConstant: 750,
                            restDelta: 1,
                            restSpeed: 10,
                            ...i,
                            ...u
                        };
                    return this.startAxisValueAnimation(c, p)
                }
                );
            return Promise.all(l).then(s)
        }
        startAxisValueAnimation(e, t) {
            let n = this.getAxisMotionValue(e);
            return $f(this.visualElement, e),
                n.start(xd(e, n, 0, t, this.visualElement, !1))
        }
        stopAnimation() {
            wn(e => this.getAxisMotionValue(e).stop())
        }
        pauseAnimation() {
            wn(e => {
                var t;
                return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause()
            }
            )
        }
        getAnimationState(e) {
            var t;
            return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state
        }
        getAxisMotionValue(e) {
            let t = `_drag${e.toUpperCase()}`
                , n = this.visualElement.getProps()
                , r = n[t];
            return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
        }
        snapToCursor(e) {
            wn(t => {
                let { drag: n } = this.getProps();
                if (!al(t, n, this.currentDirection))
                    return;
                let { projection: r } = this.visualElement
                    , i = this.getAxisMotionValue(t);
                if (r && r.layout) {
                    let { min: o, max: s } = r.layout.layoutBox[t];
                    i.set(e[t] - Le(o, s, .5))
                }
            }
            )
        }
        scalePositionWithinConstraints() {
            if (!this.visualElement.current)
                return;
            let { drag: e, dragConstraints: t } = this.getProps()
                , { projection: n } = this.visualElement;
            if (!co(t) || !n || !this.constraints)
                return;
            this.stopAnimation();
            let r = {
                x: 0,
                y: 0
            };
            wn(o => {
                let s = this.getAxisMotionValue(o);
                if (s && this.constraints !== !1) {
                    let a = s.get();
                    r[o] = OP({
                        min: a,
                        max: a
                    }, this.constraints[o])
                }
            }
            );
            let { transformTemplate: i } = this.visualElement.getProps();
            this.visualElement.current.style.transform = i ? i({}, "") : "none",
                n.root && n.root.updateScroll(),
                n.updateLayout(),
                this.resolveConstraints(),
                wn(o => {
                    if (!al(o, e, null))
                        return;
                    let s = this.getAxisMotionValue(o)
                        , { min: a, max: l } = this.constraints[o];
                    s.set(Le(a, l, r[o]))
                }
                )
        }
        addListeners() {
            if (!this.visualElement.current)
                return;
            BP.set(this.visualElement, this);
            let e = this.visualElement.current
                , t = Zn(e, "pointerdown", a => {
                    let { drag: l, dragListener: c = !0 } = this.getProps();
                    l && c && this.start(a)
                }
                )
                , n = () => {
                    let { dragConstraints: a } = this.getProps();
                    co(a) && a.current && (this.constraints = this.resolveRefConstraints())
                }
                , { projection: r } = this.visualElement
                , i = r.addEventListener("measure", n);
            r && !r.layout && (r.root && r.root.updateScroll(),
                r.updateLayout()),
                J.read(n);
            let o = wr(I, "resize", () => this.scalePositionWithinConstraints())
                , s = r.addEventListener("didUpdate", ({ delta: a, hasLayoutChanged: l }) => {
                    this.isDragging && l && (wn(c => {
                        let u = this.getAxisMotionValue(c);
                        u && (this.originPoint[c] += a[c].translate,
                            u.set(u.get() + a[c].translate))
                    }
                    ),
                        this.visualElement.render())
                }
                );
            return () => {
                o(),
                    t(),
                    i(),
                    s && s()
            }
        }
        getProps() {
            let e = this.visualElement.getProps()
                , { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = Hf, dragMomentum: s = !0 } = e;
            return {
                ...e,
                drag: t,
                dragDirectionLock: n,
                dragPropagation: r,
                dragConstraints: i,
                dragElastic: o,
                dragMomentum: s
            }
        }
    }
    ;
function al(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}
function NP(e, t = 10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"),
        n
}
var jP = class extends Ur {
    constructor(e) {
        super(e),
            this.removeGroupControls = wt,
            this.removeListeners = wt,
            this.controls = new $P(e)
    }
    mount() {
        let { dragControls: e } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
            this.removeListeners = this.controls.addListeners() || wt
    }
    unmount() {
        this.removeGroupControls(),
            this.removeListeners()
    }
}
    , Dv = e => (t, n) => {
        e && J.postRender(() => e(t, n))
    }
    , HP = class extends Ur {
        constructor() {
            super(...arguments),
                this.removePointerDownListener = wt
        }
        onPointerDown(e) {
            this.session = new T0(e, this.createPanHandlers(), {
                transformPagePoint: this.node.getTransformPagePoint(),
                contextWindow: I0(this.node)
            })
        }
        createPanHandlers() {
            let { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps();
            return {
                onSessionStart: Dv(e),
                onStart: Dv(t),
                onMove: n,
                onEnd: (i, o) => {
                    delete this.session,
                        r && J.postRender(() => r(i, o))
                }
            }
        }
        mount() {
            this.removePointerDownListener = Zn(this.node.current, "pointerdown", e => this.onPointerDown(e))
        }
        update() {
            this.session && this.session.updateHandlers(this.createPanHandlers())
        }
        unmount() {
            this.removePointerDownListener(),
                this.session && this.session.end()
        }
    }
    , fl = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
    };
function zv(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
var vs = {
    correct: (e, t) => {
        if (!t.target)
            return e;
        if (typeof e == "string")
            if (ee.test(e))
                e = parseFloat(e);
            else
                return e;
        let n = zv(e, t.target.x)
            , r = zv(e, t.target.y);
        return `${n}% ${r}%`
    }
}
    , WP = {
        correct: (e, { treeScale: t, projectionDelta: n }) => {
            let r = e
                , i = kr.parse(e);
            if (i.length > 5)
                return r;
            let o = kr.createTransformer(e)
                , s = typeof i[0] != "number" ? 1 : 0
                , a = n.x.scale * t.x
                , l = n.y.scale * t.y;
            i[0 + s] /= a,
                i[1 + s] /= l;
            let c = Le(a, l, .5);
            return typeof i[2 + s] == "number" && (i[2 + s] /= c),
                typeof i[3 + s] == "number" && (i[3 + s] /= c),
                o(i)
        }
    }
    , UP = class extends ke {
        componentDidMount() {
            let { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props
                , { projection: i } = e;
            Fd(GP),
                i && (t.group && t.group.add(i),
                    n && n.register && r && n.register(i),
                    i.root.didUpdate(),
                    i.addEventListener("animationComplete", () => {
                        this.safeToRemove()
                    }
                    ),
                    i.setOptions({
                        ...i.options,
                        onExitComplete: () => this.safeToRemove()
                    })),
                fl.hasEverUpdated = !0
        }
        getSnapshotBeforeUpdate(e) {
            let { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props
                , o = n.projection;
            return o && (o.isPresent = i,
                r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(),
                e.isPresent !== i && (i ? o.promote() : o.relegate() || J.postRender(() => {
                    let s = o.getStack();
                    (!s || !s.members.length) && this.safeToRemove()
                }
                ))),
                null
        }
        componentDidUpdate() {
            let { projection: e } = this.props.visualElement;
            e && (e.root.didUpdate(),
                Pd.postRender(() => {
                    !e.currentAnimation && e.isLead() && this.safeToRemove()
                }
                ))
        }
        componentWillUnmount() {
            let { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props
                , { projection: r } = e;
            r && (r.scheduleCheckAfterUnmount(),
                t && t.group && t.group.remove(r),
                n && n.deregister && n.deregister(r))
        }
        safeToRemove() {
            let { safeToRemove: e } = this.props;
            e && e()
        }
        render() {
            return null
        }
    }
    ;
function O0(e) {
    let [t, n] = Ed()
        , r = D(Os);
    return k(UP, {
        ...e,
        layoutGroup: r,
        switchLayoutGroup: D(Ll),
        isPresent: t,
        safeToRemove: n
    })
}
var GP = {
    borderRadius: {
        ...vs,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: vs,
    borderTopRightRadius: vs,
    borderBottomLeftRadius: vs,
    borderBottomRightRadius: vs,
    boxShadow: WP
}
    , M0 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
    , qP = M0.length
    , Bv = e => typeof e == "string" ? parseFloat(e) : e
    , $v = e => typeof e == "number" || ee.test(e);
function XP(e, t, n, r, i, o) {
    i ? (e.opacity = Le(0, n.opacity !== void 0 ? n.opacity : 1, YP(r)),
        e.opacityExit = Le(t.opacity !== void 0 ? t.opacity : 1, 0, KP(r))) : o && (e.opacity = Le(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let s = 0; s < qP; s++) {
        let a = `border${M0[s]}Radius`
            , l = Nv(t, a)
            , c = Nv(n, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
            c || (c = 0),
            l === 0 || c === 0 || $v(l) === $v(c) ? (e[a] = Math.max(Le(Bv(l), Bv(c), r), 0),
                (Xn.test(c) || Xn.test(l)) && (e[a] += "%")) : e[a] = c
    }
    (t.rotate || n.rotate) && (e.rotate = Le(t.rotate || 0, n.rotate || 0, r))
}
function Nv(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
var YP = L0(0, .5, ed)
    , KP = L0(.5, .95, wt);
function L0(e, t, n) {
    return r => r < e ? 0 : r > t ? 1 : n(Cr(e, t, r))
}
function jv(e, t) {
    e.min = t.min,
        e.max = t.max
}
function xn(e, t) {
    jv(e.x, t.x),
        jv(e.y, t.y)
}
function Hv(e, t) {
    e.translate = t.translate,
        e.scale = t.scale,
        e.originPoint = t.originPoint,
        e.origin = t.origin
}
function Wv(e, t, n, r, i) {
    return e -= t,
        e = xl(e, 1 / n, r),
        i !== void 0 && (e = xl(e, 1 / i, r)),
        e
}
function QP(e, t = 0, n = 1, r = .5, i, o = e, s = e) {
    if (Xn.test(t) && (t = parseFloat(t),
        t = Le(s.min, s.max, t / 100) - s.min),
        typeof t != "number")
        return;
    let a = Le(o.min, o.max, r);
    e === o && (a -= t),
        e.min = Wv(e.min, t, n, a, i),
        e.max = Wv(e.max, t, n, a, i)
}
function Uv(e, t, [n, r, i], o, s) {
    QP(e, t[n], t[r], t[i], t.scale, o, s)
}
var ZP = ["x", "scaleX", "originX"]
    , JP = ["y", "scaleY", "originY"];
function Gv(e, t, n, r) {
    Uv(e.x, t, ZP, n ? n.x : void 0, r ? r.x : void 0),
        Uv(e.y, t, JP, n ? n.y : void 0, r ? r.y : void 0)
}
function qv(e) {
    return e.translate === 0 && e.scale === 1
}
function V0(e) {
    return qv(e.x) && qv(e.y)
}
function Xv(e, t) {
    return e.min === t.min && e.max === t.max
}
function e_(e, t) {
    return Xv(e.x, t.x) && Xv(e.y, t.y)
}
function Yv(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function A0(e, t) {
    return Yv(e.x, t.x) && Yv(e.y, t.y)
}
function Kv(e) {
    return Ut(e.x) / Ut(e.y)
}
function Qv(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
var t_ = class {
    constructor() {
        this.members = []
    }
    add(e) {
        gd(this.members, e),
            e.scheduleRender()
    }
    remove(e) {
        if (El(this.members, e),
            e === this.prevLead && (this.prevLead = void 0),
            e === this.lead) {
            let t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        let t = this.members.findIndex(r => e === r);
        if (t === 0)
            return !1;
        let n;
        for (let r = t; r >= 0; r--) {
            let i = this.members[r];
            if (i.isPresent !== !1) {
                n = i;
                break
            }
        }
        return n ? (this.promote(n),
            !0) : !1
    }
    promote(e, t) {
        let n = this.lead;
        if (e !== n && (this.prevLead = n,
            this.lead = e,
            e.show(),
            n)) {
            n.instance && n.scheduleRender(),
                e.scheduleRender(),
                e.resumeFrom = n,
                t && (e.resumeFrom.preserveOpacity = !0),
                n.snapshot && (e.snapshot = n.snapshot,
                    e.snapshot.latestValues = n.animationValues || n.latestValues),
                e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            let { crossfade: r } = e.options;
            r === !1 && n.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            let { options: t, resumingFrom: n } = e;
            t.onExitComplete && t.onExitComplete(),
                n && n.options.onExitComplete && n.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
    ;
function n_(e, t, n) {
    let r = ""
        , i = e.x.translate / t.x
        , o = e.y.translate / t.y
        , s = n?.z || 0;
    if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `),
        (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
        n) {
        let { transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: p, skewY: v } = n;
        c && (r = `perspective(${c}px) ${r}`),
            u && (r += `rotate(${u}deg) `),
            f && (r += `rotateX(${f}deg) `),
            d && (r += `rotateY(${d}deg) `),
            p && (r += `skewX(${p}deg) `),
            v && (r += `skewY(${v}deg) `)
    }
    let a = e.x.scale * t.x
        , l = e.y.scale * t.y;
    return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`),
        r || "none"
}
function D0(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
function z0(e, t, n) {
    let r = Be(e) ? e : Xe(e);
    return r.start(xd("", r, t, n)),
        r.animation
}
var Ci = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
    , ws = typeof I < "u" && I.MotionDebug !== void 0
    , Sf = ["", "X", "Y", "Z"]
    , r_ = {
        visibility: "hidden"
    }
    , Zv = 1e3
    , i_ = 0;
function kf(e, t, n, r) {
    let { latestValues: i } = t;
    i[e] && (n[e] = i[e],
        t.setStaticValue(e, 0),
        r && (r[e] = 0))
}
function B0(e) {
    if (e.hasCheckedOptimisedAppear = !0,
        e.root === e)
        return;
    let { visualElement: t } = e.options;
    if (!t)
        return;
    let n = n0(t);
    if (I.MotionHasOptimisedAnimation(n, "transform")) {
        let { layout: i, layoutId: o } = e.options;
        I.MotionCancelOptimisedAnimation(n, "transform", J, !(i || o))
    }
    let { parent: r } = e;
    r && !r.hasCheckedOptimisedAppear && B0(r)
}
function $0({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
    return class {
        constructor(s = {}, a = t?.()) {
            this.id = i_++,
                this.animationId = 0,
                this.children = new Set,
                this.options = {},
                this.isTreeAnimating = !1,
                this.isAnimationBlocked = !1,
                this.isLayoutDirty = !1,
                this.isProjectionDirty = !1,
                this.isSharedProjectionDirty = !1,
                this.isTransformDirty = !1,
                this.updateManuallyBlocked = !1,
                this.updateBlockedByResize = !1,
                this.isUpdating = !1,
                this.isSVG = !1,
                this.needsReset = !1,
                this.shouldResetTransform = !1,
                this.hasCheckedOptimisedAppear = !1,
                this.treeScale = {
                    x: 1,
                    y: 1
                },
                this.eventHandlers = new Map,
                this.hasTreeAnimated = !1,
                this.updateScheduled = !1,
                this.scheduleUpdate = () => this.update(),
                this.projectionUpdateScheduled = !1,
                this.checkUpdateFailed = () => {
                    this.isUpdating && (this.isUpdating = !1,
                        this.clearAllSnapshots())
                }
                ,
                this.updateProjection = () => {
                    this.projectionUpdateScheduled = !1,
                        ws && (Ci.totalNodes = Ci.resolvedTargetDeltas = Ci.recalculatedProjection = 0),
                        this.nodes.forEach(a_),
                        this.nodes.forEach(d_),
                        this.nodes.forEach(h_),
                        this.nodes.forEach(l_),
                        ws && I.MotionDebug.record(Ci)
                }
                ,
                this.resolvedRelativeTargetAt = 0,
                this.hasProjected = !1,
                this.isVisible = !0,
                this.animationProgress = 0,
                this.sharedNodes = new Map,
                this.latestValues = s,
                this.root = a ? a.root || a : this,
                this.path = a ? [...a.path, a] : [],
                this.parent = a,
                this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++)
                this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new h0)
        }
        addEventListener(s, a) {
            return this.eventHandlers.has(s) || this.eventHandlers.set(s, new vd),
                this.eventHandlers.get(s).add(a)
        }
        notifyListeners(s, ...a) {
            let l = this.eventHandlers.get(s);
            l && l.notify(...a)
        }
        hasListeners(s) {
            return this.eventHandlers.has(s)
        }
        mount(s, a = this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = D0(s),
                this.instance = s;
            let { layoutId: l, layout: c, visualElement: u } = this.options;
            if (u && !u.current && u.mount(s),
                this.root.nodes.add(this),
                this.parent && this.parent.children.add(this),
                a && (c || l) && (this.isLayoutDirty = !0),
                e) {
                let f, d = () => this.root.updateBlockedByResize = !1;
                e(s, () => {
                    this.root.updateBlockedByResize = !0,
                        f && f(),
                        f = p0(d, 250),
                        fl.hasAnimatedSinceResize && (fl.hasAnimatedSinceResize = !1,
                            this.nodes.forEach(ey))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
                this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: p, layout: v }) => {
                    if (this.isTreeAnimationBlocked()) {
                        this.target = void 0,
                            this.relativeTarget = void 0;
                        return
                    }
                    let g = this.options.transition || u.getDefaultTransition() || y_
                        , { onLayoutAnimationStart: b, onLayoutAnimationComplete: m } = u.getProps()
                        , h = !this.targetLayout || !A0(this.targetLayout, v) || p
                        , y = !d && p;
                    if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || y || d && (h || !this.currentAnimation)) {
                        this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                            this.resumingFrom.resumingFrom = void 0),
                            this.setAnimationOrigin(f, y);
                        let w = {
                            ...bd(g, "layout"),
                            onPlay: b,
                            onComplete: m
                        };
                        (u.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0,
                            w.type = !1),
                            this.startAnimation(w)
                    } else
                        d || ey(this),
                            this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                    this.targetLayout = v
                }
                )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
                this.root.nodes.remove(this);
            let s = this.getStack();
            s && s.remove(this),
                this.parent && this.parent.children.delete(this),
                this.instance = void 0,
                Ft(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
                this.nodes && this.nodes.forEach(p_),
                this.animationId++)
        }
        getTransformTemplate() {
            let { visualElement: s } = this.options;
            return s && s.getProps().transformTemplate
        }
        willUpdate(s = !0) {
            if (this.root.hasTreeAnimated = !0,
                this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (I.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && B0(this),
                !this.root.isUpdating && this.root.startUpdate(),
                this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                let f = this.path[u];
                f.shouldResetTransform = !0,
                    f.updateScroll("snapshot"),
                    f.options.layoutRoot && f.willUpdate(!1)
            }
            let { layoutId: a, layout: l } = this.options;
            if (a === void 0 && !l)
                return;
            let c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
                this.updateSnapshot(),
                s && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
                this.isUpdateBlocked()) {
                this.unblockUpdate(),
                    this.clearAllSnapshots(),
                    this.nodes.forEach(Jv);
                return
            }
            this.isUpdating || this.nodes.forEach(u_),
                this.isUpdating = !1,
                this.nodes.forEach(f_),
                this.nodes.forEach(o_),
                this.nodes.forEach(s_),
                this.clearAllSnapshots();
            let a = Qn.now();
            qe.delta = Sr(0, 1e3 / 60, a - qe.timestamp),
                qe.timestamp = a,
                qe.isProcessing = !0,
                cl.update.process(qe),
                cl.preRender.process(qe),
                cl.render.process(qe),
                qe.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
                Pd.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(c_),
                this.sharedNodes.forEach(m_)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
                J.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            J.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
                !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            let s = this.layout;
            this.layout = this.measure(!1),
                this.layoutCorrected = je(),
                this.isLayoutDirty = !1,
                this.projectionDelta = void 0,
                this.notifyListeners("measure", this.layout.layoutBox);
            let { visualElement: a } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0)
        }
        updateScroll(s = "measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1),
                a) {
                let l = r(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: s,
                    isRoot: l,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : l
                }
            }
        }
        resetTransform() {
            if (!i)
                return;
            let s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
                , a = this.projectionDelta && !V0(this.projectionDelta)
                , l = this.getTransformTemplate()
                , c = l ? l(this.latestValues, "") : void 0
                , u = c !== this.prevTransformTemplateValue;
            s && (a || ki(this.latestValues) || u) && (i(this.instance, c),
                this.shouldResetTransform = !1,
                this.scheduleRender())
        }
        measure(s = !0) {
            let a = this.measurePageBox()
                , l = this.removeElementScroll(a);
            return s && (l = this.removeTransform(l)),
                b_(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var s;
            let { visualElement: a } = this.options;
            if (!a)
                return je();
            let l = a.measureViewportBox();
            if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(x_))) {
                let { scroll: u } = this.root;
                u && (uo(l.x, u.offset.x),
                    uo(l.y, u.offset.y))
            }
            return l
        }
        removeElementScroll(s) {
            var a;
            let l = je();
            if (xn(l, s),
                !((a = this.scroll) === null || a === void 0) && a.wasRoot)
                return l;
            for (let c = 0; c < this.path.length; c++) {
                let u = this.path[c]
                    , { scroll: f, options: d } = u;
                u !== this.root && f && d.layoutScroll && (f.wasRoot && xn(l, s),
                    uo(l.x, f.offset.x),
                    uo(l.y, f.offset.y))
            }
            return l
        }
        applyTransform(s, a = !1) {
            let l = je();
            xn(l, s);
            for (let c = 0; c < this.path.length; c++) {
                let u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && fo(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }),
                    ki(u.latestValues) && fo(l, u.latestValues)
            }
            return ki(this.latestValues) && fo(l, this.latestValues),
                l
        }
        removeTransform(s) {
            let a = je();
            xn(a, s);
            for (let l = 0; l < this.path.length; l++) {
                let c = this.path[l];
                if (!c.instance || !ki(c.latestValues))
                    continue;
                Wf(c.latestValues) && c.updateSnapshot();
                let u = je()
                    , f = c.measurePageBox();
                xn(u, f),
                    Gv(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return ki(this.latestValues) && Gv(a, this.latestValues),
                a
        }
        setTargetDelta(s) {
            this.targetDelta = s,
                this.root.scheduleUpdateProjection(),
                this.isProjectionDirty = !0
        }
        setOptions(s) {
            this.options = {
                ...this.options,
                ...s,
                crossfade: s.crossfade !== void 0 ? s.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
                this.layout = void 0,
                this.snapshot = void 0,
                this.prevTransformTemplateValue = void 0,
                this.targetDelta = void 0,
                this.target = void 0,
                this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== qe.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(s = !1) {
            var a;
            let l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
                this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
                this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            let c = !!this.resumingFrom || this !== l;
            if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            let { layout: f, layoutId: d } = this.options;
            if (!(!this.layout || !(f || d))) {
                if (this.resolvedRelativeTargetAt = qe.timestamp,
                    !this.targetDelta && !this.relativeTarget) {
                    let p = this.getClosestProjectingParent();
                    p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = je(),
                        this.relativeTargetOrigin = je(),
                        Ts(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox),
                        xn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = je(),
                        this.targetWithTransforms = je()),
                        this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                            aP(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : xn(this.target, this.layout.layoutBox),
                                P0(this.target, this.targetDelta)) : xn(this.target, this.layout.layoutBox),
                        this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        let p = this.getClosestProjectingParent();
                        p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p,
                            this.forceRelativeParentToResolveTarget(),
                            this.relativeTarget = je(),
                            this.relativeTargetOrigin = je(),
                            Ts(this.relativeTargetOrigin, this.target, p.target),
                            xn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    ws && Ci.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Wf(this.parent.latestValues) || F0(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var s;
            let a = this.getLead()
                , l = !!this.resumingFrom || this !== a
                , c = !0;
            if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1),
                l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
                this.resolvedRelativeTargetAt === qe.timestamp && (c = !1),
                c)
                return;
            let { layout: u, layoutId: f } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
                this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
                !this.layout || !(u || f))
                return;
            xn(this.layoutCorrected, this.layout.layoutBox);
            let d = this.treeScale.x
                , p = this.treeScale.y;
            DP(this.layoutCorrected, this.treeScale, this.path, l),
                a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox,
                    a.targetWithTransforms = je());
            let { target: v } = a;
            if (!v) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                    this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Hv(this.prevProjectionDelta.x, this.projectionDelta.x),
                Hv(this.prevProjectionDelta.y, this.projectionDelta.y)),
                Cs(this.projectionDelta, this.layoutCorrected, v, this.latestValues),
                (this.treeScale.x !== d || this.treeScale.y !== p || !Qv(this.projectionDelta.x, this.prevProjectionDelta.x) || !Qv(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
                    this.scheduleRender(),
                    this.notifyListeners("projectionUpdate", v)),
                ws && Ci.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(s = !0) {
            var a;
            if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(),
                s) {
                let l = this.getStack();
                l && l.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = lo(),
                this.projectionDelta = lo(),
                this.projectionDeltaWithTransform = lo()
        }
        setAnimationOrigin(s, a = !1) {
            let l = this.snapshot
                , c = l ? l.latestValues : {}
                , u = {
                    ...this.latestValues
                }
                , f = lo();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
                this.attemptToResolveRelativeTarget = !a;
            let d = je()
                , p = l ? l.source : void 0
                , v = this.layout ? this.layout.source : void 0
                , g = p !== v
                , b = this.getStack()
                , m = !b || b.members.length <= 1
                , h = !!(g && !m && this.options.crossfade === !0 && !this.path.some(v_));
            this.animationProgress = 0;
            let y;
            this.mixTargetDelta = w => {
                let C = w / 1e3;
                ty(f.x, s.x, C),
                    ty(f.y, s.y, C),
                    this.setTargetDelta(f),
                    this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ts(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                        g_(this.relativeTarget, this.relativeTargetOrigin, d, C),
                        y && e_(this.relativeTarget, y) && (this.isProjectionDirty = !1),
                        y || (y = je()),
                        xn(y, this.relativeTarget)),
                    g && (this.animationValues = u,
                        XP(u, c, this.latestValues, C, h, m)),
                    this.root.scheduleUpdateProjection(),
                    this.scheduleRender(),
                    this.animationProgress = C
            }
                ,
                this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(s) {
            this.notifyListeners("animationStart"),
                this.currentAnimation && this.currentAnimation.stop(),
                this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
                this.pendingAnimation && (Ft(this.pendingAnimation),
                    this.pendingAnimation = void 0),
                this.pendingAnimation = J.update(() => {
                    fl.hasAnimatedSinceResize = !0,
                        this.currentAnimation = z0(0, Zv, {
                            ...s,
                            onUpdate: a => {
                                this.mixTargetDelta(a),
                                    s.onUpdate && s.onUpdate(a)
                            }
                            ,
                            onComplete: () => {
                                s.onComplete && s.onComplete(),
                                    this.completeAnimation()
                            }
                        }),
                        this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                        this.pendingAnimation = void 0
                }
                )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
                this.resumingFrom.preserveOpacity = void 0);
            let s = this.getStack();
            s && s.exitAnimationComplete(),
                this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
                this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Zv),
                this.currentAnimation.stop()),
                this.completeAnimation()
        }
        applyTransformsToTarget() {
            let s = this.getLead()
                , { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s;
            if (!(!a || !l || !c)) {
                if (this !== s && this.layout && c && N0(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || je();
                    let f = Ut(this.layout.layoutBox.x);
                    l.x.min = s.target.x.min,
                        l.x.max = l.x.min + f;
                    let d = Ut(this.layout.layoutBox.y);
                    l.y.min = s.target.y.min,
                        l.y.max = l.y.min + d
                }
                xn(a, l),
                    fo(a, u),
                    Cs(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(s, a) {
            this.sharedNodes.has(s) || this.sharedNodes.set(s, new t_),
                this.sharedNodes.get(s).add(a);
            let c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            let s = this.getStack();
            return s ? s.lead === this : !0
        }
        getLead() {
            var s;
            let { layoutId: a } = this.options;
            return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this
        }
        getPrevLead() {
            var s;
            let { layoutId: a } = this.options;
            return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0
        }
        getStack() {
            let { layoutId: s } = this.options;
            if (s)
                return this.root.sharedNodes.get(s)
        }
        promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) {
            let c = this.getStack();
            c && c.promote(this, l),
                s && (this.projectionDelta = void 0,
                    this.needsReset = !0),
                a && this.setOptions({
                    transition: a
                })
        }
        relegate() {
            let s = this.getStack();
            return s ? s.relegate(this) : !1
        }
        resetSkewAndRotation() {
            let { visualElement: s } = this.options;
            if (!s)
                return;
            let a = !1
                , { latestValues: l } = s;
            if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
                !a)
                return;
            let c = {};
            l.z && kf("z", s, c, this.animationValues);
            for (let u = 0; u < Sf.length; u++)
                kf(`rotate${Sf[u]}`, s, c, this.animationValues),
                    kf(`skew${Sf[u]}`, s, c, this.animationValues);
            s.render();
            for (let u in c)
                s.setStaticValue(u, c[u]),
                    this.animationValues && (this.animationValues[u] = c[u]);
            s.scheduleRender()
        }
        getProjectionStyles(s) {
            var a, l;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return r_;
            let c = {
                visibility: ""
            }
                , u = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                    c.opacity = "",
                    c.pointerEvents = Et(s?.pointerEvents) || "",
                    c.transform = u ? u(this.latestValues, "") : "none",
                    c;
            let f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                let g = {};
                return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                    g.pointerEvents = Et(s?.pointerEvents) || ""),
                    this.hasProjected && !ki(this.latestValues) && (g.transform = u ? u({}, "") : "none",
                        this.hasProjected = !1),
                    g
            }
            let d = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(),
                c.transform = n_(this.projectionDeltaWithTransform, this.treeScale, d),
                u && (c.transform = u(d, c.transform));
            let { x: p, y: v } = this.projectionDelta;
            c.transformOrigin = `${p.origin * 100}% ${v.origin * 100}% 0`,
                f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (let g in yl) {
                if (d[g] === void 0)
                    continue;
                let { correct: b, applyTo: m } = yl[g]
                    , h = c.transform === "none" ? d[g] : b(d[g], f);
                if (m) {
                    let y = m.length;
                    for (let w = 0; w < y; w++)
                        c[m[w]] = h
                } else
                    c[g] = h
            }
            return this.options.layoutId && (c.pointerEvents = f === this ? Et(s?.pointerEvents) || "" : "none"),
                c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(s => {
                var a;
                return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
                this.root.nodes.forEach(Jv),
                this.root.sharedNodes.clear()
        }
    }
}
function o_(e) {
    e.updateLayout()
}
function s_(e) {
    var t;
    let n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        let { layoutBox: r, measuredBox: i } = e.layout
            , { animationType: o } = e.options
            , s = n.source !== e.layout.source;
        o === "size" ? wn(f => {
            let d = s ? n.measuredBox[f] : n.layoutBox[f]
                , p = Ut(d);
            d.min = r[f].min,
                d.max = d.min + p
        }
        ) : N0(o, n.layoutBox, r) && wn(f => {
            let d = s ? n.measuredBox[f] : n.layoutBox[f]
                , p = Ut(r[f]);
            d.max = d.min + p,
                e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0,
                    e.relativeTarget[f].max = e.relativeTarget[f].min + p)
        }
        );
        let a = lo();
        Cs(a, r, n.layoutBox);
        let l = lo();
        s ? Cs(l, e.applyTransform(i, !0), n.measuredBox) : Cs(l, r, n.layoutBox);
        let c = !V0(a)
            , u = !1;
        if (!e.resumeFrom) {
            let f = e.getClosestProjectingParent();
            if (f && !f.resumeFrom) {
                let { snapshot: d, layout: p } = f;
                if (d && p) {
                    let v = je();
                    Ts(v, n.layoutBox, d.layoutBox);
                    let g = je();
                    Ts(g, r, p.layoutBox),
                        A0(v, g) || (u = !0),
                        f.options.layoutRoot && (e.relativeTarget = g,
                            e.relativeTargetOrigin = v,
                            e.relativeParent = f)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: u
        })
    } else if (e.isLead()) {
        let { onExitComplete: r } = e.options;
        r && r()
    }
    e.options.transition = void 0
}
function a_(e) {
    ws && Ci.totalNodes++,
        e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
            e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)),
            e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function l_(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function c_(e) {
    e.clearSnapshot()
}
function Jv(e) {
    e.clearMeasurements()
}
function u_(e) {
    e.isLayoutDirty = !1
}
function f_(e) {
    let { visualElement: t } = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
        e.resetTransform()
}
function ey(e) {
    e.finishAnimation(),
        e.targetDelta = e.relativeTarget = e.target = void 0,
        e.isProjectionDirty = !0
}
function d_(e) {
    e.resolveTargetDelta()
}
function h_(e) {
    e.calcProjection()
}
function p_(e) {
    e.resetSkewAndRotation()
}
function m_(e) {
    e.removeLeadSnapshot()
}
function ty(e, t, n) {
    e.translate = Le(t.translate, 0, n),
        e.scale = Le(t.scale, 1, n),
        e.origin = t.origin,
        e.originPoint = t.originPoint
}
function ny(e, t, n, r) {
    e.min = Le(t.min, n.min, r),
        e.max = Le(t.max, n.max, r)
}
function g_(e, t, n, r) {
    ny(e.x, t.x, n.x, r),
        ny(e.y, t.y, n.y, r)
}
function v_(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
var y_ = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
    , ry = e => typeof _e < "u" && _e.userAgent && _e.userAgent.toLowerCase().includes(e)
    , iy = ry("applewebkit/") && !ry("chrome/") ? Math.round : wt;
function oy(e) {
    e.min = iy(e.min),
        e.max = iy(e.max)
}
function b_(e) {
    oy(e.x),
        oy(e.y)
}
function N0(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !sP(Kv(t), Kv(n), .2)
}
function x_(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
var w_ = $0({
    attachResizeListener: (e, t) => wr(e, "resize", t),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
    , Ei = {
        current: void 0
    }
    , j0 = $0({
        measureScroll: e => ({
            x: e.scrollLeft,
            y: e.scrollTop
        }),
        defaultParent: () => {
            if (!Ei.current) {
                let e = new w_({});
                e.mount(I),
                    e.setOptions({
                        layoutScroll: !0
                    }),
                    Ei.current = e
            }
            return Ei.current
        }
        ,
        resetTransform: (e, t) => {
            e.style.transform = t !== void 0 ? t : "none"
        }
        ,
        checkIsScrollRoot: e => I.getComputedStyle(e).position === "fixed"
    })
    , H0 = {
        pan: {
            Feature: HP
        },
        drag: {
            Feature: jP,
            ProjectionNode: j0,
            MeasureLayout: O0
        }
    };
function sy(e, t) {
    let n = t ? "pointerenter" : "pointerleave"
        , r = t ? "onHoverStart" : "onHoverEnd"
        , i = (o, s) => {
            if (o.pointerType === "touch" || Rd())
                return;
            let a = e.getProps();
            e.animationState && a.whileHover && e.animationState.setActive("whileHover", t);
            let l = a[r];
            l && J.postRender(() => l(o, s))
        }
        ;
    return Zn(e.current, n, i, {
        passive: !e.getProps()[r]
    })
}
var S_ = class extends Ur {
    mount() {
        this.unmount = Kn(sy(this.node, !0), sy(this.node, !1))
    }
    unmount() { }
}
    , k_ = class extends Ur {
        constructor() {
            super(...arguments),
                this.isActive = !1
        }
        onFocus() {
            let e = !1;
            try {
                e = this.node.current.matches(":focus-visible")
            } catch {
                e = !0
            }
            !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
                this.isActive = !0)
        }
        onBlur() {
            !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
                this.isActive = !1)
        }
        mount() {
            this.unmount = Kn(wr(this.node.current, "focus", () => this.onFocus()), wr(this.node.current, "blur", () => this.onBlur()))
        }
        unmount() { }
    }
    , W0 = (e, t) => t ? e === t ? !0 : W0(e, t.parentElement) : !1;
function Cf(e, t) {
    if (!t)
        return;
    let n = new PointerEvent("pointer" + e);
    t(n, Ml(n))
}
var C_ = class extends Ur {
    constructor() {
        super(...arguments),
            this.removeStartListeners = wt,
            this.removeEndListeners = wt,
            this.removeAccessibleListeners = wt,
            this.startPointerPress = (e, t) => {
                if (this.isPressing)
                    return;
                this.removeEndListeners();
                let n = this.node.getProps()
                    , i = Zn(I, "pointerup", (s, a) => {
                        if (!this.checkPressEnd())
                            return;
                        let { onTap: l, onTapCancel: c, globalTapTarget: u } = this.node.getProps()
                            , f = !u && !W0(this.node.current, s.target) ? c : l;
                        f && J.update(() => f(s, a))
                    }
                        , {
                            passive: !(n.onTap || n.onPointerUp)
                        })
                    , o = Zn(I, "pointercancel", (s, a) => this.cancelPress(s, a), {
                        passive: !(n.onTapCancel || n.onPointerCancel)
                    });
                this.removeEndListeners = Kn(i, o),
                    this.startPress(e, t)
            }
            ,
            this.startAccessiblePress = () => {
                let e = i => {
                    if (i.key !== "Enter" || this.isPressing)
                        return;
                    let o = s => {
                        s.key !== "Enter" || !this.checkPressEnd() || Cf("up", (a, l) => {
                            let { onTap: c } = this.node.getProps();
                            c && J.postRender(() => c(a, l))
                        }
                        )
                    }
                        ;
                    this.removeEndListeners(),
                        this.removeEndListeners = wr(this.node.current, "keyup", o),
                        Cf("down", (s, a) => {
                            this.startPress(s, a)
                        }
                        )
                }
                    , t = wr(this.node.current, "keydown", e)
                    , n = () => {
                        this.isPressing && Cf("cancel", (i, o) => this.cancelPress(i, o))
                    }
                    , r = wr(this.node.current, "blur", n);
                this.removeAccessibleListeners = Kn(t, r)
            }
    }
    startPress(e, t) {
        this.isPressing = !0;
        let { onTapStart: n, whileTap: r } = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
            n && J.postRender(() => n(e, t))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
            this.isPressing = !1,
            this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
            !Rd()
    }
    cancelPress(e, t) {
        if (!this.checkPressEnd())
            return;
        let { onTapCancel: n } = this.node.getProps();
        n && J.postRender(() => n(e, t))
    }
    mount() {
        let e = this.node.getProps()
            , t = Zn(e.globalTapTarget ? I : this.node.current, "pointerdown", this.startPointerPress, {
                passive: !(e.onTapStart || e.onPointerStart)
            })
            , n = wr(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Kn(t, n)
    }
    unmount() {
        this.removeStartListeners(),
            this.removeEndListeners(),
            this.removeAccessibleListeners()
    }
}
    , Gf = new WeakMap
    , Tf = new WeakMap
    , T_ = e => {
        let t = Gf.get(e.target);
        t && t(e)
    }
    , R_ = e => {
        e.forEach(T_)
    }
    ;
function E_({ root: e, ...t }) {
    let n = e || document;
    Tf.has(n) || Tf.set(n, {});
    let r = Tf.get(n)
        , i = JSON.stringify(t);
    return r[i] || (r[i] = new IntersectionObserver(R_, {
        root: e,
        ...t
    })),
        r[i]
}
function F_(e, t, n) {
    let r = E_(t);
    return Gf.set(e, n),
        r.observe(e),
        () => {
            Gf.delete(e),
                r.unobserve(e)
        }
}
var P_ = {
    some: 0,
    all: 1
}
    , __ = class extends Ur {
        constructor() {
            super(...arguments),
                this.hasEnteredView = !1,
                this.isInView = !1
        }
        startObserver() {
            this.unmount();
            let { viewport: e = {} } = this.node.getProps()
                , { root: t, margin: n, amount: r = "some", once: i } = e
                , o = {
                    root: t ? t.current : void 0,
                    rootMargin: n,
                    threshold: typeof r == "number" ? r : P_[r]
                }
                , s = a => {
                    let { isIntersecting: l } = a;
                    if (this.isInView === l || (this.isInView = l,
                        i && !l && this.hasEnteredView))
                        return;
                    l && (this.hasEnteredView = !0),
                        this.node.animationState && this.node.animationState.setActive("whileInView", l);
                    let { onViewportEnter: c, onViewportLeave: u } = this.node.getProps()
                        , f = l ? c : u;
                    f && f(a)
                }
                ;
            return F_(this.node.current, o, s)
        }
        mount() {
            this.startObserver()
        }
        update() {
            if (typeof IntersectionObserver > "u")
                return;
            let { props: e, prevProps: t } = this.node;
            ["amount", "margin", "root"].some(I_(e, t)) && this.startObserver()
        }
        unmount() { }
    }
    ;
function I_({ viewport: e = {} }, { viewport: t = {} } = {}) {
    return n => e[n] !== t[n]
}
var U0 = {
    inView: {
        Feature: __
    },
    tap: {
        Feature: C_
    },
    focus: {
        Feature: k_
    },
    hover: {
        Feature: S_
    }
}
    , G0 = {
        layout: {
            ProjectionNode: j0,
            MeasureLayout: O0
        }
    }
    , O_ = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function Md(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(O_.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function q0(e, { style: t, vars: n }, r, i) {
    Object.assign(e.style, t, i && i.getProjectionStyles(r));
    for (let o in n)
        e.style.setProperty(o, n[o])
}
var X0 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function Y0(e, t, n, r) {
    q0(e, t, void 0, r);
    for (let i in t.attrs)
        e.setAttribute(X0.has(i) ? i : Pl(i), t.attrs[i])
}
function K0(e, { layout: t, layoutId: n }) {
    return Wr.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!yl[e] || e === "opacity")
}
function Ld(e, t, n) {
    var r;
    let { style: i } = e
        , o = {};
    for (let s in i)
        (Be(i[s]) || t.style && Be(t.style[s]) || K0(s, e) || ((r = n?.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]);
    return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1),
        o
}
function Q0(e, t, n) {
    let r = Ld(e, t, n);
    for (let i in e)
        if (Be(e[i]) || Be(t[i])) {
            let o = Vs.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            r[o] = e[i]
        }
    return r
}
var Vd = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
    , Z0 = () => ({
        ...Vd(),
        attrs: {}
    });
function Ad(e, t, n) {
    let { style: r, vars: i, transformOrigin: o } = e
        , s = !1
        , a = !1;
    for (let l in t) {
        let c = t[l];
        if (Wr.has(l)) {
            s = !0;
            continue
        } else if (Vy(l)) {
            i[l] = c;
            continue
        } else {
            let u = b0(c, hd[l]);
            l.startsWith("origin") ? (a = !0,
                o[l] = u) : r[l] = u
        }
    }
    if (t.transform || (s || n ? r.transform = x0(t, e.transform, n) : r.transform && (r.transform = "none")),
        a) {
        let { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = o;
        r.transformOrigin = `${l} ${c} ${u}`
    }
}
function ay(e, t, n) {
    return typeof e == "string" ? e : ee.transform(t + n * e)
}
function M_(e, t, n) {
    let r = ay(t, e.x, e.width)
        , i = ay(n, e.y, e.height);
    return `${r} ${i}`
}
var L_ = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
    , V_ = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };
function A_(e, t, n = 1, r = 0, i = !0) {
    e.pathLength = 1;
    let o = i ? L_ : V_;
    e[o.offset] = ee.transform(-r);
    let s = ee.transform(t)
        , a = ee.transform(n);
    e[o.array] = `${s} ${a}`
}
function Dd(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...c }, u, f) {
    if (Ad(e, c, f),
        u) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style,
        e.style = {};
    let { attrs: d, style: p, dimensions: v } = e;
    d.transform && (v && (p.transform = d.transform),
        delete d.transform),
        v && (i !== void 0 || o !== void 0 || p.transform) && (p.transformOrigin = M_(v, i !== void 0 ? i : .5, o !== void 0 ? o : .5)),
        t !== void 0 && (d.x = t),
        n !== void 0 && (d.y = n),
        r !== void 0 && (d.scale = r),
        s !== void 0 && A_(d, s, a, l, !1)
}
var zd = e => typeof e == "string" && e.toLowerCase() === "svg"
    , D_ = {
        useVisualState: Dl({
            scrapeMotionValuesFromProps: Q0,
            createRenderState: Z0,
            onMount: (e, t, { renderState: n, latestValues: r }) => {
                J.read(() => {
                    try {
                        n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect()
                    } catch {
                        n.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }
                ),
                    J.render(() => {
                        Dd(n, r, zd(t.tagName), e.transformTemplate),
                            Y0(t, n)
                    }
                    )
            }
        })
    }
    , z_ = {
        useVisualState: Dl({
            applyWillChange: !0,
            scrapeMotionValuesFromProps: Ld,
            createRenderState: Vd
        })
    };
function J0(e, t, n) {
    for (let r in t)
        !Be(t[r]) && !K0(r, n) && (e[r] = t[r])
}
function B_({ transformTemplate: e }, t) {
    return ue(() => {
        let n = Vd();
        return Ad(n, t, e),
            Object.assign({}, n.vars, n.style)
    }
        , [t])
}
function $_(e, t) {
    let n = e.style || {}
        , r = {};
    return J0(r, n, e),
        Object.assign(r, B_(e, t)),
        r
}
function N_(e, t) {
    let n = {}
        , r = $_(e, t);
    return e.drag && e.dragListener !== !1 && (n.draggable = !1,
        r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none",
        r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`),
        e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
        n.style = r,
        n
}
function j_(e, t, n, r) {
    let i = ue(() => {
        let o = Z0();
        return Dd(o, t, zd(r), e.transformTemplate),
        {
            ...o.attrs,
            style: {
                ...o.style
            }
        }
    }
        , [t]);
    if (e.style) {
        let o = {};
        J0(o, e.style, e),
            i.style = {
                ...o,
                ...i.style
            }
    }
    return i
}
function H_(e = !1) {
    return (n, r, i, { latestValues: o }, s) => {
        let l = (Md(n) ? j_ : N_)(r, o, s, n)
            , c = k0(r, typeof n == "string", e)
            , u = n !== bn ? {
                ...c,
                ...l,
                ref: i
            } : {}
            , { children: f } = r
            , d = ue(() => Be(f) ? f.get() : f, [f]);
        return Nr(n, {
            ...u,
            children: d
        })
    }
}
function W_(e, t) {
    return function (r, { forwardMotionProps: i } = {
        forwardMotionProps: !1
    }) {
        let s = {
            ...Md(r) ? D_ : z_,
            preloadedFeatures: e,
            useRender: H_(i),
            createVisualElement: t,
            Component: r
        };
        return y0(s)
    }
}
var eb = class extends Od {
    constructor() {
        super(...arguments),
            this.KeyframeResolver = Yy
    }
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, { vars: t, style: n }) {
        delete t[e],
            delete n[e]
    }
}
    ;
function U_(e) {
    return I.getComputedStyle(e)
}
var tb = class extends eb {
    constructor() {
        super(...arguments),
            this.type = "html",
            this.applyWillChange = !0,
            this.renderInstance = q0
    }
    readValueFromInstance(e, t) {
        if (Wr.has(t)) {
            let n = pd(t);
            return n && n.default || 0
        } else {
            let n = U_(e)
                , r = (Vy(t) ? n.getPropertyValue(t) : n[t]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(e, { transformPagePoint: t }) {
        return _0(e, t)
    }
    build(e, t, n) {
        Ad(e, t, n.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return Ld(e, t, n)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
            delete this.childSubscription);
        let { children: e } = this.props;
        Be(e) && (this.childSubscription = e.on("change", t => {
            this.current && (this.current.textContent = `${t}`)
        }
        ))
    }
}
    , nb = class extends eb {
        constructor() {
            super(...arguments),
                this.type = "svg",
                this.isSVGTag = !1,
                this.measureInstanceViewportBox = je
        }
        getBaseTargetFromProps(e, t) {
            return e[t]
        }
        readValueFromInstance(e, t) {
            if (Wr.has(t)) {
                let n = pd(t);
                return n && n.default || 0
            }
            return t = X0.has(t) ? t : Pl(t),
                e.getAttribute(t)
        }
        scrapeMotionValuesFromProps(e, t, n) {
            return Q0(e, t, n)
        }
        build(e, t, n) {
            Dd(e, t, this.isSVGTag, n.transformTemplate)
        }
        renderInstance(e, t, n, r) {
            Y0(e, t, n, r)
        }
        mount(e) {
            this.isSVGTag = zd(e.tagName),
                super.mount(e)
        }
    }
    , Bd = (e, t) => Md(e) ? new nb(t) : new tb(t, {
        allowProjection: e !== bn
    })
    , G_ = W_({
        ...Ol,
        ...U0,
        ...H0,
        ...G0
    }, Bd)
    , Ye = RP(G_);
var q_ = class extends ke {
    getSnapshotBeforeUpdate(e) {
        let t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
            let n = this.props.sizeRef.current;
            n.height = t.offsetHeight || 0,
                n.width = t.offsetWidth || 0,
                n.top = t.offsetTop,
                n.left = t.offsetLeft
        }
        return null
    }
    componentDidUpdate() { }
    render() {
        return this.props.children
    }
}
    ;
function X_({ children: e, isPresent: t }) {
    let n = wi()
        , r = V(null)
        , i = V({
            width: 0,
            height: 0,
            top: 0,
            left: 0
        })
        , { nonce: o } = D(Jn);
    return ht(() => {
        let { width: s, height: a, top: l, left: c } = i.current;
        if (t || !r.current || !s || !a)
            return;
        r.current.dataset.motionPopId = n;
        let u = document.createElement("style");
        return o && (u.nonce = o),
            document.head.appendChild(u),
            u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `),
            () => {
                document.head.removeChild(u)
            }
    }
        , [t]),
        k(q_, {
            isPresent: t,
            childRef: r,
            sizeRef: i,
            children: xr(e, {
                ref: r
            })
        })
}
var Y_ = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => {
    let a = tr(K_)
        , l = wi()
        , c = Q(f => {
            a.set(f, !0);
            for (let d of a.values())
                if (!d)
                    return;
            r && r()
        }
            , [a, r])
        , u = ue(() => ({
            id: l,
            initial: t,
            isPresent: n,
            custom: i,
            onExitComplete: c,
            register: f => (a.set(f, !1),
                () => a.delete(f))
        }), o ? [Math.random(), c] : [n, c]);
    return ue(() => {
        a.forEach((f, d) => a.set(d, !1))
    }
        , [n]),
        H(() => {
            !n && !a.size && r && r()
        }
            , [n]),
        s === "popLayout" && (e = k(X_, {
            isPresent: n,
            children: e
        })),
        k(xo.Provider, {
            value: u,
            children: e
        })
}
    ;
function K_() {
    return new Map
}
var ll = e => e.key || "";
function ly(e) {
    let t = [];
    return yn.forEach(e, n => {
        At(n) && t.push(n)
    }
    ),
        t
}
var $d = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => {
    nn(!t, "Replace exitBeforeEnter with mode='wait'");
    let a = ue(() => ly(e), [e])
        , l = a.map(ll)
        , c = V(!0)
        , u = V(a)
        , f = tr(() => new Map)
        , [d, p] = Ee(a)
        , [v, g] = Ee(a);
    Gr(() => {
        c.current = !1,
            u.current = a;
        for (let h = 0; h < v.length; h++) {
            let y = ll(v[h]);
            l.includes(y) ? f.delete(y) : f.get(y) !== !0 && f.set(y, !1)
        }
    }
        , [v, l.length, l.join("-")]);
    let b = [];
    if (a !== d) {
        let h = [...a];
        for (let y = 0; y < v.length; y++) {
            let w = v[y]
                , C = ll(w);
            l.includes(C) || (h.splice(y, 0, w),
                b.push(w))
        }
        s === "wait" && b.length && (h = b),
            g(ly(h)),
            p(a);
        return
    }
    let { forceRender: m } = D(Os);
    return k(lt, {
        children: v.map(h => {
            let y = ll(h)
                , w = a === v || l.includes(y)
                , C = () => {
                    if (f.has(y))
                        f.set(y, !0);
                    else
                        return;
                    let S = !0;
                    f.forEach(T => {
                        T || (S = !1)
                    }
                    ),
                        S && (m?.(),
                            g(u.current),
                            i && i())
                }
                ;
            return k(Y_, {
                isPresent: w,
                initial: !c.current || r ? void 0 : !1,
                custom: w ? void 0 : n,
                presenceAffectsLayout: o,
                mode: s,
                onExitComplete: w ? void 0 : C,
                children: h
            }, y)
        }
        )
    })
}
    ;
function rb({ children: e, isValidProp: t, ...n }) {
    t && S0(t),
        n = {
            ...D(Jn),
            ...n
        },
        n.isStatic = tr(() => n.isStatic);
    let r = ue(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]);
    return k(Jn.Provider, {
        value: r,
        children: e
    })
}
var ib = be(null);
function Q_() {
    let e = V(!1);
    return Gr(() => (e.current = !0,
        () => {
            e.current = !1
        }
    ), []),
        e
}
function Nd() {
    let e = Q_()
        , [t, n] = Ee(0)
        , r = Q(() => {
            e.current && n(t + 1)
        }
            , [t]);
    return [Q(() => J.postRender(r), [r]), t]
}
var Z_ = e => !e.isLayoutDirty && e.willUpdate(!1);
function cy() {
    let e = new Set
        , t = new WeakMap
        , n = () => e.forEach(Z_);
    return {
        add: r => {
            e.add(r),
                t.set(r, r.addEventListener("willUpdate", n))
        }
        ,
        remove: r => {
            e.delete(r);
            let i = t.get(r);
            i && (i(),
                t.delete(r)),
                n()
        }
        ,
        dirty: n
    }
}
var ob = e => e === !0
    , J_ = e => ob(e === !0) || e === "id"
    , sb = ({ children: e, id: t, inherit: n = !0 }) => {
        let r = D(Os)
            , i = D(ib)
            , [o, s] = Nd()
            , a = V(null)
            , l = r.id || i;
        a.current === null && (J_(n) && l && (t = t ? l + "-" + t : l),
            a.current = {
                id: t,
                group: ob(n) && r.group || cy()
            });
        let c = ue(() => ({
            ...a.current,
            forceRender: o
        }), [s]);
        return k(Os.Provider, {
            value: c,
            children: e
        })
    }
    , eI = {
        renderer: Bd,
        ...Ol
    }
    , ab = {
        renderer: Bd,
        ...Ol,
        ...U0
    }
    , tI = {
        ...ab,
        ...H0,
        ...G0
    };
function nr(e) {
    let t = tr(() => Xe(e))
        , { isStatic: n } = D(Jn);
    if (n) {
        let [, r] = Ee(e);
        H(() => t.on("change", r), [])
    }
    return t
}
function lb(e, t) {
    let n = nr(t())
        , r = () => n.set(t());
    return r(),
        Gr(() => {
            let i = () => J.preRender(r, !1, !0)
                , o = e.map(s => s.on("change", i));
            return () => {
                o.forEach(s => s()),
                    Ft(r)
            }
        }
        ),
        n
}
var nI = e => e && typeof e == "object" && e.mix
    , rI = e => nI(e) ? e.mix : void 0;
function wo(...e) {
    let t = !Array.isArray(e[0])
        , n = t ? 0 : -1
        , r = e[0 + n]
        , i = e[1 + n]
        , o = e[2 + n]
        , s = e[3 + n]
        , a = bo(i, o, {
            mixer: rI(o[0]),
            ...s
        });
    return t ? a(r) : a
}
function iI(e) {
    ks.current = [],
        e();
    let t = lb(ks.current, e);
    return ks.current = void 0,
        t
}
function Dt(e, t, n, r) {
    if (typeof e == "function")
        return iI(e);
    let i = typeof t == "function" ? t : wo(t, n, r);
    return Array.isArray(e) ? uy(e, i) : uy([e], ([o]) => i(o))
}
function uy(e, t) {
    let n = tr(() => []);
    return lb(e, () => {
        n.length = 0;
        let r = e.length;
        for (let i = 0; i < r; i++)
            n[i] = e[i].get();
        return t(n)
    }
    )
}
function fy(e) {
    return typeof e == "number" ? e : parseFloat(e)
}
function jd(e, t = {}) {
    let { isStatic: n } = D(Jn)
        , r = V(null)
        , i = nr(Be(e) ? fy(e.get()) : e)
        , o = V(i.get())
        , s = V(() => { }
        )
        , a = () => {
            let c = r.current;
            c && c.time === 0 && c.sample(qe.delta),
                l(),
                r.current = dd({
                    keyframes: [i.get(), o.current],
                    velocity: i.getVelocity(),
                    type: "spring",
                    restDelta: .001,
                    restSpeed: .01,
                    ...t,
                    onUpdate: s.current
                })
        }
        , l = () => {
            r.current && r.current.stop()
        }
        ;
    return ht(() => i.attach((c, u) => n ? u(c) : (o.current = c,
        s.current = u,
        J.update(a),
        i.get()), l), [JSON.stringify(t)]),
        Gr(() => {
            if (Be(e))
                return e.on("change", c => i.set(fy(c)))
        }
            , [i]),
        i
}
function Hd(e, t, n) {
    var r;
    if (typeof e == "string") {
        let i = document;
        t && (nn(!!t.current, "Scope provided, but no element detected."),
            i = t.current),
            n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)),
                e = n[e]) : e = i.querySelectorAll(e)
    } else
        e instanceof Element && (e = [e]);
    return Array.from(e || [])
}
var dl = new WeakMap, Hr;
function oI(e, t) {
    if (t) {
        let { inlineSize: n, blockSize: r } = t[0];
        return {
            width: n,
            height: r
        }
    } else
        return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : {
            width: e.offsetWidth,
            height: e.offsetHeight
        }
}
function sI({ target: e, contentRect: t, borderBoxSize: n }) {
    var r;
    (r = dl.get(e)) === null || r === void 0 || r.forEach(i => {
        i({
            target: e,
            contentSize: t,
            get size() {
                return oI(e, n)
            }
        })
    }
    )
}
function aI(e) {
    e.forEach(sI)
}
function lI() {
    typeof ResizeObserver > "u" || (Hr = new ResizeObserver(aI))
}
function cI(e, t) {
    Hr || lI();
    let n = Hd(e);
    return n.forEach(r => {
        let i = dl.get(r);
        i || (i = new Set,
            dl.set(r, i)),
            i.add(t),
            Hr?.observe(r)
    }
    ),
        () => {
            n.forEach(r => {
                let i = dl.get(r);
                i?.delete(t),
                    i?.size || Hr?.unobserve(r)
            }
            )
        }
}
var hl = new Set, Rs;
function uI() {
    Rs = () => {
        let e = {
            width: I.innerWidth,
            height: I.innerHeight
        }
            , t = {
                target: I,
                size: e,
                contentSize: e
            };
        hl.forEach(n => n(t))
    }
        ,
        I.addEventListener("resize", Rs)
}
function fI(e) {
    return hl.add(e),
        Rs || uI(),
        () => {
            hl.delete(e),
                !hl.size && Rs && (Rs = void 0)
        }
}
function dI(e, t) {
    return typeof e == "function" ? fI(e) : cI(e, t)
}
var hI = 50
    , dy = () => ({
        current: 0,
        offset: [],
        progress: 0,
        scrollLength: 0,
        targetOffset: 0,
        targetLength: 0,
        containerLength: 0,
        velocity: 0
    })
    , pI = () => ({
        time: 0,
        x: dy(),
        y: dy()
    })
    , mI = {
        x: {
            length: "Width",
            position: "Left"
        },
        y: {
            length: "Height",
            position: "Top"
        }
    };
function hy(e, t, n, r) {
    let i = n[t]
        , { length: o, position: s } = mI[t]
        , a = i.current
        , l = n.time;
    i.current = e[`scroll${s}`],
        i.scrollLength = e[`scroll${o}`] - e[`client${o}`],
        i.offset.length = 0,
        i.offset[0] = 0,
        i.offset[1] = i.scrollLength,
        i.progress = Cr(0, i.scrollLength, i.current);
    let c = r - l;
    i.velocity = c > hI ? 0 : id(i.current - a, c)
}
function gI(e, t, n) {
    hy(e, "x", t, n),
        hy(e, "y", t, n),
        t.time = n
}
function vI(e, t) {
    let n = {
        x: 0,
        y: 0
    }
        , r = e;
    for (; r && r !== t;)
        if (r instanceof HTMLElement)
            n.x += r.offsetLeft,
                n.y += r.offsetTop,
                r = r.offsetParent;
        else if (r.tagName === "svg") {
            let i = r.getBoundingClientRect();
            r = r.parentElement;
            let o = r.getBoundingClientRect();
            n.x += i.left - o.left,
                n.y += i.top - o.top
        } else if (r instanceof SVGGraphicsElement) {
            let { x: i, y: o } = r.getBBox();
            n.x += i,
                n.y += o;
            let s = null
                , a = r.parentNode;
            for (; !s;)
                a.tagName === "svg" && (s = a),
                    a = r.parentNode;
            r = s
        } else
            break;
    return n
}
var yI = {
    Enter: [[0, 1], [1, 1]],
    Exit: [[0, 0], [1, 0]],
    Any: [[1, 0], [0, 1]],
    All: [[0, 0], [1, 1]]
}
    , qf = {
        start: 0,
        center: .5,
        end: 1
    };
function py(e, t, n = 0) {
    let r = 0;
    if (e in qf && (e = qf[e]),
        typeof e == "string") {
        let i = parseFloat(e);
        e.endsWith("px") ? r = i : e.endsWith("%") ? e = i / 100 : e.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : e = i
    }
    return typeof e == "number" && (r = t * e),
        n + r
}
var bI = [0, 0];
function xI(e, t, n, r) {
    let i = Array.isArray(e) ? e : bI
        , o = 0
        , s = 0;
    return typeof e == "number" ? i = [e, e] : typeof e == "string" && (e = e.trim(),
        e.includes(" ") ? i = e.split(" ") : i = [e, qf[e] ? e : "0"]),
        o = py(i[0], n, r),
        s = py(i[1], t),
        o - s
}
var wI = {
    x: 0,
    y: 0
};
function SI(e) {
    return "getBBox" in e && e.tagName !== "svg" ? e.getBBox() : {
        width: e.clientWidth,
        height: e.clientHeight
    }
}
function kI(e, t, n) {
    let { offset: r = yI.All } = n
        , { target: i = e, axis: o = "y" } = n
        , s = o === "y" ? "height" : "width"
        , a = i !== e ? vI(i, e) : wI
        , l = i === e ? {
            width: e.scrollWidth,
            height: e.scrollHeight
        } : SI(i)
        , c = {
            width: e.clientWidth,
            height: e.clientHeight
        };
    t[o].offset.length = 0;
    let u = !t[o].interpolate
        , f = r.length;
    for (let d = 0; d < f; d++) {
        let p = xI(r[d], c[s], l[s], a[o]);
        !u && p !== t[o].interpolatorOffsets[d] && (u = !0),
            t[o].offset[d] = p
    }
    u && (t[o].interpolate = bo(t[o].offset, ud(r)),
        t[o].interpolatorOffsets = [...t[o].offset]),
        t[o].progress = t[o].interpolate(t[o].current)
}
function CI(e, t = e, n) {
    if (n.x.targetOffset = 0,
        n.y.targetOffset = 0,
        t !== e) {
        let r = t;
        for (; r && r !== e;)
            n.x.targetOffset += r.offsetLeft,
                n.y.targetOffset += r.offsetTop,
                r = r.offsetParent
    }
    n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth,
        n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight,
        n.x.containerLength = e.clientWidth,
        n.y.containerLength = e.clientHeight
}
function TI(e, t, n, r = {}) {
    return {
        measure: () => CI(e, r.target, n),
        update: i => {
            gI(e, n, i),
                (r.offset || r.target) && kI(e, n, r)
        }
        ,
        notify: () => t(n)
    }
}
var ys = new WeakMap
    , my = new WeakMap
    , Rf = new WeakMap
    , gy = e => e === document.documentElement ? I : e;
function Tr(e, { container: t = document.documentElement, ...n } = {}) {
    let r = Rf.get(t);
    r || (r = new Set,
        Rf.set(t, r));
    let i = pI()
        , o = TI(t, e, i, n);
    if (r.add(o),
        !ys.has(t)) {
        let a = () => {
            for (let d of r)
                d.measure()
        }
            , l = () => {
                for (let d of r)
                    d.update(qe.timestamp)
            }
            , c = () => {
                for (let d of r)
                    d.notify()
            }
            , u = () => {
                J.read(a, !1, !0),
                    J.read(l, !1, !0),
                    J.update(c, !1, !0)
            }
            ;
        ys.set(t, u);
        let f = gy(t);
        I.addEventListener("resize", u, {
            passive: !0
        }),
            t !== document.documentElement && my.set(t, dI(t, u)),
            f.addEventListener("scroll", u, {
                passive: !0
            })
    }
    let s = ys.get(t);
    return J.read(s, !1, !0),
        () => {
            var a;
            Ft(s);
            let l = Rf.get(t);
            if (!l || (l.delete(o),
                l.size))
                return;
            let c = ys.get(t);
            ys.delete(t),
                c && (gy(t).removeEventListener("scroll", c),
                    (a = my.get(t)) === null || a === void 0 || a(),
                    I.removeEventListener("resize", c))
        }
}
function cb(e, t) {
    let n, r = () => {
        let { currentTime: i } = t
            , s = (i === null ? 0 : i.value) / 100;
        n !== s && e(s),
            n = s
    }
        ;
    return J.update(r, !0),
        () => Ft(r)
}
function RI({ source: e, container: t, axis: n = "y" }) {
    e && (t = e);
    let r = {
        value: 0
    }
        , i = Tr(o => {
            r.value = o[n].progress * 100
        }
            , {
                container: t,
                axis: n
            });
    return {
        currentTime: r,
        cancel: i
    }
}
var Ef = new Map;
function ub({ source: e, container: t = document.documentElement, axis: n = "y" } = {}) {
    e && (t = e),
        Ef.has(t) || Ef.set(t, {});
    let r = Ef.get(t);
    return r[n] || (r[n] = e0() ? new ScrollTimeline({
        source: t,
        axis: n
    }) : RI({
        source: t,
        axis: n
    })),
        r[n]
}
function EI(e) {
    return e.length === 2
}
function fb(e) {
    return e && (e.target || e.offset)
}
function FI(e, t) {
    return EI(e) || fb(t) ? Tr(n => {
        e(n[t.axis].progress, n)
    }
        , t) : cb(e, ub(t))
}
function PI(e, t) {
    if (fb(t))
        return e.pause(),
            Tr(n => {
                e.time = e.duration * n[t.axis].progress
            }
                , t);
    {
        let n = ub(t);
        return e.attachTimeline(n, r => (r.pause(),
            cb(i => {
                r.time = r.duration * i
            }
                , n)))
    }
}
function db(e, { axis: t = "y", ...n } = {}) {
    let r = {
        axis: t,
        ...n
    };
    return typeof e == "function" ? FI(e, r) : PI(e, r)
}
function vy(e, t) {
    vo(!!(!t || t.current), `You have defined a ${e} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`)
}
var _I = () => ({
    scrollX: Xe(0),
    scrollY: Xe(0),
    scrollXProgress: Xe(0),
    scrollYProgress: Xe(0)
});
function hb({ container: e, target: t, layoutEffect: n = !0, ...r } = {}) {
    let i = tr(_I);
    return (n ? Gr : H)(() => (vy("target", t),
        vy("container", e),
        db((s, { x: a, y: l }) => {
            i.scrollX.set(a.current),
                i.scrollXProgress.set(a.progress),
                i.scrollY.set(l.current),
                i.scrollYProgress.set(l.progress)
        }
            , {
                ...r,
                container: e?.current || void 0,
                target: t?.current || void 0
            })), [e, t, JSON.stringify(r.offset)]),
        i
}
function II(e) {
    let t = V(0)
        , { isStatic: n } = D(Jn);
    H(() => {
        if (n)
            return;
        let r = ({ timestamp: i, delta: o }) => {
            t.current || (t.current = i),
                e(i - t.current, o)
        }
            ;
        return J.update(r, !0),
            () => Ft(r)
    }
        , [e])
}
function pb() {
    !Id.current && C0();
    let [e] = Ee(bl.current);
    return e
}
function Fi() {
    let e = pb()
        , { reducedMotion: t } = D(Jn);
    return t === "never" ? !1 : t === "always" ? !0 : e
}
function OI(e) {
    e.values.forEach(t => t.stop())
}
function Xf(e, t) {
    [...t].reverse().forEach(r => {
        let i = e.getVariant(r);
        i && wd(e, i),
            e.variantChildren && e.variantChildren.forEach(o => {
                Xf(o, t)
            }
            )
    }
    )
}
function MI(e, t) {
    if (Array.isArray(t))
        return Xf(e, t);
    if (typeof t == "string")
        return Xf(e, [t]);
    wd(e, t)
}
function mb() {
    let e = !1
        , t = new Set
        , n = {
            subscribe(r) {
                return t.add(r),
                    () => void t.delete(r)
            },
            start(r, i) {
                nn(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
                let o = [];
                return t.forEach(s => {
                    o.push(kd(s, r, {
                        transitionOverride: i
                    }))
                }
                ),
                    Promise.all(o)
            },
            set(r) {
                return nn(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."),
                    t.forEach(i => {
                        MI(i, r)
                    }
                    )
            },
            stop() {
                t.forEach(r => {
                    OI(r)
                }
                )
            },
            mount() {
                return e = !0,
                    () => {
                        e = !1,
                            n.stop()
                    }
            }
        };
    return n
}
var gb = (e, t, n) => {
    let r = t - e;
    return ((n - e) % r + r) % r + e
}
    ;
function LI(e, t = 100, n) {
    let r = n({
        ...e,
        keyframes: [0, t]
    })
        , i = Math.min(jy(r), Vf);
    return {
        type: "keyframes",
        ease: o => r.next(i * o).value / t,
        duration: Yn(i)
    }
}
function Wd(e) {
    return typeof e == "object" && !Array.isArray(e)
}
function vb(e, t, n, r) {
    return typeof e == "string" && Wd(t) ? Hd(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e]
}
function yy(e, t, n, r) {
    var i;
    return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e
}
function VI(e, t) {
    return Dy(e) ? e[gb(0, e.length, t)] : e
}
function AI(e, t, n) {
    for (let r = 0; r < e.length; r++) {
        let i = e[r];
        i.at > t && i.at < n && (El(e, i),
            r--)
    }
}
function DI(e, t, n, r, i, o) {
    AI(e, i, o);
    for (let s = 0; s < t.length; s++)
        e.push({
            value: t[s],
            at: Le(i, o, r[s]),
            easing: VI(n, s)
        })
}
function zI(e, t) {
    return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at
}
var BI = "easeInOut";
function $I(e, { defaultTransition: t = {}, ...n } = {}, r, i) {
    let o = t.duration || .3
        , s = new Map
        , a = new Map
        , l = {}
        , c = new Map
        , u = 0
        , f = 0
        , d = 0;
    for (let p = 0; p < e.length; p++) {
        let v = e[p];
        if (typeof v == "string") {
            c.set(v, f);
            continue
        } else if (!Array.isArray(v)) {
            c.set(v.name, yy(f, v.at, u, c));
            continue
        }
        let [g, b, m = {}] = v;
        m.at !== void 0 && (f = yy(f, m.at, u, c));
        let h = 0
            , y = (w, C, S, T = 0, R = 0) => {
                let F = NI(w)
                    , { delay: P = 0, times: B = ud(F), type: $ = "keyframes", ...N } = C
                    , { ease: U = t.ease || "easeOut", duration: j } = C
                    , ae = typeof P == "function" ? P(T, R) : P
                    , te = F.length
                    , Y = Cl($) ? $ : i?.[$];
                if (te <= 2 && Y) {
                    let se = 100;
                    if (te === 2 && WI(F)) {
                        let Je = F[1] - F[0];
                        se = Math.abs(Je)
                    }
                    let le = {
                        ...N
                    };
                    j !== void 0 && (le.duration = Mn(j));
                    let q = LI(le, se, Y);
                    U = q.ease,
                        j = q.duration
                }
                j ?? (j = o);
                let ne = f + ae
                    , G = ne + j;
                B.length === 1 && B[0] === 0 && (B[1] = 1);
                let he = B.length - F.length;
                he > 0 && zy(B, he),
                    F.length === 1 && F.unshift(null),
                    DI(S, F, U, B, ne, G),
                    h = Math.max(ae + j, h),
                    d = Math.max(G, d)
            }
            ;
        if (Be(g)) {
            let w = by(g, a);
            y(b, m, xy("default", w))
        } else {
            let w = vb(g, b, r, l)
                , C = w.length;
            for (let S = 0; S < C; S++) {
                b = b,
                    m = m;
                let T = w[S]
                    , R = by(T, a);
                for (let F in b)
                    y(b[F], jI(m, F), xy(F, R), S, C)
            }
        }
        u = f,
            f += h
    }
    return a.forEach((p, v) => {
        for (let g in p) {
            let b = p[g];
            b.sort(zI);
            let m = []
                , h = []
                , y = [];
            for (let C = 0; C < b.length; C++) {
                let { at: S, value: T, easing: R } = b[C];
                m.push(T),
                    h.push(Cr(0, d, S)),
                    y.push(R || "easeOut")
            }
            h[0] !== 0 && (h.unshift(0),
                m.unshift(m[0]),
                y.unshift(BI)),
                h[h.length - 1] !== 1 && (h.push(1),
                    m.push(null)),
                s.has(v) || s.set(v, {
                    keyframes: {},
                    transition: {}
                });
            let w = s.get(v);
            w.keyframes[g] = m,
                w.transition[g] = {
                    ...t,
                    duration: d,
                    ease: y,
                    times: h,
                    ...n
                }
        }
    }
    ),
        s
}
function by(e, t) {
    return !t.has(e) && t.set(e, {}),
        t.get(e)
}
function xy(e, t) {
    return t[e] || (t[e] = []),
        t[e]
}
function NI(e) {
    return Array.isArray(e) ? e : [e]
}
function jI(e, t) {
    return e && e[t] ? {
        ...e,
        ...e[t]
    } : {
        ...e
    }
}
var HI = e => typeof e == "number"
    , WI = e => e.every(HI);
function UI(e, t) {
    return e in t
}
var GI = class extends Od {
    constructor() {
        super(...arguments),
            this.type = "object"
    }
    readValueFromInstance(e, t) {
        if (UI(t, e)) {
            let n = e[t];
            if (typeof n == "string" || typeof n == "number")
                return n
        }
    }
    getBaseTargetFromProps() { }
    removeValueFromRenderState(e, t) {
        delete t.output[e]
    }
    measureInstanceViewportBox() {
        return je()
    }
    build(e, t) {
        Object.assign(e.output, t)
    }
    renderInstance(e, { output: t }) {
        Object.assign(e, t)
    }
    sortInstanceNodePosition() {
        return 0
    }
}
    ;
function qI(e) {
    let t = {
        presenceContext: null,
        props: {},
        visualState: {
            renderState: {
                transform: {},
                transformOrigin: {},
                style: {},
                vars: {},
                attrs: {}
            },
            latestValues: {}
        }
    }
        , n = D0(e) ? new nb(t) : new tb(t);
    n.mount(e),
        er.set(e, n)
}
function XI(e) {
    let t = {
        presenceContext: null,
        props: {},
        visualState: {
            renderState: {
                output: {}
            },
            latestValues: {}
        }
    }
        , n = new GI(t);
    n.mount(e),
        er.set(e, n)
}
function YI(e, t) {
    return Be(e) || typeof e == "number" || typeof e == "string" && !Wd(t)
}
function yb(e, t, n, r) {
    let i = [];
    if (YI(e, t))
        i.push(z0(e, Wd(t) && t.default || t, n && (n.default || n)));
    else {
        let o = vb(e, t, r)
            , s = o.length;
        nn(!!s, "No valid elements provided.");
        for (let a = 0; a < s; a++) {
            let l = o[a]
                , c = l instanceof Element ? qI : XI;
            er.has(l) || c(l);
            let u = er.get(l)
                , f = {
                    ...n
                };
            "delay" in f && typeof f.delay == "function" && (f.delay = f.delay(a, s)),
                i.push(...Sd(u, {
                    ...t,
                    transition: f
                }, {}))
        }
    }
    return i
}
function KI(e, t, n) {
    let r = [];
    return $I(e, t, n, {
        spring: Ls
    }).forEach(({ keyframes: o, transition: s }, a) => {
        r.push(...yb(a, o, s))
    }
    ),
        r
}
function QI(e) {
    return Array.isArray(e) && Array.isArray(e[0])
}
function bb(e) {
    function t(n, r, i) {
        let o = [];
        QI(n) ? o = KI(n, r, e) : o = yb(n, r, i, e);
        let s = new t0(o);
        return e && e.animations.push(s),
            s
    }
    return t
}
var rr = bb();
function xb() {
    let e = tr(mb);
    return Gr(e.mount, []),
        e
}
var wb = xb;
var ZI = {
    some: 0,
    all: 1
};
function zl(e, t, { root: n, margin: r, amount: i = "some" } = {}) {
    let o = Hd(e)
        , s = new WeakMap
        , a = c => {
            c.forEach(u => {
                let f = s.get(u.target);
                if (u.isIntersecting !== !!f)
                    if (u.isIntersecting) {
                        let d = t(u);
                        typeof d == "function" ? s.set(u.target, d) : l.unobserve(u.target)
                    } else
                        f && (f(u),
                            s.delete(u.target))
            }
            )
        }
        , l = new IntersectionObserver(a, {
            root: n,
            rootMargin: r,
            threshold: typeof i == "number" ? i : ZI[i]
        });
    return o.forEach(c => l.observe(c)),
        () => l.disconnect()
}
function JI(e, { root: t, margin: n, amount: r, once: i = !1 } = {}) {
    let [o, s] = Ee(!1);
    return H(() => {
        if (!e.current || i && o)
            return;
        let a = () => (s(!0),
            i ? void 0 : () => s(!1))
            , l = {
                root: t && t.current || void 0,
                margin: n,
                amount: r
            };
        return zl(e.current, a, l)
    }
        , [t, e, n, i, r]),
        o
}
function Bl(e) {
    return e !== null && typeof e == "object" && _d in e
}
function Ud(e) {
    if (Bl(e))
        return e[_d]
}
function Gd() {
    return e2
}
function e2(e) {
    Ei.current && (Ei.current.isUpdating = !1,
        Ei.current.blockUpdate(),
        e && e())
}
function Sb() {
    let [e, t] = Nd()
        , n = Gd()
        , r = V();
    return H(() => {
        J.postRender(() => J.postRender(() => {
            t === r.current && (ml.current = !1)
        }
        ))
    }
        , [t]),
        i => {
            n(() => {
                ml.current = !0,
                    e(),
                    i(),
                    r.current = t + 1
            }
            )
        }
}
function kb() {
    return Q(() => {
        let t = Ei.current;
        t && t.resetTree()
    }
        , [])
}
var wy = () => ({});
var lj = Dl({
    scrapeMotionValuesFromProps: wy,
    createRenderState: wy
});
var Cb = {};
Bg(Cb, {
    Group: () => r2,
    Item: () => a2
});
var Tb = be(null);
function t2(e, t, n, r) {
    if (!r)
        return e;
    let i = e.findIndex(u => u.value === t);
    if (i === -1)
        return e;
    let o = r > 0 ? 1 : -1
        , s = e[i + o];
    if (!s)
        return e;
    let a = e[i]
        , l = s.layout
        , c = Le(l.min, l.max, .5);
    return o === 1 && a.layout.max + n > c || o === -1 && a.layout.min + n < c ? IF(e, i, i + o) : e
}
function n2({ children: e, as: t = "ul", axis: n = "y", onReorder: r, values: i, ...o }, s) {
    let a = tr(() => Ye[t])
        , l = []
        , c = V(!1);
    nn(!!i, "Reorder.Group must be provided a values prop");
    let u = {
        axis: n,
        registerItem: (f, d) => {
            let p = l.findIndex(v => f === v.value);
            p !== -1 ? l[p].layout = d[n] : l.push({
                value: f,
                layout: d[n]
            }),
                l.sort(o2)
        }
        ,
        updateOrder: (f, d, p) => {
            if (c.current)
                return;
            let v = t2(l, f, d, p);
            l !== v && (c.current = !0,
                r(v.map(i2).filter(g => i.indexOf(g) !== -1)))
        }
    };
    return H(() => {
        c.current = !1
    }
    ),
        k(a, {
            ...o,
            ref: s,
            ignoreStrict: !0,
            children: k(Tb.Provider, {
                value: u,
                children: e
            })
        })
}
var r2 = Ie(n2);
function i2(e) {
    return e.value
}
function o2(e, t) {
    return e.layout.min - t.layout.min
}
function Sy(e, t = 0) {
    return Be(e) ? e : nr(t)
}
function s2({ children: e, style: t = {}, value: n, as: r = "li", onDrag: i, layout: o = !0, ...s }, a) {
    let l = tr(() => Ye[r])
        , c = D(Tb)
        , u = {
            x: Sy(t.x),
            y: Sy(t.y)
        }
        , f = Dt([u.x, u.y], ([g, b]) => g || b ? 1 : "unset");
    nn(!!c, "Reorder.Item must be a child of Reorder.Group");
    let { axis: d, registerItem: p, updateOrder: v } = c;
    return k(l, {
        drag: d,
        ...s,
        dragSnapToOrigin: !0,
        style: {
            ...t,
            x: u.x,
            y: u.y,
            zIndex: f
        },
        layout: o,
        onDrag: (g, b) => {
            let { velocity: m } = b;
            m[d] && v(n, u[d].get(), m[d]),
                i && i(g, b)
        }
        ,
        onLayoutMeasure: g => p(n, g),
        ref: a,
        ignoreStrict: !0,
        children: e
    })
}
var a2 = Ie(s2);
function l2(e, t) {
    if (e === "first")
        return 0;
    {
        let n = t - 1;
        return e === "last" ? n : n / 2
    }
}
function qd(e = .1, { startDelay: t = 0, from: n = 0, ease: r } = {}) {
    return (i, o) => {
        let s = typeof n == "number" ? n : l2(n, o)
            , a = Math.abs(s - i)
            , l = e * a;
        if (r) {
            let c = o * e;
            l = Of(r)(l / c) * c
        }
        return t + l
    }
}
var c2 = bs.reduce((e, t) => (e[t] = n => Ft(n),
    e), {});
var WM = {};
lf(WM, {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => OM,
    createPortal: () => MM,
    createRoot: () => LM,
    default: () => jS,
    findDOMNode: () => VM,
    flushSync: () => AM,
    hydrate: () => DM,
    hydrateRoot: () => zM,
    render: () => BM,
    unmountComponentAtNode: () => $M,
    unstable_batchedUpdates: () => NM,
    unstable_renderSubtreeIntoContainer: () => jM,
    version: () => HM
});
var Ul = {};
lf(Ul, {
    default: () => ie,
    unstable_IdlePriority: () => d2,
    unstable_ImmediatePriority: () => h2,
    unstable_LowPriority: () => p2,
    unstable_NormalPriority: () => m2,
    unstable_Profiling: () => g2,
    unstable_UserBlockingPriority: () => v2,
    unstable_cancelCallback: () => y2,
    unstable_continueExecution: () => b2,
    unstable_forceFrameRate: () => x2,
    unstable_getCurrentPriorityLevel: () => w2,
    unstable_getFirstCallbackNode: () => S2,
    unstable_next: () => k2,
    unstable_now: () => f2,
    unstable_pauseExecution: () => C2,
    unstable_requestPaint: () => T2,
    unstable_runWithPriority: () => R2,
    unstable_scheduleCallback: () => E2,
    unstable_shouldYield: () => F2,
    unstable_wrapCallback: () => P2
});
var ie = {};
function Qd(e, t) {
    var n = e.length;
    e.push(t);
    e: for (; 0 < n;) {
        var r = n - 1 >>> 1
            , i = e[r];
        if (!(0 < $l(i, t)))
            break e;
        e[r] = t,
            e[n] = i,
            n = r
    }
}
function Ln(e) {
    return e.length === 0 ? null : e[0]
}
function jl(e) {
    if (e.length === 0)
        return null;
    var t = e[0]
        , n = e.pop();
    if (n !== t) {
        e[0] = n;
        e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) {
            var s = 2 * (r + 1) - 1
                , a = e[s]
                , l = s + 1
                , c = e[l];
            if (0 > $l(a, n))
                l < i && 0 > $l(c, a) ? (e[r] = c,
                    e[l] = n,
                    r = l) : (e[r] = a,
                        e[s] = n,
                        r = s);
            else {
                if (!(l < i && 0 > $l(c, n)))
                    break e;
                e[r] = c,
                    e[l] = n,
                    r = l
            }
        }
    }
    return t
}
function $l(e, t) {
    var n = e.sortIndex - t.sortIndex;
    return n !== 0 ? n : e.id - t.id
}
typeof performance == "object" && typeof performance.now == "function" ? (Rb = performance,
    ie.unstable_now = function () {
        return Rb.now()
    }
) : (Xd = Date,
    Eb = Xd.now(),
    ie.unstable_now = function () {
        return Xd.now() - Eb
    }
);
var Rb, Xd, Eb, ir = [], qr = [], u2 = 1, Sn = null, Pt = 3, Hl = !1, Pi = !1, zs = !1, _b = typeof setTimeout == "function" ? setTimeout : null, Ib = typeof clearTimeout == "function" ? clearTimeout : null, Fb = typeof setImmediate < "u" ? setImmediate : null;
typeof _e < "u" && _e.scheduling !== void 0 && _e.scheduling.isInputPending !== void 0 && _e.scheduling.isInputPending.bind(_e.scheduling);
function Zd(e) {
    for (var t = Ln(qr); t !== null;) {
        if (t.callback === null)
            jl(qr);
        else {
            if (!(t.startTime <= e))
                break;
            jl(qr),
                t.sortIndex = t.expirationTime,
                Qd(ir, t)
        }
        t = Ln(qr)
    }
}
function Jd(e) {
    if (zs = !1,
        Zd(e),
        !Pi)
        if (Ln(ir) !== null)
            Pi = !0,
                th(eh);
        else {
            var t = Ln(qr);
            t !== null && nh(Jd, t.startTime - e)
        }
}
function eh(e, t) {
    Pi = !1,
        zs && (zs = !1,
            Ib(Bs),
            Bs = -1),
        Hl = !0;
    var n = Pt;
    try {
        for (Zd(t),
            Sn = Ln(ir); Sn !== null && (!(Sn.expirationTime > t) || e && !Lb());) {
            var r = Sn.callback;
            if (typeof r == "function") {
                Sn.callback = null,
                    Pt = Sn.priorityLevel;
                var i = r(Sn.expirationTime <= t);
                t = ie.unstable_now(),
                    typeof i == "function" ? Sn.callback = i : Sn === Ln(ir) && jl(ir),
                    Zd(t)
            } else
                jl(ir);
            Sn = Ln(ir)
        }
        if (Sn !== null)
            var o = !0;
        else {
            var s = Ln(qr);
            s !== null && nh(Jd, s.startTime - t),
                o = !1
        }
        return o
    } finally {
        Sn = null,
            Pt = n,
            Hl = !1
    }
}
var Wl = !1
    , Nl = null
    , Bs = -1
    , Ob = 5
    , Mb = -1;
function Lb() {
    return !(ie.unstable_now() - Mb < Ob)
}
function Yd() {
    if (Nl !== null) {
        var e = ie.unstable_now();
        Mb = e;
        var t = !0;
        try {
            t = Nl(!0, e)
        } finally {
            t ? Ds() : (Wl = !1,
                Nl = null)
        }
    } else
        Wl = !1
}
var Ds;
typeof Fb == "function" ? Ds = function () {
    Fb(Yd)
}
    : typeof MessageChannel < "u" ? (Kd = new MessageChannel,
        Pb = Kd.port2,
        Kd.port1.onmessage = Yd,
        Ds = function () {
            Pb.postMessage(null)
        }
    ) : Ds = function () {
        _b(Yd, 0)
    }
    ;
var Kd, Pb;
function th(e) {
    Nl = e,
        Wl || (Wl = !0,
            Ds())
}
function nh(e, t) {
    Bs = _b(function () {
        e(ie.unstable_now())
    }, t)
}
ie.unstable_IdlePriority = 5;
ie.unstable_ImmediatePriority = 1;
ie.unstable_LowPriority = 4;
ie.unstable_NormalPriority = 3;
ie.unstable_Profiling = null;
ie.unstable_UserBlockingPriority = 2;
ie.unstable_cancelCallback = function (e) {
    e.callback = null
}
    ;
ie.unstable_continueExecution = function () {
    Pi || Hl || (Pi = !0,
        th(eh))
}
    ;
ie.unstable_forceFrameRate = function (e) {
    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ob = 0 < e ? Math.floor(1e3 / e) : 5
}
    ;
ie.unstable_getCurrentPriorityLevel = function () {
    return Pt
}
    ;
ie.unstable_getFirstCallbackNode = function () {
    return Ln(ir)
}
    ;
ie.unstable_next = function (e) {
    switch (Pt) {
        case 1:
        case 2:
        case 3:
            var t = 3;
            break;
        default:
            t = Pt
    }
    var n = Pt;
    Pt = t;
    try {
        return e()
    } finally {
        Pt = n
    }
}
    ;
ie.unstable_pauseExecution = function () { }
    ;
ie.unstable_requestPaint = function () { }
    ;
ie.unstable_runWithPriority = function (e, t) {
    switch (e) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            e = 3
    }
    var n = Pt;
    Pt = e;
    try {
        return t()
    } finally {
        Pt = n
    }
}
    ;
ie.unstable_scheduleCallback = function (e, t, n) {
    var r = ie.unstable_now();
    switch (typeof n == "object" && n !== null ? (n = n.delay,
        n = typeof n == "number" && 0 < n ? r + n : r) : n = r,
    e) {
        case 1:
            var i = -1;
            break;
        case 2:
            i = 250;
            break;
        case 5:
            i = 1073741823;
            break;
        case 4:
            i = 1e4;
            break;
        default:
            i = 5e3
    }
    return i = n + i,
        e = {
            id: u2++,
            callback: t,
            priorityLevel: e,
            startTime: n,
            expirationTime: i,
            sortIndex: -1
        },
        n > r ? (e.sortIndex = n,
            Qd(qr, e),
            Ln(ir) === null && e === Ln(qr) && (zs ? (Ib(Bs),
                Bs = -1) : zs = !0,
                nh(Jd, n - r))) : (e.sortIndex = i,
                    Qd(ir, e),
                    Pi || Hl || (Pi = !0,
                        th(eh))),
        e
}
    ;
ie.unstable_shouldYield = Lb;
ie.unstable_wrapCallback = function (e) {
    var t = Pt;
    return function () {
        var n = Pt;
        Pt = t;
        try {
            return e.apply(this, arguments)
        } finally {
            Pt = n
        }
    }
}
    ;
var f2 = ie.unstable_now
    , d2 = ie.unstable_IdlePriority
    , h2 = ie.unstable_ImmediatePriority
    , p2 = ie.unstable_LowPriority
    , m2 = ie.unstable_NormalPriority
    , g2 = ie.unstable_Profiling
    , v2 = ie.unstable_UserBlockingPriority
    , y2 = ie.unstable_cancelCallback
    , b2 = ie.unstable_continueExecution
    , x2 = ie.unstable_forceFrameRate
    , w2 = ie.unstable_getCurrentPriorityLevel
    , S2 = ie.unstable_getFirstCallbackNode
    , k2 = ie.unstable_next
    , C2 = ie.unstable_pauseExecution
    , T2 = ie.unstable_requestPaint
    , R2 = ie.unstable_runWithPriority
    , E2 = ie.unstable_scheduleCallback
    , F2 = ie.unstable_shouldYield
    , P2 = ie.unstable_wrapCallback;
var _2 = "default" in Rt ? x : Rt
    , I2 = "default" in Ul ? ie : Ul
    , ln = {}
    , Nx = _2
    , an = I2;
function M(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
        t += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var jx = new Set
    , aa = {};
function ji(e, t) {
    jo(e, t),
        jo(e + "Capture", t)
}
function jo(e, t) {
    for (aa[e] = t,
        e = 0; e < t.length; e++)
        jx.add(t[e])
}
var Ir = !(typeof I > "u" || typeof I.document > "u" || typeof I.document.createElement > "u")
    , Th = Object.prototype.hasOwnProperty
    , O2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
    , Vb = {}
    , Ab = {};
function M2(e) {
    return Th.call(Ab, e) ? !0 : Th.call(Vb, e) ? !1 : O2.test(e) ? Ab[e] = !0 : (Vb[e] = !0,
        !1)
}
function L2(e, t, n, r) {
    if (n !== null && n.type === 0)
        return !1;
    switch (typeof t) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
                e !== "data-" && e !== "aria-");
        default:
            return !1
    }
}
function V2(e, t, n, r) {
    if (t === null || typeof t > "u" || L2(e, t, n, r))
        return !0;
    if (r)
        return !1;
    if (n !== null)
        switch (n.type) {
            case 3:
                return !t;
            case 4:
                return t === !1;
            case 5:
                return isNaN(t);
            case 6:
                return isNaN(t) || 1 > t
        }
    return !1
}
function $t(e, t, n, r, i, o, s) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4,
        this.attributeName = r,
        this.attributeNamespace = i,
        this.mustUseProperty = n,
        this.propertyName = e,
        this.type = t,
        this.sanitizeURL = o,
        this.removeEmptyString = s
}
var Ct = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) {
    Ct[e] = new $t(e, 0, !1, e, null, !1, !1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) {
    var t = e[0];
    Ct[t] = new $t(t, 1, !1, e[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
    Ct[e] = new $t(e, 2, !1, e.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) {
    Ct[e] = new $t(e, 2, !1, e, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) {
    Ct[e] = new $t(e, 3, !1, e.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function (e) {
    Ct[e] = new $t(e, 3, !0, e, null, !1, !1)
});
["capture", "download"].forEach(function (e) {
    Ct[e] = new $t(e, 4, !1, e, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function (e) {
    Ct[e] = new $t(e, 6, !1, e, null, !1, !1)
});
["rowSpan", "start"].forEach(function (e) {
    Ct[e] = new $t(e, 5, !1, e.toLowerCase(), null, !1, !1)
});
var gp = /[\-:]([a-z])/g;
function vp(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) {
    var t = e.replace(gp, vp);
    Ct[t] = new $t(t, 1, !1, e, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) {
    var t = e.replace(gp, vp);
    Ct[t] = new $t(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
    var t = e.replace(gp, vp);
    Ct[t] = new $t(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function (e) {
    Ct[e] = new $t(e, 1, !1, e.toLowerCase(), null, !1, !1)
});
Ct.xlinkHref = new $t("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (e) {
    Ct[e] = new $t(e, 1, !1, e.toLowerCase(), null, !0, !0)
});
function yp(e, t, n, r) {
    var i = Ct.hasOwnProperty(t) ? Ct[t] : null;
    (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (V2(t, n, i, r) && (n = null),
        r || i === null ? M2(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && "" : n : (t = i.attributeName,
            r = i.attributeNamespace,
            n === null ? e.removeAttribute(t) : (i = i.type,
                n = i === 3 || i === 4 && n === !0 ? "" : "" + n,
                r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var Vr = Nx.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
    , Gl = Symbol.for("react.element")
    , Co = Symbol.for("react.portal")
    , To = Symbol.for("react.fragment")
    , bp = Symbol.for("react.strict_mode")
    , Rh = Symbol.for("react.profiler")
    , Hx = Symbol.for("react.provider")
    , Wx = Symbol.for("react.context")
    , xp = Symbol.for("react.forward_ref")
    , Eh = Symbol.for("react.suspense")
    , Fh = Symbol.for("react.suspense_list")
    , wp = Symbol.for("react.memo")
    , Yr = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var Ux = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.cache");
Symbol.for("react.tracing_marker");
var Db = Symbol.iterator;
function $s(e) {
    return e === null || typeof e != "object" ? null : (e = Db && e[Db] || e["@@iterator"],
        typeof e == "function" ? e : null)
}
var rh, Ue = Object.assign;
function Xs(e) {
    if (rh === void 0)
        try {
            throw Error()
        } catch (n) {
            var t = n.stack.trim().match(/\n( *(at )?)/);
            rh = t && t[1] || ""
        }
    return `
` + rh + e
}
var ih = !1;
function oh(e, t) {
    if (!e || ih)
        return "";
    ih = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function () {
                throw Error()
            }
                ,
                Object.defineProperty(t.prototype, "props", {
                    set: function () {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (c) {
                    r = c
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            e()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)
                a--;
            for (; 1 <= s && 0 <= a; s--,
                a--)
                if (i[s] !== o[a]) {
                    if (s !== 1 || a !== 1)
                        do
                            if (s--,
                                a--,
                                0 > a || i[s] !== o[a]) {
                                var l = `
` + i[s].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                    l
                            }
                        while (1 <= s && 0 <= a);
                    break
                }
        }
    } finally {
        ih = !1,
            Error.prepareStackTrace = n
    }
    return (e = e ? e.displayName || e.name : "") ? Xs(e) : ""
}
function A2(e) {
    switch (e.tag) {
        case 5:
            return Xs(e.type);
        case 16:
            return Xs("Lazy");
        case 13:
            return Xs("Suspense");
        case 19:
            return Xs("SuspenseList");
        case 0:
        case 2:
        case 15:
            return e = oh(e.type, !1),
                e;
        case 11:
            return e = oh(e.type.render, !1),
                e;
        case 1:
            return e = oh(e.type, !0),
                e;
        default:
            return ""
    }
}
function Ph(e) {
    if (e == null)
        return null;
    if (typeof e == "function")
        return e.displayName || e.name || null;
    if (typeof e == "string")
        return e;
    switch (e) {
        case To:
            return "Fragment";
        case Co:
            return "Portal";
        case Rh:
            return "Profiler";
        case bp:
            return "StrictMode";
        case Eh:
            return "Suspense";
        case Fh:
            return "SuspenseList"
    }
    if (typeof e == "object")
        switch (e.$$typeof) {
            case Wx:
                return (e.displayName || "Context") + ".Consumer";
            case Hx:
                return (e._context.displayName || "Context") + ".Provider";
            case xp:
                var t = e.render;
                return e = e.displayName,
                    e || (e = t.displayName || t.name || "",
                        e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
                    e;
            case wp:
                return t = e.displayName || null,
                    t !== null ? t : Ph(e.type) || "Memo";
            case Yr:
                t = e._payload,
                    e = e._init;
                try {
                    return Ph(e(t))
                } catch { }
        }
    return null
}
function D2(e) {
    var t = e.type;
    switch (e.tag) {
        case 24:
            return "Cache";
        case 9:
            return (t.displayName || "Context") + ".Consumer";
        case 10:
            return (t._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return e = t.render,
                e = e.displayName || e.name || "",
                t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return t;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Ph(t);
        case 8:
            return t === bp ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof t == "function")
                return t.displayName || t.name || null;
            if (typeof t == "string")
                return t
    }
    return null
}
function ci(e) {
    switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return e;
        case "object":
            return e;
        default:
            return ""
    }
}
function Gx(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function z2(e) {
    var t = Gx(e) ? "checked" : "value"
        , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
        , r = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get
            , o = n.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function () {
                return i.call(this)
            },
            set: function (s) {
                r = "" + s,
                    o.call(this, s)
            }
        }),
            Object.defineProperty(e, t, {
                enumerable: n.enumerable
            }),
        {
            getValue: function () {
                return r
            },
            setValue: function (s) {
                r = "" + s
            },
            stopTracking: function () {
                e._valueTracker = null,
                    delete e[t]
            }
        }
    }
}
function ql(e) {
    e._valueTracker || (e._valueTracker = z2(e))
}
function qx(e) {
    if (!e)
        return !1;
    var t = e._valueTracker;
    if (!t)
        return !0;
    var n = t.getValue()
        , r = "";
    return e && (r = Gx(e) ? e.checked ? "true" : "false" : e.value),
        e = r,
        e !== n && (t.setValue(e),
            !0)
}
function wc(e) {
    if (e = e || (typeof document < "u" ? document : void 0),
        typeof e > "u")
        return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}
function _h(e, t) {
    var n = t.checked;
    return Ue({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ?? e._wrapperState.initialChecked
    })
}
function zb(e, t) {
    var n = t.defaultValue == null ? "" : t.defaultValue
        , r = t.checked != null ? t.checked : t.defaultChecked;
    n = ci(t.value != null ? t.value : n),
        e._wrapperState = {
            initialChecked: r,
            initialValue: n,
            controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
        }
}
function Xx(e, t) {
    t = t.checked,
        t != null && yp(e, "checked", t, !1)
}
function Ih(e, t) {
    Xx(e, t);
    var n = ci(t.value)
        , r = t.type;
    if (n != null)
        r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if (r === "submit" || r === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? Oh(e, t.type, n) : t.hasOwnProperty("defaultValue") && Oh(e, t.type, ci(t.defaultValue)),
        t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function Bb(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var r = t.type;
        if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null))
            return;
        t = "" + e._wrapperState.initialValue,
            n || t === e.value || (e.value = t),
            e.defaultValue = t
    }
    n = e.name,
        n !== "" && (e.name = ""),
        e.defaultChecked = !!e._wrapperState.initialChecked,
        n !== "" && (e.name = n)
}
function Oh(e, t, n) {
    t === "number" && wc(e.ownerDocument) === e || (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Ys = Array.isArray;
function Ao(e, t, n, r) {
    if (e = e.options,
        t) {
        t = {};
        for (var i = 0; i < n.length; i++)
            t["$" + n[i]] = !0;
        for (n = 0; n < e.length; n++)
            i = t.hasOwnProperty("$" + e[n].value),
                e[n].selected !== i && (e[n].selected = i),
                i && r && (e[n].defaultSelected = !0)
    } else {
        for (n = "" + ci(n),
            t = null,
            i = 0; i < e.length; i++) {
            if (e[i].value === n) {
                e[i].selected = !0,
                    r && (e[i].defaultSelected = !0);
                return
            }
            t !== null || e[i].disabled || (t = e[i])
        }
        t !== null && (t.selected = !0)
    }
}
function Mh(e, t) {
    if (t.dangerouslySetInnerHTML != null)
        throw Error(M(91));
    return Ue({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}
function $b(e, t) {
    var n = t.value;
    if (n == null) {
        if (n = t.children,
            t = t.defaultValue,
            n != null) {
            if (t != null)
                throw Error(M(92));
            if (Ys(n)) {
                if (1 < n.length)
                    throw Error(M(93));
                n = n[0]
            }
            t = n
        }
        t == null && (t = ""),
            n = t
    }
    e._wrapperState = {
        initialValue: ci(n)
    }
}
function Yx(e, t) {
    var n = ci(t.value)
        , r = ci(t.defaultValue);
    n != null && (n = "" + n,
        n !== e.value && (e.value = n),
        t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
        r != null && (e.defaultValue = "" + r)
}
function Nb(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function Kx(e) {
    switch (e) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}
function Lh(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? Kx(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Xl, Qx = function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) {
        MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i)
        })
    }
        : e
}(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
        e.innerHTML = t;
    else {
        for (Xl = Xl || document.createElement("div"),
            Xl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
            t = Xl.firstChild; e.firstChild;)
            e.removeChild(e.firstChild);
        for (; t.firstChild;)
            e.appendChild(t.firstChild)
    }
});
function la(e, t) {
    if (t) {
        var n = e.firstChild;
        if (n && n === e.lastChild && n.nodeType === 3) {
            n.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var Zs = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
    , B2 = ["Webkit", "ms", "Moz", "O"];
Object.keys(Zs).forEach(function (e) {
    B2.forEach(function (t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1),
            Zs[t] = Zs[e]
    })
});
function Zx(e, t, n) {
    return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Zs.hasOwnProperty(e) && Zs[e] ? ("" + t).trim() : t + "px"
}
function Jx(e, t) {
    e = e.style;
    for (var n in t)
        if (t.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0
                , i = Zx(n, t[n], r);
            n === "float" && (n = "cssFloat"),
                r ? e.setProperty(n, i) : e[n] = i
        }
}
var $2 = Ue({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Vh(e, t) {
    if (t) {
        if ($2[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
            throw Error(M(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null)
                throw Error(M(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML))
                throw Error(M(61))
        }
        if (t.style != null && typeof t.style != "object")
            throw Error(M(62))
    }
}
function Ah(e, t) {
    if (e.indexOf("-") === -1)
        return typeof t.is == "string";
    switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var Dh = null;
function Sp(e) {
    return e = e.target || e.srcElement || I,
        e.correspondingUseElement && (e = e.correspondingUseElement),
        e.nodeType === 3 ? e.parentNode : e
}
var zh = null
    , Do = null
    , zo = null;
function jb(e) {
    if (e = Ra(e)) {
        if (typeof zh != "function")
            throw Error(M(280));
        var t = e.stateNode;
        t && (t = Yc(t),
            zh(e.stateNode, e.type, t))
    }
}
function ew(e) {
    Do ? zo ? zo.push(e) : zo = [e] : Do = e
}
function tw() {
    if (Do) {
        var e = Do
            , t = zo;
        if (zo = Do = null,
            jb(e),
            t)
            for (e = 0; e < t.length; e++)
                jb(t[e])
    }
}
function nw(e, t) {
    return e(t)
}
function rw() { }
var sh = !1;
function iw(e, t, n) {
    if (sh)
        return e(t, n);
    sh = !0;
    try {
        return nw(e, t, n)
    } finally {
        sh = !1,
            (Do !== null || zo !== null) && (rw(),
                tw())
    }
}
function ca(e, t) {
    var n = e.stateNode;
    if (n === null)
        return null;
    var r = Yc(n);
    if (r === null)
        return null;
    n = r[t];
    e: switch (t) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (e = e.type,
                r = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
                e = !r;
            break e;
        default:
            e = !1
    }
    if (e)
        return null;
    if (n && typeof n != "function")
        throw Error(M(231, t, typeof n));
    return n
}
var Bh = !1;
if (Ir)
    try {
        So = {},
            Object.defineProperty(So, "passive", {
                get: function () {
                    Bh = !0
                }
            }),
            I.addEventListener("test", So, So),
            I.removeEventListener("test", So, So)
    } catch {
        Bh = !1
    }
var So;
function N2(e, t, n, r, i, o, s, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(n, c)
    } catch (u) {
        this.onError(u)
    }
}
var Js = !1
    , Sc = null
    , kc = !1
    , $h = null
    , j2 = {
        onError: function (e) {
            Js = !0,
                Sc = e
        }
    };
function H2(e, t, n, r, i, o, s, a, l) {
    Js = !1,
        Sc = null,
        N2.apply(j2, arguments)
}
function W2(e, t, n, r, i, o, s, a, l) {
    if (H2.apply(this, arguments),
        Js) {
        if (!Js)
            throw Error(M(198));
        var c = Sc;
        Js = !1,
            Sc = null,
            kc || (kc = !0,
                $h = c)
    }
}
function Hi(e) {
    var t = e
        , n = e;
    if (e.alternate)
        for (; t.return;)
            t = t.return;
    else {
        e = t;
        do
            t = e,
                4098 & t.flags && (n = t.return),
                e = t.return;
        while (e)
    }
    return t.tag === 3 ? n : null
}
function ow(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate,
            e !== null && (t = e.memoizedState)),
            t !== null)
            return t.dehydrated
    }
    return null
}
function Hb(e) {
    if (Hi(e) !== e)
        throw Error(M(188))
}
function U2(e) {
    var t = e.alternate;
    if (!t) {
        if (t = Hi(e),
            t === null)
            throw Error(M(188));
        return t !== e ? null : e
    }
    for (var n = e, r = t; ;) {
        var i = n.return;
        if (i === null)
            break;
        var o = i.alternate;
        if (o === null) {
            if (r = i.return,
                r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === o.child) {
            for (o = i.child; o;) {
                if (o === n)
                    return Hb(i),
                        e;
                if (o === r)
                    return Hb(i),
                        t;
                o = o.sibling
            }
            throw Error(M(188))
        }
        if (n.return !== r.return)
            n = i,
                r = o;
        else {
            for (var s = !1, a = i.child; a;) {
                if (a === n) {
                    s = !0,
                        n = i,
                        r = o;
                    break
                }
                if (a === r) {
                    s = !0,
                        r = i,
                        n = o;
                    break
                }
                a = a.sibling
            }
            if (!s) {
                for (a = o.child; a;) {
                    if (a === n) {
                        s = !0,
                            n = o,
                            r = i;
                        break
                    }
                    if (a === r) {
                        s = !0,
                            r = o,
                            n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!s)
                    throw Error(M(189))
            }
        }
        if (n.alternate !== r)
            throw Error(M(190))
    }
    if (n.tag !== 3)
        throw Error(M(188));
    return n.stateNode.current === n ? e : t
}
function sw(e) {
    return e = U2(e),
        e !== null ? aw(e) : null
}
function aw(e) {
    if (e.tag === 5 || e.tag === 6)
        return e;
    for (e = e.child; e !== null;) {
        var t = aw(e);
        if (t !== null)
            return t;
        e = e.sibling
    }
    return null
}
var lw = an.unstable_scheduleCallback
    , Wb = an.unstable_cancelCallback
    , G2 = an.unstable_shouldYield
    , q2 = an.unstable_requestPaint
    , nt = an.unstable_now
    , X2 = an.unstable_getCurrentPriorityLevel
    , kp = an.unstable_ImmediatePriority
    , cw = an.unstable_UserBlockingPriority
    , Cc = an.unstable_NormalPriority
    , Y2 = an.unstable_LowPriority
    , uw = an.unstable_IdlePriority
    , Uc = null
    , lr = null;
function K2(e) {
    if (lr && typeof lr.onCommitFiberRoot == "function")
        try {
            lr.onCommitFiberRoot(Uc, e, void 0, (128 & e.current.flags) === 128)
        } catch { }
}
var Bn = Math.clz32 ? Math.clz32 : J2
    , Q2 = Math.log
    , Z2 = Math.LN2;
function J2(e) {
    return e >>>= 0,
        e === 0 ? 32 : 31 - (Q2(e) / Z2 | 0) | 0
}
var Yl = 64
    , Kl = 4194304;
function Ks(e) {
    switch (e & -e) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return 4194240 & e;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return 130023424 & e;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return e
    }
}
function Tc(e, t) {
    var n = e.pendingLanes;
    if (n === 0)
        return 0;
    var r = 0
        , i = e.suspendedLanes
        , o = e.pingedLanes
        , s = 268435455 & n;
    if (s !== 0) {
        var a = s & ~i;
        a !== 0 ? r = Ks(a) : (o &= s,
            o !== 0 && (r = Ks(o)))
    } else
        s = n & ~i,
            s !== 0 ? r = Ks(s) : o !== 0 && (r = Ks(o));
    if (r === 0)
        return 0;
    if (t !== 0 && t !== r && !(t & i) && (i = r & -r,
        o = t & -t,
        i >= o || i === 16 && (4194240 & o) !== 0))
        return t;
    if (4 & r && (r |= 16 & n),
        t = e.entangledLanes,
        t !== 0)
        for (e = e.entanglements,
            t &= r; 0 < t;)
            n = 31 - Bn(t),
                i = 1 << n,
                r |= e[n],
                t &= ~i;
    return r
}
function eO(e, t) {
    switch (e) {
        case 1:
        case 2:
        case 4:
            return t + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}
function tO(e, t) {
    for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
        var s = 31 - Bn(o)
            , a = 1 << s
            , l = i[s];
        l === -1 ? a & n && !(a & r) || (i[s] = eO(a, t)) : l <= t && (e.expiredLanes |= a),
            o &= ~a
    }
}
function Nh(e) {
    return e = -1073741825 & e.pendingLanes,
        e !== 0 ? e : 1073741824 & e ? 1073741824 : 0
}
function fw() {
    var e = Yl;
    return Yl <<= 1,
        !(4194240 & Yl) && (Yl = 64),
        e
}
function ah(e) {
    for (var t = [], n = 0; 31 > n; n++)
        t.push(e);
    return t
}
function Ca(e, t, n) {
    e.pendingLanes |= t,
        t !== 536870912 && (e.suspendedLanes = 0,
            e.pingedLanes = 0),
        e = e.eventTimes,
        t = 31 - Bn(t),
        e[t] = n
}
function nO(e, t) {
    var n = e.pendingLanes & ~t;
    e.pendingLanes = t,
        e.suspendedLanes = 0,
        e.pingedLanes = 0,
        e.expiredLanes &= t,
        e.mutableReadLanes &= t,
        e.entangledLanes &= t,
        t = e.entanglements;
    var r = e.eventTimes;
    for (e = e.expirationTimes; 0 < n;) {
        var i = 31 - Bn(n)
            , o = 1 << i;
        t[i] = 0,
            r[i] = -1,
            e[i] = -1,
            n &= ~o
    }
}
function Cp(e, t) {
    var n = e.entangledLanes |= t;
    for (e = e.entanglements; n;) {
        var r = 31 - Bn(n)
            , i = 1 << r;
        i & t | e[r] & t && (e[r] |= t),
            n &= ~i
    }
}
var Te = 0;
function dw(e) {
    return e &= -e,
        1 < e ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1
}
var hw, Tp, pw, mw, gw, jh = !1, Ql = [], ti = null, ni = null, ri = null, ua = new Map, fa = new Map, Qr = [], rO = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Ub(e, t) {
    switch (e) {
        case "focusin":
        case "focusout":
            ti = null;
            break;
        case "dragenter":
        case "dragleave":
            ni = null;
            break;
        case "mouseover":
        case "mouseout":
            ri = null;
            break;
        case "pointerover":
        case "pointerout":
            ua.delete(t.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            fa.delete(t.pointerId)
    }
}
function Ns(e, t, n, r, i, o) {
    return e === null || e.nativeEvent !== o ? (e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i]
    },
        t !== null && (t = Ra(t),
            t !== null && Tp(t)),
        e) : (e.eventSystemFlags |= r,
            t = e.targetContainers,
            i !== null && t.indexOf(i) === -1 && t.push(i),
            e)
}
function iO(e, t, n, r, i) {
    switch (t) {
        case "focusin":
            return ti = Ns(ti, e, t, n, r, i),
                !0;
        case "dragenter":
            return ni = Ns(ni, e, t, n, r, i),
                !0;
        case "mouseover":
            return ri = Ns(ri, e, t, n, r, i),
                !0;
        case "pointerover":
            var o = i.pointerId;
            return ua.set(o, Ns(ua.get(o) || null, e, t, n, r, i)),
                !0;
        case "gotpointercapture":
            return o = i.pointerId,
                fa.set(o, Ns(fa.get(o) || null, e, t, n, r, i)),
                !0
    }
    return !1
}
function vw(e) {
    var t = Oi(e.target);
    if (t !== null) {
        var n = Hi(t);
        if (n !== null) {
            if (t = n.tag,
                t === 13) {
                if (t = ow(n),
                    t !== null) {
                    e.blockedOn = t,
                        gw(e.priority, function () {
                            pw(n)
                        });
                    return
                }
            } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}
function fc(e) {
    if (e.blockedOn !== null)
        return !1;
    for (var t = e.targetContainers; 0 < t.length;) {
        var n = Hh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (n !== null)
            return t = Ra(n),
                t !== null && Tp(t),
                e.blockedOn = n,
                !1;
        n = e.nativeEvent;
        var r = new n.constructor(n.type, n);
        Dh = r,
            n.target.dispatchEvent(r),
            Dh = null,
            t.shift()
    }
    return !0
}
function Gb(e, t, n) {
    fc(e) && n.delete(t)
}
function oO() {
    jh = !1,
        ti !== null && fc(ti) && (ti = null),
        ni !== null && fc(ni) && (ni = null),
        ri !== null && fc(ri) && (ri = null),
        ua.forEach(Gb),
        fa.forEach(Gb)
}
function js(e, t) {
    e.blockedOn === t && (e.blockedOn = null,
        jh || (jh = !0,
            an.unstable_scheduleCallback(an.unstable_NormalPriority, oO)))
}
function da(e) {
    function t(i) {
        return js(i, e)
    }
    if (0 < Ql.length) {
        js(Ql[0], e);
        for (var n = 1; n < Ql.length; n++) {
            var r = Ql[n];
            r.blockedOn === e && (r.blockedOn = null)
        }
    }
    for (ti !== null && js(ti, e),
        ni !== null && js(ni, e),
        ri !== null && js(ri, e),
        ua.forEach(t),
        fa.forEach(t),
        n = 0; n < Qr.length; n++)
        r = Qr[n],
            r.blockedOn === e && (r.blockedOn = null);
    for (; 0 < Qr.length && (n = Qr[0],
        n.blockedOn === null);)
        vw(n),
            n.blockedOn === null && Qr.shift()
}
var Bo = Vr.ReactCurrentBatchConfig
    , Rc = !0;
function sO(e, t, n, r) {
    var i = Te
        , o = Bo.transition;
    Bo.transition = null;
    try {
        Te = 1,
            Rp(e, t, n, r)
    } finally {
        Te = i,
            Bo.transition = o
    }
}
function aO(e, t, n, r) {
    var i = Te
        , o = Bo.transition;
    Bo.transition = null;
    try {
        Te = 4,
            Rp(e, t, n, r)
    } finally {
        Te = i,
            Bo.transition = o
    }
}
function Rp(e, t, n, r) {
    if (Rc) {
        var i = Hh(e, t, n, r);
        if (i === null)
            ph(e, t, r, Ec, n),
                Ub(e, r);
        else if (iO(i, e, t, n, r))
            r.stopPropagation();
        else if (Ub(e, r),
            4 & t && -1 < rO.indexOf(e)) {
            for (; i !== null;) {
                var o = Ra(i);
                if (o !== null && hw(o),
                    o = Hh(e, t, n, r),
                    o === null && ph(e, t, r, Ec, n),
                    o === i)
                    break;
                i = o
            }
            i !== null && r.stopPropagation()
        } else
            ph(e, t, r, null, n)
    }
}
var Ec = null;
function Hh(e, t, n, r) {
    if (Ec = null,
        e = Sp(r),
        e = Oi(e),
        e !== null)
        if (t = Hi(e),
            t === null)
            e = null;
        else if (n = t.tag,
            n === 13) {
            if (e = ow(t),
                e !== null)
                return e;
            e = null
        } else if (n === 3) {
            if (t.stateNode.current.memoizedState.isDehydrated)
                return t.tag === 3 ? t.stateNode.containerInfo : null;
            e = null
        } else
            t !== e && (e = null);
    return Ec = e,
        null
}
function yw(e) {
    switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (X2()) {
                case kp:
                    return 1;
                case cw:
                    return 4;
                case Cc:
                case Y2:
                    return 16;
                case uw:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var Jr = null
    , Ep = null
    , dc = null;
function bw() {
    if (dc)
        return dc;
    var e, t, n = Ep, r = n.length, i = "value" in Jr ? Jr.value : Jr.textContent, o = i.length;
    for (e = 0; e < r && n[e] === i[e]; e++)
        ;
    var s = r - e;
    for (t = 1; t <= s && n[r - t] === i[o - t]; t++)
        ;
    return dc = i.slice(e, 1 < t ? 1 - t : void 0)
}
function hc(e) {
    var t = e.keyCode;
    return "charCode" in e ? (e = e.charCode,
        e === 0 && t === 13 && (e = 13)) : e = t,
        e === 10 && (e = 13),
        32 <= e || e === 13 ? e : 0
}
function Zl() {
    return !0
}
function qb() {
    return !1
}
function cn(e) {
    function t(n, r, i, o, s) {
        this._reactName = n,
            this._targetInst = i,
            this.type = r,
            this.nativeEvent = o,
            this.target = s,
            this.currentTarget = null;
        for (var a in e)
            e.hasOwnProperty(a) && (n = e[a],
                this[a] = n ? n(o) : o[a]);
        return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Zl : qb,
            this.isPropagationStopped = qb,
            this
    }
    return Ue(t.prototype, {
        preventDefault: function () {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
                this.isDefaultPrevented = Zl)
        },
        stopPropagation: function () {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
                this.isPropagationStopped = Zl)
        },
        persist: function () { },
        isPersistent: Zl
    }),
        t
}
var lh, ch, Hs, Yo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
        return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, Fp = cn(Yo), Ta = Ue({}, Yo, {
    view: 0,
    detail: 0
}), lO = cn(Ta), Gc = Ue({}, Ta, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Pp,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function (e) {
        return "movementX" in e ? e.movementX : (e !== Hs && (Hs && e.type === "mousemove" ? (lh = e.screenX - Hs.screenX,
            ch = e.screenY - Hs.screenY) : ch = lh = 0,
            Hs = e),
            lh)
    },
    movementY: function (e) {
        return "movementY" in e ? e.movementY : ch
    }
}), Xb = cn(Gc), cO = Ue({}, Gc, {
    dataTransfer: 0
}), uO = cn(cO), fO = Ue({}, Ta, {
    relatedTarget: 0
}), uh = cn(fO), dO = Ue({}, Yo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), hO = cn(dO), pO = Ue({}, Yo, {
    clipboardData: function (e) {
        return "clipboardData" in e ? e.clipboardData : I.clipboardData
    }
}), mO = cn(pO), gO = Ue({}, Yo, {
    data: 0
}), Yb = cn(gO), vO = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, yO = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, bO = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function xO(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : !!(e = bO[e]) && !!t[e]
}
function Pp() {
    return xO
}
var wO = Ue({}, Ta, {
    key: function (e) {
        if (e.key) {
            var t = vO[e.key] || e.key;
            if (t !== "Unidentified")
                return t
        }
        return e.type === "keypress" ? (e = hc(e),
            e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? yO[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Pp,
    charCode: function (e) {
        return e.type === "keypress" ? hc(e) : 0
    },
    keyCode: function (e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function (e) {
        return e.type === "keypress" ? hc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
})
    , SO = cn(wO)
    , kO = Ue({}, Gc, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
    , Kb = cn(kO)
    , CO = Ue({}, Ta, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Pp
    })
    , TO = cn(CO)
    , RO = Ue({}, Yo, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
    , EO = cn(RO)
    , FO = Ue({}, Gc, {
        deltaX: function (e) {
            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        },
        deltaY: function (e) {
            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
    , PO = cn(FO)
    , _O = [9, 13, 27, 32]
    , _p = Ir && "CompositionEvent" in I
    , ea = null;
Ir && "documentMode" in document && (ea = document.documentMode);
var IO = Ir && "TextEvent" in I && !ea
    , xw = Ir && (!_p || ea && 8 < ea && 11 >= ea)
    , Qb = String.fromCharCode(32)
    , Zb = !1;
function ww(e, t) {
    switch (e) {
        case "keyup":
            return _O.indexOf(t.keyCode) !== -1;
        case "keydown":
            return t.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}
function Sw(e) {
    return e = e.detail,
        typeof e == "object" && "data" in e ? e.data : null
}
var Ro = !1;
function OO(e, t) {
    switch (e) {
        case "compositionend":
            return Sw(t);
        case "keypress":
            return t.which !== 32 ? null : (Zb = !0,
                Qb);
        case "textInput":
            return e = t.data,
                e === Qb && Zb ? null : e;
        default:
            return null
    }
}
function MO(e, t) {
    if (Ro)
        return e === "compositionend" || !_p && ww(e, t) ? (e = bw(),
            dc = Ep = Jr = null,
            Ro = !1,
            e) : null;
    switch (e) {
        case "paste":
            return null;
        case "keypress":
            if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                if (t.char && 1 < t.char.length)
                    return t.char;
                if (t.which)
                    return String.fromCharCode(t.which)
            }
            return null;
        case "compositionend":
            return xw && t.locale !== "ko" ? null : t.data;
        default:
            return null
    }
}
var LO = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Jb(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!LO[e.type] : t === "textarea"
}
function kw(e, t, n, r) {
    ew(r),
        t = Fc(t, "onChange"),
        0 < t.length && (n = new Fp("onChange", "change", null, n, r),
            e.push({
                event: n,
                listeners: t
            }))
}
var ta = null
    , ha = null;
function VO(e) {
    Lw(e, 0)
}
function qc(e) {
    var t = Po(e);
    if (qx(t))
        return e
}
function AO(e, t) {
    if (e === "change")
        return t
}
var Cw = !1;
Ir && (Ir ? (ec = "oninput" in document,
    ec || (fh = document.createElement("div"),
        fh.setAttribute("oninput", "return;"),
        ec = typeof fh.oninput == "function"),
    Jl = ec) : Jl = !1,
    Cw = Jl && (!document.documentMode || 9 < document.documentMode));
var Jl, ec, fh;
function ex() {
    ta && (ta.detachEvent("onpropertychange", Tw),
        ha = ta = null)
}
function Tw(e) {
    if (e.propertyName === "value" && qc(ha)) {
        var t = [];
        kw(t, ha, e, Sp(e)),
            iw(VO, t)
    }
}
function DO(e, t, n) {
    e === "focusin" ? (ex(),
        ta = t,
        ha = n,
        ta.attachEvent("onpropertychange", Tw)) : e === "focusout" && ex()
}
function zO(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return qc(ha)
}
function BO(e, t) {
    if (e === "click")
        return qc(t)
}
function $O(e, t) {
    if (e === "input" || e === "change")
        return qc(t)
}
function NO(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var Nn = typeof Object.is == "function" ? Object.is : NO;
function pa(e, t) {
    if (Nn(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    var n = Object.keys(e)
        , r = Object.keys(t);
    if (n.length !== r.length)
        return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!Th.call(t, i) || !Nn(e[i], t[i]))
            return !1
    }
    return !0
}
function tx(e) {
    for (; e && e.firstChild;)
        e = e.firstChild;
    return e
}
function nx(e, t) {
    var n = tx(e);
    e = 0;
    for (var r; n;) {
        if (n.nodeType === 3) {
            if (r = e + n.textContent.length,
                e <= t && r >= t)
                return {
                    node: n,
                    offset: t - e
                };
            e = r
        }
        e: {
            for (; n;) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = tx(n)
    }
}
function Rw(e, t) {
    return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? Rw(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
}
function Ew() {
    for (var e = I, t = wc(); t instanceof e.HTMLIFrameElement;) {
        try {
            var n = typeof t.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (!n)
            break;
        e = t.contentWindow,
            t = wc(e.document)
    }
    return t
}
function Ip(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function jO(e) {
    var t = Ew()
        , n = e.focusedElem
        , r = e.selectionRange;
    if (t !== n && n && n.ownerDocument && Rw(n.ownerDocument.documentElement, n)) {
        if (r !== null && Ip(n)) {
            if (t = r.start,
                e = r.end,
                e === void 0 && (e = t),
                "selectionStart" in n)
                n.selectionStart = t,
                    n.selectionEnd = Math.min(e, n.value.length);
            else if (e = (t = n.ownerDocument || document) && t.defaultView || I,
                e.getSelection) {
                e = e.getSelection();
                var i = n.textContent.length
                    , o = Math.min(r.start, i);
                r = r.end === void 0 ? o : Math.min(r.end, i),
                    !e.extend && o > r && (i = r,
                        r = o,
                        o = i),
                    i = nx(n, o);
                var s = nx(n, r);
                i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(),
                    t.setStart(i.node, i.offset),
                    e.removeAllRanges(),
                    o > r ? (e.addRange(t),
                        e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset),
                            e.addRange(t)))
            }
        }
        for (t = [],
            e = n; e = e.parentNode;)
            e.nodeType === 1 && t.push({
                element: e,
                left: e.scrollLeft,
                top: e.scrollTop
            });
        for (typeof n.focus == "function" && n.focus(),
            n = 0; n < t.length; n++)
            e = t[n],
                e.element.scrollLeft = e.left,
                e.element.scrollTop = e.top
    }
}
var HO = Ir && "documentMode" in document && 11 >= document.documentMode
    , Eo = null
    , Wh = null
    , na = null
    , Uh = !1;
function rx(e, t, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    Uh || Eo == null || Eo !== wc(r) || (r = Eo,
        "selectionStart" in r && Ip(r) ? r = {
            start: r.selectionStart,
            end: r.selectionEnd
        } : (r = (r.ownerDocument && r.ownerDocument.defaultView || I).getSelection(),
            r = {
                anchorNode: r.anchorNode,
                anchorOffset: r.anchorOffset,
                focusNode: r.focusNode,
                focusOffset: r.focusOffset
            }),
        na && pa(na, r) || (na = r,
            r = Fc(Wh, "onSelect"),
            0 < r.length && (t = new Fp("onSelect", "select", null, t, n),
                e.push({
                    event: t,
                    listeners: r
                }),
                t.target = Eo)))
}
function tc(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(),
        n["Webkit" + e] = "webkit" + t,
        n["Moz" + e] = "moz" + t,
        n
}
var Fo = {
    animationend: tc("Animation", "AnimationEnd"),
    animationiteration: tc("Animation", "AnimationIteration"),
    animationstart: tc("Animation", "AnimationStart"),
    transitionend: tc("Transition", "TransitionEnd")
}
    , dh = {}
    , Fw = {};
Ir && (Fw = document.createElement("div").style,
    "AnimationEvent" in I || (delete Fo.animationend.animation,
        delete Fo.animationiteration.animation,
        delete Fo.animationstart.animation),
    "TransitionEvent" in I || delete Fo.transitionend.transition);
function Xc(e) {
    if (dh[e])
        return dh[e];
    if (!Fo[e])
        return e;
    var t, n = Fo[e];
    for (t in n)
        if (n.hasOwnProperty(t) && t in Fw)
            return dh[e] = n[t];
    return e
}
var Pw = Xc("animationend")
    , _w = Xc("animationiteration")
    , Iw = Xc("animationstart")
    , Ow = Xc("transitionend")
    , Mw = new Map
    , ix = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function fi(e, t) {
    Mw.set(e, t),
        ji(t, [e])
}
for (nc = 0; nc < ix.length; nc++)
    rc = ix[nc],
        ox = rc.toLowerCase(),
        sx = rc[0].toUpperCase() + rc.slice(1),
        fi(ox, "on" + sx);
var rc, ox, sx, nc;
fi(Pw, "onAnimationEnd");
fi(_w, "onAnimationIteration");
fi(Iw, "onAnimationStart");
fi("dblclick", "onDoubleClick");
fi("focusin", "onFocus");
fi("focusout", "onBlur");
fi(Ow, "onTransitionEnd");
jo("onMouseEnter", ["mouseout", "mouseover"]);
jo("onMouseLeave", ["mouseout", "mouseover"]);
jo("onPointerEnter", ["pointerout", "pointerover"]);
jo("onPointerLeave", ["pointerout", "pointerover"]);
ji("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
ji("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
ji("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ji("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
ji("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
ji("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Qs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
    , WO = new Set("cancel close invalid load scroll toggle".split(" ").concat(Qs));
function ax(e, t, n) {
    var r = e.type || "unknown-event";
    e.currentTarget = n,
        W2(r, t, void 0, e),
        e.currentTarget = null
}
function Lw(e, t) {
    t = (4 & t) !== 0;
    for (var n = 0; n < e.length; n++) {
        var r = e[n]
            , i = r.event;
        r = r.listeners;
        e: {
            var o = void 0;
            if (t)
                for (var s = r.length - 1; 0 <= s; s--) {
                    var a = r[s]
                        , l = a.instance
                        , c = a.currentTarget;
                    if (a = a.listener,
                        l !== o && i.isPropagationStopped())
                        break e;
                    ax(i, a, c),
                        o = l
                }
            else
                for (s = 0; s < r.length; s++) {
                    if (a = r[s],
                        l = a.instance,
                        c = a.currentTarget,
                        a = a.listener,
                        l !== o && i.isPropagationStopped())
                        break e;
                    ax(i, a, c),
                        o = l
                }
        }
    }
    if (kc)
        throw e = $h,
        kc = !1,
        $h = null,
        e
}
function Ve(e, t) {
    var n = t[Kh];
    n === void 0 && (n = t[Kh] = new Set);
    var r = e + "__bubble";
    n.has(r) || (Vw(t, e, 2, !1),
        n.add(r))
}
function hh(e, t, n) {
    var r = 0;
    t && (r |= 4),
        Vw(n, e, r, t)
}
var ic = "_reactListening" + Math.random().toString(36).slice(2);
function ma(e) {
    if (!e[ic]) {
        e[ic] = !0,
            jx.forEach(function (n) {
                n !== "selectionchange" && (WO.has(n) || hh(n, !1, e),
                    hh(n, !0, e))
            });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[ic] || (t[ic] = !0,
            hh("selectionchange", !1, t))
    }
}
function Vw(e, t, n, r) {
    switch (yw(t)) {
        case 1:
            var i = sO;
            break;
        case 4:
            i = aO;
            break;
        default:
            i = Rp
    }
    n = i.bind(null, t, n, e),
        i = void 0,
        !Bh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0),
        r ? i !== void 0 ? e.addEventListener(t, n, {
            capture: !0,
            passive: i
        }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, {
            passive: i
        }) : e.addEventListener(t, n, !1)
}
function ph(e, t, n, r, i) {
    var o = r;
    if (!(1 & t) && !(2 & t) && r !== null)
        e: for (; ;) {
            if (r === null)
                return;
            var s = r.tag;
            if (s === 3 || s === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                    break;
                if (s === 4)
                    for (s = r.return; s !== null;) {
                        var l = s.tag;
                        if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo,
                            l === i || l.nodeType === 8 && l.parentNode === i))
                            return;
                        s = s.return
                    }
                for (; a !== null;) {
                    if (s = Oi(a),
                        s === null)
                        return;
                    if (l = s.tag,
                        l === 5 || l === 6) {
                        r = o = s;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            r = r.return
        }
    iw(function () {
        var c = o
            , u = Sp(n)
            , f = [];
        e: {
            var d = Mw.get(e);
            if (d !== void 0) {
                var p = Fp
                    , v = e;
                switch (e) {
                    case "keypress":
                        if (hc(n) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        p = SO;
                        break;
                    case "focusin":
                        v = "focus",
                            p = uh;
                        break;
                    case "focusout":
                        v = "blur",
                            p = uh;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        p = uh;
                        break;
                    case "click":
                        if (n.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        p = Xb;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        p = uO;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        p = TO;
                        break;
                    case Pw:
                    case _w:
                    case Iw:
                        p = hO;
                        break;
                    case Ow:
                        p = EO;
                        break;
                    case "scroll":
                        p = lO;
                        break;
                    case "wheel":
                        p = PO;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        p = mO;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        p = Kb
                }
                var g = (4 & t) !== 0
                    , b = !g && e === "scroll"
                    , m = g ? d !== null ? d + "Capture" : null : d;
                g = [];
                for (var h, y = c; y !== null;) {
                    h = y;
                    var w = h.stateNode;
                    if (h.tag === 5 && w !== null && (h = w,
                        m !== null && (w = ca(y, m),
                            w != null && g.push(ga(y, w, h)))),
                        b)
                        break;
                    y = y.return
                }
                0 < g.length && (d = new p(d, v, null, n, u),
                    f.push({
                        event: d,
                        listeners: g
                    }))
            }
        }
        if (!(7 & t)) {
            if (d = e === "mouseover" || e === "pointerover",
                p = e === "mouseout" || e === "pointerout",
                (!d || n === Dh || !(v = n.relatedTarget || n.fromElement) || !Oi(v) && !v[Or]) && (p || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : I,
                    p ? (v = n.relatedTarget || n.toElement,
                        p = c,
                        v = v ? Oi(v) : null,
                        v !== null && (b = Hi(v),
                            v !== b || v.tag !== 5 && v.tag !== 6) && (v = null)) : (p = null,
                                v = c),
                    p !== v)) {
                if (g = Xb,
                    w = "onMouseLeave",
                    m = "onMouseEnter",
                    y = "mouse",
                    e !== "pointerout" && e !== "pointerover" || (g = Kb,
                        w = "onPointerLeave",
                        m = "onPointerEnter",
                        y = "pointer"),
                    b = p == null ? d : Po(p),
                    h = v == null ? d : Po(v),
                    d = new g(w, y + "leave", p, n, u),
                    d.target = b,
                    d.relatedTarget = h,
                    w = null,
                    Oi(u) === c && (g = new g(m, y + "enter", v, n, u),
                        g.target = h,
                        g.relatedTarget = b,
                        w = g),
                    b = w,
                    p && v)
                    e: {
                        for (g = p,
                            m = v,
                            y = 0,
                            h = g; h; h = ko(h))
                            y++;
                        for (h = 0,
                            w = m; w; w = ko(w))
                            h++;
                        for (; 0 < y - h;)
                            g = ko(g),
                                y--;
                        for (; 0 < h - y;)
                            m = ko(m),
                                h--;
                        for (; y--;) {
                            if (g === m || m !== null && g === m.alternate)
                                break e;
                            g = ko(g),
                                m = ko(m)
                        }
                        g = null
                    }
                else
                    g = null;
                p !== null && lx(f, d, p, g, !1),
                    v !== null && b !== null && lx(f, b, v, g, !0)
            }
            if (d = c ? Po(c) : I,
                p = d.nodeName && d.nodeName.toLowerCase(),
                p === "select" || p === "input" && d.type === "file")
                var C = AO;
            else if (Jb(d))
                if (Cw)
                    C = $O;
                else {
                    C = zO;
                    var S = DO
                }
            else
                (p = d.nodeName) && p.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (C = BO);
            switch (C && (C = C(e, c)) ? kw(f, C, n, u) : (S && S(e, d, c),
                e === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && Oh(d, "number", d.value)),
            S = c ? Po(c) : I,
            e) {
                case "focusin":
                    (Jb(S) || S.contentEditable === "true") && (Eo = S,
                        Wh = c,
                        na = null);
                    break;
                case "focusout":
                    na = Wh = Eo = null;
                    break;
                case "mousedown":
                    Uh = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Uh = !1,
                        rx(f, n, u);
                    break;
                case "selectionchange":
                    if (HO)
                        break;
                case "keydown":
                case "keyup":
                    rx(f, n, u)
            }
            var T;
            if (_p)
                e: {
                    switch (e) {
                        case "compositionstart":
                            var R = "onCompositionStart";
                            break e;
                        case "compositionend":
                            R = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            R = "onCompositionUpdate";
                            break e
                    }
                    R = void 0
                }
            else
                Ro ? ww(e, n) && (R = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (R = "onCompositionStart");
            R && (xw && n.locale !== "ko" && (Ro || R !== "onCompositionStart" ? R === "onCompositionEnd" && Ro && (T = bw()) : (Jr = u,
                Ep = "value" in Jr ? Jr.value : Jr.textContent,
                Ro = !0)),
                S = Fc(c, R),
                0 < S.length && (R = new Yb(R, e, null, n, u),
                    f.push({
                        event: R,
                        listeners: S
                    }),
                    T ? R.data = T : (T = Sw(n),
                        T !== null && (R.data = T)))),
                (T = IO ? OO(e, n) : MO(e, n)) && (c = Fc(c, "onBeforeInput"),
                    0 < c.length && (u = new Yb("onBeforeInput", "beforeinput", null, n, u),
                        f.push({
                            event: u,
                            listeners: c
                        }),
                        u.data = T))
        }
        Lw(f, t)
    })
}
function ga(e, t, n) {
    return {
        instance: e,
        listener: t,
        currentTarget: n
    }
}
function Fc(e, t) {
    for (var n = t + "Capture", r = []; e !== null;) {
        var i = e
            , o = i.stateNode;
        i.tag === 5 && o !== null && (i = o,
            o = ca(e, n),
            o != null && r.unshift(ga(e, o, i)),
            o = ca(e, t),
            o != null && r.push(ga(e, o, i))),
            e = e.return
    }
    return r
}
function ko(e) {
    if (e === null)
        return null;
    do
        e = e.return;
    while (e && e.tag !== 5);
    return e || null
}
function lx(e, t, n, r, i) {
    for (var o = t._reactName, s = []; n !== null && n !== r;) {
        var a = n
            , l = a.alternate
            , c = a.stateNode;
        if (l !== null && l === r)
            break;
        a.tag === 5 && c !== null && (a = c,
            i ? (l = ca(n, o),
                l != null && s.unshift(ga(n, l, a))) : i || (l = ca(n, o),
                    l != null && s.push(ga(n, l, a)))),
            n = n.return
    }
    s.length !== 0 && e.push({
        event: t,
        listeners: s
    })
}
var UO = /\r\n?/g
    , GO = /\u0000|\uFFFD/g;
function cx(e) {
    return (typeof e == "string" ? e : "" + e).replace(UO, `
`).replace(GO, "")
}
function oc(e, t, n) {
    if (t = cx(t),
        cx(e) !== t && n)
        throw Error(M(425))
}
function Pc() { }
var Gh = null
    , qh = null;
function Xh(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var Yh = typeof setTimeout == "function" ? setTimeout : void 0
    , qO = typeof clearTimeout == "function" ? clearTimeout : void 0
    , ux = typeof Promise == "function" ? Promise : void 0
    , XO = typeof queueMicrotask == "function" ? queueMicrotask : typeof ux < "u" ? function (e) {
        return ux.resolve(null).then(e).catch(YO)
    }
        : Yh;
function YO(e) {
    setTimeout(function () {
        throw e
    })
}
function mh(e, t) {
    var n = t
        , r = 0;
    do {
        var i = n.nextSibling;
        if (e.removeChild(n),
            i && i.nodeType === 8)
            if (n = i.data,
                n === "/$") {
                if (r === 0) {
                    e.removeChild(i),
                        da(t);
                    return
                }
                r--
            } else
                n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    da(t)
}
function ii(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3)
            break;
        if (t === 8) {
            if (t = e.data,
                t === "$" || t === "$!" || t === "$?")
                break;
            if (t === "/$")
                return null
        }
    }
    return e
}
function fx(e) {
    e = e.previousSibling;
    for (var t = 0; e;) {
        if (e.nodeType === 8) {
            var n = e.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (t === 0)
                    return e;
                t--
            } else
                n === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var Ko = Math.random().toString(36).slice(2)
    , ar = "__reactFiber$" + Ko
    , va = "__reactProps$" + Ko
    , Or = "__reactContainer$" + Ko
    , Kh = "__reactEvents$" + Ko
    , KO = "__reactListeners$" + Ko
    , QO = "__reactHandles$" + Ko;
function Oi(e) {
    var t = e[ar];
    if (t)
        return t;
    for (var n = e.parentNode; n;) {
        if (t = n[Or] || n[ar]) {
            if (n = t.alternate,
                t.child !== null || n !== null && n.child !== null)
                for (e = fx(e); e !== null;) {
                    if (n = e[ar])
                        return n;
                    e = fx(e)
                }
            return t
        }
        e = n,
            n = e.parentNode
    }
    return null
}
function Ra(e) {
    return e = e[ar] || e[Or],
        !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function Po(e) {
    if (e.tag === 5 || e.tag === 6)
        return e.stateNode;
    throw Error(M(33))
}
function Yc(e) {
    return e[va] || null
}
var Qh = []
    , _o = -1;
function di(e) {
    return {
        current: e
    }
}
function Ae(e) {
    0 > _o || (e.current = Qh[_o],
        Qh[_o] = null,
        _o--)
}
function Oe(e, t) {
    _o++,
        Qh[_o] = e.current,
        e.current = t
}
var ui = {}
    , Mt = di(ui)
    , Xt = di(!1)
    , Di = ui;
function Ho(e, t) {
    var n = e.type.contextTypes;
    if (!n)
        return ui;
    var r = e.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
        return r.__reactInternalMemoizedMaskedChildContext;
    var i, o = {};
    for (i in n)
        o[i] = t[i];
    return r && (e = e.stateNode,
        e.__reactInternalMemoizedUnmaskedChildContext = t,
        e.__reactInternalMemoizedMaskedChildContext = o),
        o
}
function Yt(e) {
    return e = e.childContextTypes,
        e != null
}
function _c() {
    Ae(Xt),
        Ae(Mt)
}
function dx(e, t, n) {
    if (Mt.current !== ui)
        throw Error(M(168));
    Oe(Mt, t),
        Oe(Xt, n)
}
function Aw(e, t, n) {
    var r = e.stateNode;
    if (t = t.childContextTypes,
        typeof r.getChildContext != "function")
        return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in t))
            throw Error(M(108, D2(e) || "Unknown", i));
    return Ue({}, n, r)
}
function Ic(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ui,
        Di = Mt.current,
        Oe(Mt, e),
        Oe(Xt, Xt.current),
        !0
}
function hx(e, t, n) {
    var r = e.stateNode;
    if (!r)
        throw Error(M(169));
    n ? (e = Aw(e, t, Di),
        r.__reactInternalMemoizedMergedChildContext = e,
        Ae(Xt),
        Ae(Mt),
        Oe(Mt, e)) : Ae(Xt),
        Oe(Xt, n)
}
var Er = null
    , Kc = !1
    , gh = !1;
function Dw(e) {
    Er === null ? Er = [e] : Er.push(e)
}
function ZO(e) {
    Kc = !0,
        Dw(e)
}
function hi() {
    if (!gh && Er !== null) {
        gh = !0;
        var e = 0
            , t = Te;
        try {
            var n = Er;
            for (Te = 1; e < n.length; e++) {
                var r = n[e];
                do
                    r = r(!0);
                while (r !== null)
            }
            Er = null,
                Kc = !1
        } catch (i) {
            throw Er !== null && (Er = Er.slice(e + 1)),
            lw(kp, hi),
            i
        } finally {
            Te = t,
                gh = !1
        }
    }
    return null
}
var Io = []
    , Oo = 0
    , Oc = null
    , Mc = 0
    , kn = []
    , Cn = 0
    , zi = null
    , Fr = 1
    , Pr = "";
function _i(e, t) {
    Io[Oo++] = Mc,
        Io[Oo++] = Oc,
        Oc = e,
        Mc = t
}
function zw(e, t, n) {
    kn[Cn++] = Fr,
        kn[Cn++] = Pr,
        kn[Cn++] = zi,
        zi = e;
    var r = Fr;
    e = Pr;
    var i = 32 - Bn(r) - 1;
    r &= ~(1 << i),
        n += 1;
    var o = 32 - Bn(t) + i;
    if (30 < o) {
        var s = i - i % 5;
        o = (r & (1 << s) - 1).toString(32),
            r >>= s,
            i -= s,
            Fr = 1 << 32 - Bn(t) + i | n << i | r,
            Pr = o + e
    } else
        Fr = 1 << o | n << i | r,
            Pr = e
}
function Op(e) {
    e.return !== null && (_i(e, 1),
        zw(e, 1, 0))
}
function Mp(e) {
    for (; e === Oc;)
        Oc = Io[--Oo],
            Io[Oo] = null,
            Mc = Io[--Oo],
            Io[Oo] = null;
    for (; e === zi;)
        zi = kn[--Cn],
            kn[Cn] = null,
            Pr = kn[--Cn],
            kn[Cn] = null,
            Fr = kn[--Cn],
            kn[Cn] = null
}
var sn = null
    , on = null
    , $e = !1
    , zn = null;
function Bw(e, t) {
    var n = Tn(5, null, null, 0);
    n.elementType = "DELETED",
        n.stateNode = t,
        n.return = e,
        t = e.deletions,
        t === null ? (e.deletions = [n],
            e.flags |= 16) : t.push(n)
}
function px(e, t) {
    switch (e.tag) {
        case 5:
            var n = e.type;
            return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
                t !== null && (e.stateNode = t,
                    sn = e,
                    on = ii(t.firstChild),
                    !0);
        case 6:
            return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
                t !== null && (e.stateNode = t,
                    sn = e,
                    on = null,
                    !0);
        case 13:
            return t = t.nodeType !== 8 ? null : t,
                t !== null && (n = zi !== null ? {
                    id: Fr,
                    overflow: Pr
                } : null,
                    e.memoizedState = {
                        dehydrated: t,
                        treeContext: n,
                        retryLane: 1073741824
                    },
                    n = Tn(18, null, null, 0),
                    n.stateNode = t,
                    n.return = e,
                    e.child = n,
                    sn = e,
                    on = null,
                    !0);
        default:
            return !1
    }
}
function Zh(e) {
    return (1 & e.mode) !== 0 && (128 & e.flags) === 0
}
function Jh(e) {
    if ($e) {
        var t = on;
        if (t) {
            var n = t;
            if (!px(e, t)) {
                if (Zh(e))
                    throw Error(M(418));
                t = ii(n.nextSibling);
                var r = sn;
                t && px(e, t) ? Bw(r, n) : (e.flags = -4097 & e.flags | 2,
                    $e = !1,
                    sn = e)
            }
        } else {
            if (Zh(e))
                throw Error(M(418));
            e.flags = -4097 & e.flags | 2,
                $e = !1,
                sn = e
        }
    }
}
function mx(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)
        e = e.return;
    sn = e
}
function sc(e) {
    if (e !== sn)
        return !1;
    if (!$e)
        return mx(e),
            $e = !0,
            !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
        t = t !== "head" && t !== "body" && !Xh(e.type, e.memoizedProps)),
        t && (t = on)) {
        if (Zh(e))
            throw $w(),
            Error(M(418));
        for (; t;)
            Bw(e, t),
                t = ii(t.nextSibling)
    }
    if (mx(e),
        e.tag === 13) {
        if (e = e.memoizedState,
            e = e !== null ? e.dehydrated : null,
            !e)
            throw Error(M(317));
        e: {
            for (e = e.nextSibling,
                t = 0; e;) {
                if (e.nodeType === 8) {
                    var n = e.data;
                    if (n === "/$") {
                        if (t === 0) {
                            on = ii(e.nextSibling);
                            break e
                        }
                        t--
                    } else
                        n !== "$" && n !== "$!" && n !== "$?" || t++
                }
                e = e.nextSibling
            }
            on = null
        }
    } else
        on = sn ? ii(e.stateNode.nextSibling) : null;
    return !0
}
function $w() {
    for (var e = on; e;)
        e = ii(e.nextSibling)
}
function Wo() {
    on = sn = null,
        $e = !1
}
function Lp(e) {
    zn === null ? zn = [e] : zn.push(e)
}
var JO = Vr.ReactCurrentBatchConfig;
function An(e, t) {
    if (e && e.defaultProps) {
        t = Ue({}, t),
            e = e.defaultProps;
        for (var n in e)
            t[n] === void 0 && (t[n] = e[n]);
        return t
    }
    return t
}
var Lc = di(null)
    , Vc = null
    , Mo = null
    , Vp = null;
function Ap() {
    Vp = Mo = Vc = null
}
function Dp(e) {
    var t = Lc.current;
    Ae(Lc),
        e._currentValue = t
}
function ep(e, t, n) {
    for (; e !== null;) {
        var r = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
            r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
            e === n)
            break;
        e = e.return
    }
}
function $o(e, t) {
    Vc = e,
        Vp = Mo = null,
        e = e.dependencies,
        e !== null && e.firstContext !== null && (e.lanes & t && (qt = !0),
            e.firstContext = null)
}
function En(e) {
    var t = e._currentValue;
    if (Vp !== e)
        if (e = {
            context: e,
            memoizedValue: t,
            next: null
        },
            Mo === null) {
            if (Vc === null)
                throw Error(M(308));
            Mo = e,
                Vc.dependencies = {
                    lanes: 0,
                    firstContext: e
                }
        } else
            Mo = Mo.next = e;
    return t
}
var Mi = null;
function zp(e) {
    Mi === null ? Mi = [e] : Mi.push(e)
}
function Nw(e, t, n, r) {
    var i = t.interleaved;
    return i === null ? (n.next = n,
        zp(t)) : (n.next = i.next,
            i.next = n),
        t.interleaved = n,
        Mr(e, r)
}
function Mr(e, t) {
    e.lanes |= t;
    var n = e.alternate;
    for (n !== null && (n.lanes |= t),
        n = e,
        e = e.return; e !== null;)
        e.childLanes |= t,
            n = e.alternate,
            n !== null && (n.childLanes |= t),
            n = e,
            e = e.return;
    return n.tag === 3 ? n.stateNode : null
}
var Kr = !1;
function Bp(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function jw(e, t) {
    e = e.updateQueue,
        t.updateQueue === e && (t.updateQueue = {
            baseState: e.baseState,
            firstBaseUpdate: e.firstBaseUpdate,
            lastBaseUpdate: e.lastBaseUpdate,
            shared: e.shared,
            effects: e.effects
        })
}
function _r(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function oi(e, t, n) {
    var r = e.updateQueue;
    if (r === null)
        return null;
    if (r = r.shared,
        2 & xe) {
        var i = r.pending;
        return i === null ? t.next = t : (t.next = i.next,
            i.next = t),
            r.pending = t,
            Mr(e, n)
    }
    return i = r.interleaved,
        i === null ? (t.next = t,
            zp(r)) : (t.next = i.next,
                i.next = t),
        r.interleaved = t,
        Mr(e, n)
}
function pc(e, t, n) {
    if (t = t.updateQueue,
        t !== null && (t = t.shared,
            (4194240 & n) !== 0)) {
        var r = t.lanes;
        r &= e.pendingLanes,
            n |= r,
            t.lanes = n,
            Cp(e, n)
    }
}
function gx(e, t) {
    var n = e.updateQueue
        , r = e.alternate;
    if (r === null || (r = r.updateQueue,
        n !== r))
        e = n.lastBaseUpdate,
            e === null ? n.firstBaseUpdate = t : e.next = t,
            n.lastBaseUpdate = t;
    else {
        var i = null
            , o = null;
        if (n = n.firstBaseUpdate,
            n !== null) {
            do {
                var s = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                o === null ? i = o = s : o = o.next = s,
                    n = n.next
            } while (n !== null);
            o === null ? i = o = t : o = o.next = t
        } else
            i = o = t;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: o,
            shared: r.shared,
            effects: r.effects
        },
            e.updateQueue = n
    }
}
function Ac(e, t, n, r) {
    var i = e.updateQueue;
    Kr = !1;
    var o = i.firstBaseUpdate
        , s = i.lastBaseUpdate
        , a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a
            , c = l.next;
        l.next = null,
            s === null ? o = c : s.next = c,
            s = l;
        var u = e.alternate;
        u !== null && (u = u.updateQueue,
            a = u.lastBaseUpdate,
            a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c,
                u.lastBaseUpdate = l))
    }
    if (o !== null) {
        var f = i.baseState;
        s = 0,
            u = c = l = null,
            a = o;
        do {
            var d = a.lane
                , p = a.eventTime;
            if ((r & d) === d) {
                u !== null && (u = u.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = e
                        , g = a;
                    switch (d = t,
                    p = n,
                    g.tag) {
                        case 1:
                            if (v = g.payload,
                                typeof v == "function") {
                                f = v.call(p, f, d);
                                break e
                            }
                            f = v;
                            break e;
                        case 3:
                            v.flags = -65537 & v.flags | 128;
                        case 0:
                            if (v = g.payload,
                                d = typeof v == "function" ? v.call(p, f, d) : v,
                                d == null)
                                break e;
                            f = Ue({}, f, d);
                            break e;
                        case 2:
                            Kr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (e.flags |= 64,
                    d = i.effects,
                    d === null ? i.effects = [a] : d.push(a))
            } else
                p = {
                    eventTime: p,
                    lane: d,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                    u === null ? (c = u = p,
                        l = f) : u = u.next = p,
                    s |= d;
            if (a = a.next,
                a === null) {
                if (a = i.shared.pending,
                    a === null)
                    break;
                d = a,
                    a = d.next,
                    d.next = null,
                    i.lastBaseUpdate = d,
                    i.shared.pending = null
            }
        } while (1);
        if (u === null && (l = f),
            i.baseState = l,
            i.firstBaseUpdate = c,
            i.lastBaseUpdate = u,
            t = i.shared.interleaved,
            t !== null) {
            i = t;
            do
                s |= i.lane,
                    i = i.next;
            while (i !== t)
        } else
            o === null && (i.shared.lanes = 0);
        $i |= s,
            e.lanes = s,
            e.memoizedState = f
    }
}
function vx(e, t, n) {
    if (e = t.effects,
        t.effects = null,
        e !== null)
        for (t = 0; t < e.length; t++) {
            var r = e[t]
                , i = r.callback;
            if (i !== null) {
                if (r.callback = null,
                    r = n,
                    typeof i != "function")
                    throw Error(M(191, i));
                i.call(r)
            }
        }
}
var Hw = new Nx.Component().refs;
function tp(e, t, n, r) {
    t = e.memoizedState,
        n = n(r, t),
        n = n == null ? t : Ue({}, t, n),
        e.memoizedState = n,
        e.lanes === 0 && (e.updateQueue.baseState = n)
}
var Qc = {
    isMounted: function (e) {
        return !!(e = e._reactInternals) && Hi(e) === e
    },
    enqueueSetState: function (e, t, n) {
        e = e._reactInternals;
        var r = Bt()
            , i = ai(e)
            , o = _r(r, i);
        o.payload = t,
            n != null && (o.callback = n),
            t = oi(e, o, i),
            t !== null && ($n(t, e, i, r),
                pc(t, e, i))
    },
    enqueueReplaceState: function (e, t, n) {
        e = e._reactInternals;
        var r = Bt()
            , i = ai(e)
            , o = _r(r, i);
        o.tag = 1,
            o.payload = t,
            n != null && (o.callback = n),
            t = oi(e, o, i),
            t !== null && ($n(t, e, i, r),
                pc(t, e, i))
    },
    enqueueForceUpdate: function (e, t) {
        e = e._reactInternals;
        var n = Bt()
            , r = ai(e)
            , i = _r(n, r);
        i.tag = 2,
            t != null && (i.callback = t),
            t = oi(e, i, r),
            t !== null && ($n(t, e, r, n),
                pc(t, e, r))
    }
};
function yx(e, t, n, r, i, o, s) {
    return e = e.stateNode,
        typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || !pa(n, r) || !pa(i, o)
}
function Ww(e, t, n) {
    var r = !1
        , i = ui
        , o = t.contextType;
    return typeof o == "object" && o !== null ? o = En(o) : (i = Yt(t) ? Di : Mt.current,
        r = t.contextTypes,
        o = (r = r != null) ? Ho(e, i) : ui),
        t = new t(n, o),
        e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
        t.updater = Qc,
        e.stateNode = t,
        t._reactInternals = e,
        r && (e = e.stateNode,
            e.__reactInternalMemoizedUnmaskedChildContext = i,
            e.__reactInternalMemoizedMaskedChildContext = o),
        t
}
function bx(e, t, n, r) {
    e = t.state,
        typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r),
        typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r),
        t.state !== e && Qc.enqueueReplaceState(t, t.state, null)
}
function np(e, t, n, r) {
    var i = e.stateNode;
    i.props = n,
        i.state = e.memoizedState,
        i.refs = Hw,
        Bp(e);
    var o = t.contextType;
    typeof o == "object" && o !== null ? i.context = En(o) : (o = Yt(t) ? Di : Mt.current,
        i.context = Ho(e, o)),
        i.state = e.memoizedState,
        o = t.getDerivedStateFromProps,
        typeof o == "function" && (tp(e, t, o, n),
            i.state = e.memoizedState),
        typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state,
            typeof i.componentWillMount == "function" && i.componentWillMount(),
            typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
            t !== i.state && Qc.enqueueReplaceState(i, i.state, null),
            Ac(e, n, i, r),
            i.state = e.memoizedState),
        typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}
function Ws(e, t, n) {
    if (e = n.ref,
        e !== null && typeof e != "function" && typeof e != "object") {
        if (n._owner) {
            if (n = n._owner,
                n) {
                if (n.tag !== 1)
                    throw Error(M(309));
                var r = n.stateNode
            }
            if (!r)
                throw Error(M(147, e));
            var i = r
                , o = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) {
                var a = i.refs;
                a === Hw && (a = i.refs = {}),
                    s === null ? delete a[o] : a[o] = s
            }
                ,
                t._stringRef = o,
                t)
        }
        if (typeof e != "string")
            throw Error(M(284));
        if (!n._owner)
            throw Error(M(290, e))
    }
    return e
}
function ac(e, t) {
    throw e = Object.prototype.toString.call(t),
    Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function xx(e) {
    var t = e._init;
    return t(e._payload)
}
function Uw(e) {
    function t(m, h) {
        if (e) {
            var y = m.deletions;
            y === null ? (m.deletions = [h],
                m.flags |= 16) : y.push(h)
        }
    }
    function n(m, h) {
        if (!e)
            return null;
        for (; h !== null;)
            t(m, h),
                h = h.sibling;
        return null
    }
    function r(m, h) {
        for (m = new Map; h !== null;)
            h.key !== null ? m.set(h.key, h) : m.set(h.index, h),
                h = h.sibling;
        return m
    }
    function i(m, h) {
        return m = li(m, h),
            m.index = 0,
            m.sibling = null,
            m
    }
    function o(m, h, y) {
        return m.index = y,
            e ? (y = m.alternate,
                y !== null ? (y = y.index,
                    y < h ? (m.flags |= 2,
                        h) : y) : (m.flags |= 2,
                            h)) : (m.flags |= 1048576,
                                h)
    }
    function s(m) {
        return e && m.alternate === null && (m.flags |= 2),
            m
    }
    function a(m, h, y, w) {
        return h === null || h.tag !== 6 ? (h = kh(y, m.mode, w),
            h.return = m,
            h) : (h = i(h, y),
                h.return = m,
                h)
    }
    function l(m, h, y, w) {
        var C = y.type;
        return C === To ? u(m, h, y.props.children, w, y.key) : h !== null && (h.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Yr && xx(C) === h.type) ? (w = i(h, y.props),
            w.ref = Ws(m, h, y),
            w.return = m,
            w) : (w = xc(y.type, y.key, y.props, null, m.mode, w),
                w.ref = Ws(m, h, y),
                w.return = m,
                w)
    }
    function c(m, h, y, w) {
        return h === null || h.tag !== 4 || h.stateNode.containerInfo !== y.containerInfo || h.stateNode.implementation !== y.implementation ? (h = Ch(y, m.mode, w),
            h.return = m,
            h) : (h = i(h, y.children || []),
                h.return = m,
                h)
    }
    function u(m, h, y, w, C) {
        return h === null || h.tag !== 7 ? (h = Ai(y, m.mode, w, C),
            h.return = m,
            h) : (h = i(h, y),
                h.return = m,
                h)
    }
    function f(m, h, y) {
        if (typeof h == "string" && h !== "" || typeof h == "number")
            return h = kh("" + h, m.mode, y),
                h.return = m,
                h;
        if (typeof h == "object" && h !== null) {
            switch (h.$$typeof) {
                case Gl:
                    return y = xc(h.type, h.key, h.props, null, m.mode, y),
                        y.ref = Ws(m, null, h),
                        y.return = m,
                        y;
                case Co:
                    return h = Ch(h, m.mode, y),
                        h.return = m,
                        h;
                case Yr:
                    var w = h._init;
                    return f(m, w(h._payload), y)
            }
            if (Ys(h) || $s(h))
                return h = Ai(h, m.mode, y, null),
                    h.return = m,
                    h;
            ac(m, h)
        }
        return null
    }
    function d(m, h, y, w) {
        var C = h !== null ? h.key : null;
        if (typeof y == "string" && y !== "" || typeof y == "number")
            return C !== null ? null : a(m, h, "" + y, w);
        if (typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
                case Gl:
                    return y.key === C ? l(m, h, y, w) : null;
                case Co:
                    return y.key === C ? c(m, h, y, w) : null;
                case Yr:
                    return C = y._init,
                        d(m, h, C(y._payload), w)
            }
            if (Ys(y) || $s(y))
                return C !== null ? null : u(m, h, y, w, null);
            ac(m, y)
        }
        return null
    }
    function p(m, h, y, w, C) {
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return m = m.get(y) || null,
                a(h, m, "" + w, C);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
                case Gl:
                    return m = m.get(w.key === null ? y : w.key) || null,
                        l(h, m, w, C);
                case Co:
                    return m = m.get(w.key === null ? y : w.key) || null,
                        c(h, m, w, C);
                case Yr:
                    var S = w._init;
                    return p(m, h, y, S(w._payload), C)
            }
            if (Ys(w) || $s(w))
                return m = m.get(y) || null,
                    u(h, m, w, C, null);
            ac(h, w)
        }
        return null
    }
    function v(m, h, y, w) {
        for (var C = null, S = null, T = h, R = h = 0, F = null; T !== null && R < y.length; R++) {
            T.index > R ? (F = T,
                T = null) : F = T.sibling;
            var P = d(m, T, y[R], w);
            if (P === null) {
                T === null && (T = F);
                break
            }
            e && T && P.alternate === null && t(m, T),
                h = o(P, h, R),
                S === null ? C = P : S.sibling = P,
                S = P,
                T = F
        }
        if (R === y.length)
            return n(m, T),
                $e && _i(m, R),
                C;
        if (T === null) {
            for (; R < y.length; R++)
                T = f(m, y[R], w),
                    T !== null && (h = o(T, h, R),
                        S === null ? C = T : S.sibling = T,
                        S = T);
            return $e && _i(m, R),
                C
        }
        for (T = r(m, T); R < y.length; R++)
            F = p(T, m, R, y[R], w),
                F !== null && (e && F.alternate !== null && T.delete(F.key === null ? R : F.key),
                    h = o(F, h, R),
                    S === null ? C = F : S.sibling = F,
                    S = F);
        return e && T.forEach(function (B) {
            return t(m, B)
        }),
            $e && _i(m, R),
            C
    }
    function g(m, h, y, w) {
        var C = $s(y);
        if (typeof C != "function")
            throw Error(M(150));
        if (y = C.call(y),
            y == null)
            throw Error(M(151));
        for (var S = C = null, T = h, R = h = 0, F = null, P = y.next(); T !== null && !P.done; R++,
            P = y.next()) {
            T.index > R ? (F = T,
                T = null) : F = T.sibling;
            var B = d(m, T, P.value, w);
            if (B === null) {
                T === null && (T = F);
                break
            }
            e && T && B.alternate === null && t(m, T),
                h = o(B, h, R),
                S === null ? C = B : S.sibling = B,
                S = B,
                T = F
        }
        if (P.done)
            return n(m, T),
                $e && _i(m, R),
                C;
        if (T === null) {
            for (; !P.done; R++,
                P = y.next())
                P = f(m, P.value, w),
                    P !== null && (h = o(P, h, R),
                        S === null ? C = P : S.sibling = P,
                        S = P);
            return $e && _i(m, R),
                C
        }
        for (T = r(m, T); !P.done; R++,
            P = y.next())
            P = p(T, m, R, P.value, w),
                P !== null && (e && P.alternate !== null && T.delete(P.key === null ? R : P.key),
                    h = o(P, h, R),
                    S === null ? C = P : S.sibling = P,
                    S = P);
        return e && T.forEach(function ($) {
            return t(m, $)
        }),
            $e && _i(m, R),
            C
    }
    function b(m, h, y, w) {
        if (typeof y == "object" && y !== null && y.type === To && y.key === null && (y = y.props.children),
            typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
                case Gl:
                    e: {
                        for (var C = y.key, S = h; S !== null;) {
                            if (S.key === C) {
                                if (C = y.type,
                                    C === To) {
                                    if (S.tag === 7) {
                                        n(m, S.sibling),
                                            h = i(S, y.props.children),
                                            h.return = m,
                                            m = h;
                                        break e
                                    }
                                } else if (S.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Yr && xx(C) === S.type) {
                                    n(m, S.sibling),
                                        h = i(S, y.props),
                                        h.ref = Ws(m, S, y),
                                        h.return = m,
                                        m = h;
                                    break e
                                }
                                n(m, S);
                                break
                            }
                            t(m, S),
                                S = S.sibling
                        }
                        y.type === To ? (h = Ai(y.props.children, m.mode, w, y.key),
                            h.return = m,
                            m = h) : (w = xc(y.type, y.key, y.props, null, m.mode, w),
                                w.ref = Ws(m, h, y),
                                w.return = m,
                                m = w)
                    }
                    return s(m);
                case Co:
                    e: {
                        for (S = y.key; h !== null;) {
                            if (h.key === S) {
                                if (h.tag === 4 && h.stateNode.containerInfo === y.containerInfo && h.stateNode.implementation === y.implementation) {
                                    n(m, h.sibling),
                                        h = i(h, y.children || []),
                                        h.return = m,
                                        m = h;
                                    break e
                                }
                                n(m, h);
                                break
                            }
                            t(m, h),
                                h = h.sibling
                        }
                        h = Ch(y, m.mode, w),
                            h.return = m,
                            m = h
                    }
                    return s(m);
                case Yr:
                    return S = y._init,
                        b(m, h, S(y._payload), w)
            }
            if (Ys(y))
                return v(m, h, y, w);
            if ($s(y))
                return g(m, h, y, w);
            ac(m, y)
        }
        return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y,
            h !== null && h.tag === 6 ? (n(m, h.sibling),
                h = i(h, y),
                h.return = m,
                m = h) : (n(m, h),
                    h = kh(y, m.mode, w),
                    h.return = m,
                    m = h),
            s(m)) : n(m, h)
    }
    return b
}
var Uo = Uw(!0)
    , Gw = Uw(!1)
    , Ea = {}
    , cr = di(Ea)
    , ya = di(Ea)
    , ba = di(Ea);
function Li(e) {
    if (e === Ea)
        throw Error(M(174));
    return e
}
function $p(e, t) {
    switch (Oe(ba, t),
    Oe(ya, e),
    Oe(cr, Ea),
    e = t.nodeType,
    e) {
        case 9:
        case 11:
            t = (t = t.documentElement) ? t.namespaceURI : Lh(null, "");
            break;
        default:
            e = e === 8 ? t.parentNode : t,
                t = e.namespaceURI || null,
                e = e.tagName,
                t = Lh(t, e)
    }
    Ae(cr),
        Oe(cr, t)
}
function Go() {
    Ae(cr),
        Ae(ya),
        Ae(ba)
}
function qw(e) {
    Li(ba.current);
    var t = Li(cr.current)
        , n = Lh(t, e.type);
    t !== n && (Oe(ya, e),
        Oe(cr, n))
}
function Np(e) {
    ya.current === e && (Ae(cr),
        Ae(ya))
}
var He = di(0);
function Dc(e) {
    for (var t = e; t !== null;) {
        if (t.tag === 13) {
            var n = t.memoizedState;
            if (n !== null && (n = n.dehydrated,
                n === null || n.data === "$?" || n.data === "$!"))
                return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (128 & t.flags)
                return t
        } else if (t.child !== null) {
            t.child.return = t,
                t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null;) {
            if (t.return === null || t.return === e)
                return null;
            t = t.return
        }
        t.sibling.return = t.return,
            t = t.sibling
    }
    return null
}
var vh = [];
function jp() {
    for (var e = 0; e < vh.length; e++)
        vh[e]._workInProgressVersionPrimary = null;
    vh.length = 0
}
var mc = Vr.ReactCurrentDispatcher
    , yh = Vr.ReactCurrentBatchConfig
    , Bi = 0
    , We = null
    , ct = null
    , pt = null
    , zc = !1
    , ra = !1
    , xa = 0
    , eM = 0;
function _t() {
    throw Error(M(321))
}
function Hp(e, t) {
    if (t === null)
        return !1;
    for (var n = 0; n < t.length && n < e.length; n++)
        if (!Nn(e[n], t[n]))
            return !1;
    return !0
}
function Wp(e, t, n, r, i, o) {
    if (Bi = o,
        We = t,
        t.memoizedState = null,
        t.updateQueue = null,
        t.lanes = 0,
        mc.current = e === null || e.memoizedState === null ? iM : oM,
        e = n(r, i),
        ra) {
        o = 0;
        do {
            if (ra = !1,
                xa = 0,
                25 <= o)
                throw Error(M(301));
            o += 1,
                pt = ct = null,
                t.updateQueue = null,
                mc.current = sM,
                e = n(r, i)
        } while (ra)
    }
    if (mc.current = Bc,
        t = ct !== null && ct.next !== null,
        Bi = 0,
        pt = ct = We = null,
        zc = !1,
        t)
        throw Error(M(300));
    return e
}
function Up() {
    var e = xa !== 0;
    return xa = 0,
        e
}
function sr() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return pt === null ? We.memoizedState = pt = e : pt = pt.next = e,
        pt
}
function Fn() {
    if (ct === null) {
        var e = We.alternate;
        e = e !== null ? e.memoizedState : null
    } else
        e = ct.next;
    var t = pt === null ? We.memoizedState : pt.next;
    if (t !== null)
        pt = t,
            ct = e;
    else {
        if (e === null)
            throw Error(M(310));
        ct = e,
            e = {
                memoizedState: ct.memoizedState,
                baseState: ct.baseState,
                baseQueue: ct.baseQueue,
                queue: ct.queue,
                next: null
            },
            pt === null ? We.memoizedState = pt = e : pt = pt.next = e
    }
    return pt
}
function wa(e, t) {
    return typeof t == "function" ? t(e) : t
}
function bh(e) {
    var t = Fn()
        , n = t.queue;
    if (n === null)
        throw Error(M(311));
    n.lastRenderedReducer = e;
    var r = ct
        , i = r.baseQueue
        , o = n.pending;
    if (o !== null) {
        if (i !== null) {
            var s = i.next;
            i.next = o.next,
                o.next = s
        }
        r.baseQueue = i = o,
            n.pending = null
    }
    if (i !== null) {
        o = i.next,
            r = r.baseState;
        var a = s = null
            , l = null
            , c = o;
        do {
            var u = c.lane;
            if ((Bi & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                    r = c.hasEagerState ? c.eagerState : e(r, c.action);
            else {
                var f = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = f,
                    s = r) : l = l.next = f,
                    We.lanes |= u,
                    $i |= u
            }
            c = c.next
        } while (c !== null && c !== o);
        l === null ? s = r : l.next = a,
            Nn(r, t.memoizedState) || (qt = !0),
            t.memoizedState = r,
            t.baseState = s,
            t.baseQueue = l,
            n.lastRenderedState = r
    }
    if (e = n.interleaved,
        e !== null) {
        i = e;
        do
            o = i.lane,
                We.lanes |= o,
                $i |= o,
                i = i.next;
        while (i !== e)
    } else
        i === null && (n.lanes = 0);
    return [t.memoizedState, n.dispatch]
}
function xh(e) {
    var t = Fn()
        , n = t.queue;
    if (n === null)
        throw Error(M(311));
    n.lastRenderedReducer = e;
    var r = n.dispatch
        , i = n.pending
        , o = t.memoizedState;
    if (i !== null) {
        n.pending = null;
        var s = i = i.next;
        do
            o = e(o, s.action),
                s = s.next;
        while (s !== i);
        Nn(o, t.memoizedState) || (qt = !0),
            t.memoizedState = o,
            t.baseQueue === null && (t.baseState = o),
            n.lastRenderedState = o
    }
    return [o, r]
}
function Xw() { }
function Yw(e, t) {
    var n = We
        , r = Fn()
        , i = t()
        , o = !Nn(r.memoizedState, i);
    if (o && (r.memoizedState = i,
        qt = !0),
        r = r.queue,
        Gp(Zw.bind(null, n, r, e), [e]),
        r.getSnapshot !== t || o || pt !== null && 1 & pt.memoizedState.tag) {
        if (n.flags |= 2048,
            Sa(9, Qw.bind(null, n, r, i, t), void 0, null),
            mt === null)
            throw Error(M(349));
        30 & Bi || Kw(n, t, i)
    }
    return i
}
function Kw(e, t, n) {
    e.flags |= 16384,
        e = {
            getSnapshot: t,
            value: n
        },
        t = We.updateQueue,
        t === null ? (t = {
            lastEffect: null,
            stores: null
        },
            We.updateQueue = t,
            t.stores = [e]) : (n = t.stores,
                n === null ? t.stores = [e] : n.push(e))
}
function Qw(e, t, n, r) {
    t.value = n,
        t.getSnapshot = r,
        Jw(t) && eS(e)
}
function Zw(e, t, n) {
    return n(function () {
        Jw(t) && eS(e)
    })
}
function Jw(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var n = t();
        return !Nn(e, n)
    } catch {
        return !0
    }
}
function eS(e) {
    var t = Mr(e, 1);
    t !== null && $n(t, e, 1, -1)
}
function wx(e) {
    var t = sr();
    return typeof e == "function" && (e = e()),
        t.memoizedState = t.baseState = e,
        e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: wa,
            lastRenderedState: e
        },
        t.queue = e,
        e = e.dispatch = rM.bind(null, We, e),
        [t.memoizedState, e]
}
function Sa(e, t, n, r) {
    return e = {
        tag: e,
        create: t,
        destroy: n,
        deps: r,
        next: null
    },
        t = We.updateQueue,
        t === null ? (t = {
            lastEffect: null,
            stores: null
        },
            We.updateQueue = t,
            t.lastEffect = e.next = e) : (n = t.lastEffect,
                n === null ? t.lastEffect = e.next = e : (r = n.next,
                    n.next = e,
                    e.next = r,
                    t.lastEffect = e)),
        e
}
function tS() {
    return Fn().memoizedState
}
function gc(e, t, n, r) {
    var i = sr();
    We.flags |= e,
        i.memoizedState = Sa(1 | t, n, void 0, r === void 0 ? null : r)
}
function Zc(e, t, n, r) {
    var i = Fn();
    r = r === void 0 ? null : r;
    var o = void 0;
    if (ct !== null) {
        var s = ct.memoizedState;
        if (o = s.destroy,
            r !== null && Hp(r, s.deps)) {
            i.memoizedState = Sa(t, n, o, r);
            return
        }
    }
    We.flags |= e,
        i.memoizedState = Sa(1 | t, n, o, r)
}
function Sx(e, t) {
    return gc(8390656, 8, e, t)
}
function Gp(e, t) {
    return Zc(2048, 8, e, t)
}
function nS(e, t) {
    return Zc(4, 2, e, t)
}
function rS(e, t) {
    return Zc(4, 4, e, t)
}
function iS(e, t) {
    return typeof t == "function" ? (e = e(),
        t(e),
        function () {
            t(null)
        }
    ) : t != null ? (e = e(),
        t.current = e,
        function () {
            t.current = null
        }
    ) : void 0
}
function oS(e, t, n) {
    return n = n != null ? n.concat([e]) : null,
        Zc(4, 4, iS.bind(null, t, e), n)
}
function qp() { }
function sS(e, t) {
    var n = Fn();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && Hp(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
        e)
}
function aS(e, t) {
    var n = Fn();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && Hp(t, r[1]) ? r[0] : (e = e(),
        n.memoizedState = [e, t],
        e)
}
function lS(e, t, n) {
    return 21 & Bi ? (Nn(n, t) || (n = fw(),
        We.lanes |= n,
        $i |= n,
        e.baseState = !0),
        t) : (e.baseState && (e.baseState = !1,
            qt = !0),
            e.memoizedState = n)
}
function tM(e, t) {
    var n = Te;
    Te = n !== 0 && 4 > n ? n : 4,
        e(!0);
    var r = yh.transition;
    yh.transition = {};
    try {
        e(!1),
            t()
    } finally {
        Te = n,
            yh.transition = r
    }
}
function cS() {
    return Fn().memoizedState
}
function nM(e, t, n) {
    var r = ai(e);
    if (n = {
        lane: r,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
        uS(e))
        fS(t, n);
    else if (n = Nw(e, t, n, r),
        n !== null) {
        var i = Bt();
        $n(n, e, r, i),
            dS(n, t, r)
    }
}
function rM(e, t, n) {
    var r = ai(e)
        , i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (uS(e))
        fS(t, i);
    else {
        var o = e.alternate;
        if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer,
            o !== null))
            try {
                var s = t.lastRenderedState
                    , a = o(s, n);
                if (i.hasEagerState = !0,
                    i.eagerState = a,
                    Nn(a, s)) {
                    var l = t.interleaved;
                    l === null ? (i.next = i,
                        zp(t)) : (i.next = l.next,
                            l.next = i),
                        t.interleaved = i;
                    return
                }
            } catch { }
        n = Nw(e, t, i, r),
            n !== null && (i = Bt(),
                $n(n, e, r, i),
                dS(n, t, r))
    }
}
function uS(e) {
    var t = e.alternate;
    return e === We || t !== null && t === We
}
function fS(e, t) {
    ra = zc = !0;
    var n = e.pending;
    n === null ? t.next = t : (t.next = n.next,
        n.next = t),
        e.pending = t
}
function dS(e, t, n) {
    if (4194240 & n) {
        var r = t.lanes;
        r &= e.pendingLanes,
            n |= r,
            t.lanes = n,
            Cp(e, n)
    }
}
var Bc = {
    readContext: En,
    useCallback: _t,
    useContext: _t,
    useEffect: _t,
    useImperativeHandle: _t,
    useInsertionEffect: _t,
    useLayoutEffect: _t,
    useMemo: _t,
    useReducer: _t,
    useRef: _t,
    useState: _t,
    useDebugValue: _t,
    useDeferredValue: _t,
    useTransition: _t,
    useMutableSource: _t,
    useSyncExternalStore: _t,
    useId: _t,
    unstable_isNewReconciler: !1
}
    , iM = {
        readContext: En,
        useCallback: function (e, t) {
            return sr().memoizedState = [e, t === void 0 ? null : t],
                e
        },
        useContext: En,
        useEffect: Sx,
        useImperativeHandle: function (e, t, n) {
            return n = n != null ? n.concat([e]) : null,
                gc(4194308, 4, iS.bind(null, t, e), n)
        },
        useLayoutEffect: function (e, t) {
            return gc(4194308, 4, e, t)
        },
        useInsertionEffect: function (e, t) {
            return gc(4, 2, e, t)
        },
        useMemo: function (e, t) {
            var n = sr();
            return t = t === void 0 ? null : t,
                e = e(),
                n.memoizedState = [e, t],
                e
        },
        useReducer: function (e, t, n) {
            var r = sr();
            return t = n !== void 0 ? n(t) : t,
                r.memoizedState = r.baseState = t,
                e = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: e,
                    lastRenderedState: t
                },
                r.queue = e,
                e = e.dispatch = nM.bind(null, We, e),
                [r.memoizedState, e]
        },
        useRef: function (e) {
            var t = sr();
            return e = {
                current: e
            },
                t.memoizedState = e
        },
        useState: wx,
        useDebugValue: qp,
        useDeferredValue: function (e) {
            return sr().memoizedState = e
        },
        useTransition: function () {
            var e = wx(!1)
                , t = e[0];
            return e = tM.bind(null, e[1]),
                sr().memoizedState = e,
                [t, e]
        },
        useMutableSource: function () { },
        useSyncExternalStore: function (e, t, n) {
            var r = We
                , i = sr();
            if ($e) {
                if (n === void 0)
                    throw Error(M(407));
                n = n()
            } else {
                if (n = t(),
                    mt === null)
                    throw Error(M(349));
                30 & Bi || Kw(r, t, n)
            }
            i.memoizedState = n;
            var o = {
                value: n,
                getSnapshot: t
            };
            return i.queue = o,
                Sx(Zw.bind(null, r, o, e), [e]),
                r.flags |= 2048,
                Sa(9, Qw.bind(null, r, o, n, t), void 0, null),
                n
        },
        useId: function () {
            var e = sr()
                , t = mt.identifierPrefix;
            if ($e) {
                var n = Pr
                    , r = Fr;
                n = (r & ~(1 << 32 - Bn(r) - 1)).toString(32) + n,
                    t = ":" + t + "R" + n,
                    n = xa++,
                    0 < n && (t += "H" + n.toString(32)),
                    t += ":"
            } else
                n = eM++,
                    t = ":" + t + "r" + n.toString(32) + ":";
            return e.memoizedState = t
        },
        unstable_isNewReconciler: !1
    }
    , oM = {
        readContext: En,
        useCallback: sS,
        useContext: En,
        useEffect: Gp,
        useImperativeHandle: oS,
        useInsertionEffect: nS,
        useLayoutEffect: rS,
        useMemo: aS,
        useReducer: bh,
        useRef: tS,
        useState: function () {
            return bh(wa)
        },
        useDebugValue: qp,
        useDeferredValue: function (e) {
            var t = Fn();
            return lS(t, ct.memoizedState, e)
        },
        useTransition: function () {
            var e = bh(wa)[0]
                , t = Fn().memoizedState;
            return [e, t]
        },
        useMutableSource: Xw,
        useSyncExternalStore: Yw,
        useId: cS,
        unstable_isNewReconciler: !1
    }
    , sM = {
        readContext: En,
        useCallback: sS,
        useContext: En,
        useEffect: Gp,
        useImperativeHandle: oS,
        useInsertionEffect: nS,
        useLayoutEffect: rS,
        useMemo: aS,
        useReducer: xh,
        useRef: tS,
        useState: function () {
            return xh(wa)
        },
        useDebugValue: qp,
        useDeferredValue: function (e) {
            var t = Fn();
            return ct === null ? t.memoizedState = e : lS(t, ct.memoizedState, e)
        },
        useTransition: function () {
            var e = xh(wa)[0]
                , t = Fn().memoizedState;
            return [e, t]
        },
        useMutableSource: Xw,
        useSyncExternalStore: Yw,
        useId: cS,
        unstable_isNewReconciler: !1
    };
function qo(e, t) {
    try {
        var n = ""
            , r = t;
        do
            n += A2(r),
                r = r.return;
        while (r);
        var i = n
    } catch (o) {
        i = `
Error generating stack: ` + o.message + `
` + o.stack
    }
    return {
        value: e,
        source: t,
        stack: i,
        digest: null
    }
}
function wh(e, t, n) {
    return {
        value: e,
        source: null,
        stack: n ?? null,
        digest: t ?? null
    }
}
function rp(e, t) {
    try {
        console.error(t.value)
    } catch (n) {
        setTimeout(function () {
            throw n
        })
    }
}
var aM = typeof WeakMap == "function" ? WeakMap : Map;
function hS(e, t, n) {
    n = _r(-1, n),
        n.tag = 3,
        n.payload = {
            element: null
        };
    var r = t.value;
    return n.callback = function () {
        Nc || (Nc = !0,
            dp = r),
            rp(e, t)
    }
        ,
        n
}
function pS(e, t, n) {
    n = _r(-1, n),
        n.tag = 3;
    var r = e.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = t.value;
        n.payload = function () {
            return r(i)
        }
            ,
            n.callback = function () {
                rp(e, t)
            }
    }
    var o = e.stateNode;
    return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () {
        rp(e, t),
            typeof r != "function" && (si === null ? si = new Set([this]) : si.add(this));
        var s = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: s !== null ? s : ""
        })
    }
    ),
        n
}
function kx(e, t, n) {
    var r = e.pingCache;
    if (r === null) {
        r = e.pingCache = new aM;
        var i = new Set;
        r.set(t, i)
    } else
        i = r.get(t),
            i === void 0 && (i = new Set,
                r.set(t, i));
    i.has(n) || (i.add(n),
        e = wM.bind(null, e, t, n),
        t.then(e, e))
}
function Cx(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState,
            t = t === null || t.dehydrated !== null),
            t)
            return e;
        e = e.return
    } while (e !== null);
    return null
}
function Tx(e, t, n, r, i) {
    return 1 & e.mode ? (e.flags |= 65536,
        e.lanes = i,
        e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
            n.flags |= 131072,
            n.flags &= -52805,
            n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = _r(-1, 1),
                t.tag = 2,
                oi(n, t, 1))),
            n.lanes |= 1),
            e)
}
var lM = Vr.ReactCurrentOwner
    , qt = !1;
function zt(e, t, n, r) {
    t.child = e === null ? Gw(t, null, n, r) : Uo(t, e.child, n, r)
}
function Rx(e, t, n, r, i) {
    n = n.render;
    var o = t.ref;
    return $o(t, i),
        r = Wp(e, t, n, r, o, i),
        n = Up(),
        e !== null && !qt ? (t.updateQueue = e.updateQueue,
            t.flags &= -2053,
            e.lanes &= ~i,
            Lr(e, t, i)) : ($e && n && Op(t),
                t.flags |= 1,
                zt(e, t, r, i),
                t.child)
}
function Ex(e, t, n, r, i) {
    if (e === null) {
        var o = n.type;
        return typeof o == "function" && !tm(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15,
            t.type = o,
            mS(e, t, o, r, i)) : (e = xc(n.type, null, r, t, t.mode, i),
                e.ref = t.ref,
                e.return = t,
                t.child = e)
    }
    if (o = e.child,
        !(e.lanes & i)) {
        var s = o.memoizedProps;
        if (n = n.compare,
            n = n !== null ? n : pa,
            n(s, r) && e.ref === t.ref)
            return Lr(e, t, i)
    }
    return t.flags |= 1,
        e = li(o, r),
        e.ref = t.ref,
        e.return = t,
        t.child = e
}
function mS(e, t, n, r, i) {
    if (e !== null) {
        var o = e.memoizedProps;
        if (pa(o, r) && e.ref === t.ref) {
            if (qt = !1,
                t.pendingProps = r = o,
                (e.lanes & i) === 0)
                return t.lanes = e.lanes,
                    Lr(e, t, i);
            131072 & e.flags && (qt = !0)
        }
    }
    return ip(e, t, n, r, i)
}
function gS(e, t, n) {
    var r = t.pendingProps
        , i = r.children
        , o = e !== null ? e.memoizedState : null;
    if (r.mode === "hidden")
        if (!(1 & t.mode))
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
                Oe(Vo, rn),
                rn |= n;
        else {
            if (!(1073741824 & n))
                return e = o !== null ? o.baseLanes | n : n,
                    t.lanes = t.childLanes = 1073741824,
                    t.memoizedState = {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    },
                    t.updateQueue = null,
                    Oe(Vo, rn),
                    rn |= e,
                    null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
                r = o !== null ? o.baseLanes : n,
                Oe(Vo, rn),
                rn |= r
        }
    else
        o !== null ? (r = o.baseLanes | n,
            t.memoizedState = null) : r = n,
            Oe(Vo, rn),
            rn |= r;
    return zt(e, t, i, n),
        t.child
}
function vS(e, t) {
    var n = t.ref;
    (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512,
        t.flags |= 2097152)
}
function ip(e, t, n, r, i) {
    var o = Yt(n) ? Di : Mt.current;
    return o = Ho(t, o),
        $o(t, i),
        n = Wp(e, t, n, r, o, i),
        r = Up(),
        e !== null && !qt ? (t.updateQueue = e.updateQueue,
            t.flags &= -2053,
            e.lanes &= ~i,
            Lr(e, t, i)) : ($e && r && Op(t),
                t.flags |= 1,
                zt(e, t, n, i),
                t.child)
}
function Fx(e, t, n, r, i) {
    if (Yt(n)) {
        var o = !0;
        Ic(t)
    } else
        o = !1;
    if ($o(t, i),
        t.stateNode === null)
        vc(e, t),
            Ww(t, n, r),
            np(t, n, r, i),
            r = !0;
    else if (e === null) {
        var s = t.stateNode
            , a = t.memoizedProps;
        s.props = a;
        var l = s.context
            , c = n.contextType;
        typeof c == "object" && c !== null ? c = En(c) : (c = Yt(n) ? Di : Mt.current,
            c = Ho(t, c));
        var u = n.getDerivedStateFromProps
            , f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
        f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && bx(t, s, r, c),
            Kr = !1;
        var d = t.memoizedState;
        s.state = d,
            Ac(t, r, s, i),
            l = t.memoizedState,
            a !== r || d !== l || Xt.current || Kr ? (typeof u == "function" && (tp(t, n, u, r),
                l = t.memoizedState),
                (a = Kr || yx(t, n, a, r, d, l, c)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(),
                    typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()),
                    typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
                        t.memoizedProps = r,
                        t.memoizedState = l),
                s.props = r,
                s.state = l,
                s.context = c,
                r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
                    r = !1)
    } else {
        s = t.stateNode,
            jw(e, t),
            a = t.memoizedProps,
            c = t.type === t.elementType ? a : An(t.type, a),
            s.props = c,
            f = t.pendingProps,
            d = s.context,
            l = n.contextType,
            typeof l == "object" && l !== null ? l = En(l) : (l = Yt(n) ? Di : Mt.current,
                l = Ho(t, l));
        var p = n.getDerivedStateFromProps;
        (u = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && bx(t, s, r, l),
            Kr = !1,
            d = t.memoizedState,
            s.state = d,
            Ac(t, r, s, i);
        var v = t.memoizedState;
        a !== f || d !== v || Xt.current || Kr ? (typeof p == "function" && (tp(t, n, p, r),
            v = t.memoizedState),
            (c = Kr || yx(t, n, c, r, d, v, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, v, l),
                typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, v, l)),
                typeof s.componentDidUpdate == "function" && (t.flags |= 4),
                typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
                    typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
                    t.memoizedProps = r,
                    t.memoizedState = v),
            s.props = r,
            s.state = v,
            s.context = l,
            r = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
                typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
                r = !1)
    }
    return op(e, t, n, r, o, i)
}
function op(e, t, n, r, i, o) {
    vS(e, t);
    var s = (128 & t.flags) !== 0;
    if (!r && !s)
        return i && hx(t, n, !1),
            Lr(e, t, o);
    r = t.stateNode,
        lM.current = t;
    var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return t.flags |= 1,
        e !== null && s ? (t.child = Uo(t, e.child, null, o),
            t.child = Uo(t, null, a, o)) : zt(e, t, a, o),
        t.memoizedState = r.state,
        i && hx(t, n, !0),
        t.child
}
function yS(e) {
    var t = e.stateNode;
    t.pendingContext ? dx(e, t.pendingContext, t.pendingContext !== t.context) : t.context && dx(e, t.context, !1),
        $p(e, t.containerInfo)
}
function Px(e, t, n, r, i) {
    return Wo(),
        Lp(i),
        t.flags |= 256,
        zt(e, t, n, r),
        t.child
}
var sp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function ap(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}
function bS(e, t, n) {
    var r, i = t.pendingProps, o = He.current, s = !1, a = (128 & t.flags) !== 0;
    if ((r = a) || (r = (e === null || e.memoizedState !== null) && (2 & o) !== 0),
        r ? (s = !0,
            t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1),
        Oe(He, 1 & o),
        e === null)
        return Jh(t),
            e = t.memoizedState,
            e !== null && (e = e.dehydrated,
                e !== null) ? (1 & t.mode ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
                    null) : (a = i.children,
                        e = i.fallback,
                        s ? (i = t.mode,
                            s = t.child,
                            a = {
                                mode: "hidden",
                                children: a
                            },
                            !(1 & i) && s !== null ? (s.childLanes = 0,
                                s.pendingProps = a) : s = tu(a, i, 0, null),
                            e = Ai(e, i, n, null),
                            s.return = t,
                            e.return = t,
                            s.sibling = e,
                            t.child = s,
                            t.child.memoizedState = ap(n),
                            t.memoizedState = sp,
                            e) : Xp(t, a));
    if (o = e.memoizedState,
        o !== null && (r = o.dehydrated,
            r !== null))
        return cM(e, t, a, i, r, o, n);
    if (s) {
        s = i.fallback,
            a = t.mode,
            o = e.child,
            r = o.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(1 & a) && t.child !== o ? (i = t.child,
            i.childLanes = 0,
            i.pendingProps = l,
            t.deletions = null) : (i = li(o, l),
                i.subtreeFlags = 14680064 & o.subtreeFlags),
            r !== null ? s = li(r, s) : (s = Ai(s, a, n, null),
                s.flags |= 2),
            s.return = t,
            i.return = t,
            i.sibling = s,
            t.child = i,
            i = s,
            s = t.child,
            a = e.child.memoizedState,
            a = a === null ? ap(n) : {
                baseLanes: a.baseLanes | n,
                cachePool: null,
                transitions: a.transitions
            },
            s.memoizedState = a,
            s.childLanes = e.childLanes & ~n,
            t.memoizedState = sp,
            i
    }
    return s = e.child,
        e = s.sibling,
        i = li(s, {
            mode: "visible",
            children: i.children
        }),
        !(1 & t.mode) && (i.lanes = n),
        i.return = t,
        i.sibling = null,
        e !== null && (n = t.deletions,
            n === null ? (t.deletions = [e],
                t.flags |= 16) : n.push(e)),
        t.child = i,
        t.memoizedState = null,
        i
}
function Xp(e, t) {
    return t = tu({
        mode: "visible",
        children: t
    }, e.mode, 0, null),
        t.return = e,
        e.child = t
}
function lc(e, t, n, r) {
    return r !== null && Lp(r),
        Uo(t, e.child, null, n),
        e = Xp(t, t.pendingProps.children),
        e.flags |= 2,
        t.memoizedState = null,
        e
}
function cM(e, t, n, r, i, o, s) {
    if (n)
        return 256 & t.flags ? (t.flags &= -257,
            r = wh(Error(M(422))),
            lc(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child,
                t.flags |= 128,
                null) : (o = r.fallback,
                    i = t.mode,
                    r = tu({
                        mode: "visible",
                        children: r.children
                    }, i, 0, null),
                    o = Ai(o, i, s, null),
                    o.flags |= 2,
                    r.return = t,
                    o.return = t,
                    r.sibling = o,
                    t.child = r,
                    1 & t.mode && Uo(t, e.child, null, s),
                    t.child.memoizedState = ap(s),
                    t.memoizedState = sp,
                    o);
    if (!(1 & t.mode))
        return lc(e, t, s, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset,
            r)
            var a = r.dgst;
        return r = a,
            o = Error(M(419)),
            r = wh(o, r, void 0),
            lc(e, t, s, r)
    }
    if (a = (s & e.childLanes) !== 0,
        qt || a) {
        if (r = mt,
            r !== null) {
            switch (s & -s) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (r.suspendedLanes | s) ? 0 : i,
                i !== 0 && i !== o.retryLane && (o.retryLane = i,
                    Mr(e, i),
                    $n(r, e, i, -1))
        }
        return em(),
            r = wh(Error(M(421))),
            lc(e, t, s, r)
    }
    return i.data === "$?" ? (t.flags |= 128,
        t.child = e.child,
        t = SM.bind(null, e),
        i._reactRetry = t,
        null) : (e = o.treeContext,
            on = ii(i.nextSibling),
            sn = t,
            $e = !0,
            zn = null,
            e !== null && (kn[Cn++] = Fr,
                kn[Cn++] = Pr,
                kn[Cn++] = zi,
                Fr = e.id,
                Pr = e.overflow,
                zi = t),
            t = Xp(t, r.children),
            t.flags |= 4096,
            t)
}
function _x(e, t, n) {
    e.lanes |= t;
    var r = e.alternate;
    r !== null && (r.lanes |= t),
        ep(e.return, t, n)
}
function Sh(e, t, n, r, i) {
    var o = e.memoizedState;
    o === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (o.isBackwards = t,
        o.rendering = null,
        o.renderingStartTime = 0,
        o.last = r,
        o.tail = n,
        o.tailMode = i)
}
function xS(e, t, n) {
    var r = t.pendingProps
        , i = r.revealOrder
        , o = r.tail;
    if (zt(e, t, r.children, n),
        r = He.current,
        2 & r)
        r = 1 & r | 2,
            t.flags |= 128;
    else {
        if (e !== null && 128 & e.flags)
            e: for (e = t.child; e !== null;) {
                if (e.tag === 13)
                    e.memoizedState !== null && _x(e, n, t);
                else if (e.tag === 19)
                    _x(e, n, t);
                else if (e.child !== null) {
                    e.child.return = e,
                        e = e.child;
                    continue
                }
                if (e === t)
                    break e;
                for (; e.sibling === null;) {
                    if (e.return === null || e.return === t)
                        break e;
                    e = e.return
                }
                e.sibling.return = e.return,
                    e = e.sibling
            }
        r &= 1
    }
    if (Oe(He, r),
        !(1 & t.mode))
        t.memoizedState = null;
    else
        switch (i) {
            case "forwards":
                for (n = t.child,
                    i = null; n !== null;)
                    e = n.alternate,
                        e !== null && Dc(e) === null && (i = n),
                        n = n.sibling;
                n = i,
                    n === null ? (i = t.child,
                        t.child = null) : (i = n.sibling,
                            n.sibling = null),
                    Sh(t, !1, i, n, o);
                break;
            case "backwards":
                for (n = null,
                    i = t.child,
                    t.child = null; i !== null;) {
                    if (e = i.alternate,
                        e !== null && Dc(e) === null) {
                        t.child = i;
                        break
                    }
                    e = i.sibling,
                        i.sibling = n,
                        n = i,
                        i = e
                }
                Sh(t, !0, n, null, o);
                break;
            case "together":
                Sh(t, !1, null, null, void 0);
                break;
            default:
                t.memoizedState = null
        }
    return t.child
}
function vc(e, t) {
    !(1 & t.mode) && e !== null && (e.alternate = null,
        t.alternate = null,
        t.flags |= 2)
}
function Lr(e, t, n) {
    if (e !== null && (t.dependencies = e.dependencies),
        $i |= t.lanes,
        !(n & t.childLanes))
        return null;
    if (e !== null && t.child !== e.child)
        throw Error(M(153));
    if (t.child !== null) {
        for (e = t.child,
            n = li(e, e.pendingProps),
            t.child = n,
            n.return = t; e.sibling !== null;)
            e = e.sibling,
                n = n.sibling = li(e, e.pendingProps),
                n.return = t;
        n.sibling = null
    }
    return t.child
}
function uM(e, t, n) {
    switch (t.tag) {
        case 3:
            yS(t),
                Wo();
            break;
        case 5:
            qw(t);
            break;
        case 1:
            Yt(t.type) && Ic(t);
            break;
        case 4:
            $p(t, t.stateNode.containerInfo);
            break;
        case 10:
            var r = t.type._context
                , i = t.memoizedProps.value;
            Oe(Lc, r._currentValue),
                r._currentValue = i;
            break;
        case 13:
            if (r = t.memoizedState,
                r !== null)
                return r.dehydrated !== null ? (Oe(He, 1 & He.current),
                    t.flags |= 128,
                    null) : n & t.child.childLanes ? bS(e, t, n) : (Oe(He, 1 & He.current),
                        e = Lr(e, t, n),
                        e !== null ? e.sibling : null);
            Oe(He, 1 & He.current);
            break;
        case 19:
            if (r = (n & t.childLanes) !== 0,
                128 & e.flags) {
                if (r)
                    return xS(e, t, n);
                t.flags |= 128
            }
            if (i = t.memoizedState,
                i !== null && (i.rendering = null,
                    i.tail = null,
                    i.lastEffect = null),
                Oe(He, He.current),
                r)
                break;
            return null;
        case 22:
        case 23:
            return t.lanes = 0,
                gS(e, t, n)
    }
    return Lr(e, t, n)
}
var wS, lp, SS, kS;
wS = function (e, t) {
    for (var n = t.child; n !== null;) {
        if (n.tag === 5 || n.tag === 6)
            e.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n,
                n = n.child;
            continue
        }
        if (n === t)
            break;
        for (; n.sibling === null;) {
            if (n.return === null || n.return === t)
                return;
            n = n.return
        }
        n.sibling.return = n.return,
            n = n.sibling
    }
}
    ;
lp = function () { }
    ;
SS = function (e, t, n, r) {
    var i = e.memoizedProps;
    if (i !== r) {
        e = t.stateNode,
            Li(cr.current);
        var o = null;
        switch (n) {
            case "input":
                i = _h(e, i),
                    r = _h(e, r),
                    o = [];
                break;
            case "select":
                i = Ue({}, i, {
                    value: void 0
                }),
                    r = Ue({}, r, {
                        value: void 0
                    }),
                    o = [];
                break;
            case "textarea":
                i = Mh(e, i),
                    r = Mh(e, r),
                    o = [];
                break;
            default:
                typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Pc)
        }
        Vh(n, r);
        var s;
        n = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (s in a)
                        a.hasOwnProperty(s) && (n || (n = {}),
                            n[s] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (aa.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
        for (c in r) {
            var l = r[c];
            if (a = i?.[c],
                r.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (s in a)
                            !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}),
                                n[s] = "");
                        for (s in l)
                            l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}),
                                n[s] = l[s])
                    } else
                        n || (o || (o = []),
                            o.push(c, n)),
                            n = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                        a = a ? a.__html : void 0,
                        l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (aa.hasOwnProperty(c) ? (l != null && c === "onScroll" && Ve("scroll", e),
                            o || a === l || (o = [])) : (o = o || []).push(c, l))
        }
        n && (o = o || []).push("style", n);
        var c = o;
        (t.updateQueue = c) && (t.flags |= 4)
    }
}
    ;
kS = function (e, t, n, r) {
    n !== r && (t.flags |= 4)
}
    ;
function Us(e, t) {
    if (!$e)
        switch (e.tailMode) {
            case "hidden":
                t = e.tail;
                for (var n = null; t !== null;)
                    t.alternate !== null && (n = t),
                        t = t.sibling;
                n === null ? e.tail = null : n.sibling = null;
                break;
            case "collapsed":
                n = e.tail;
                for (var r = null; n !== null;)
                    n.alternate !== null && (r = n),
                        n = n.sibling;
                r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
        }
}
function It(e) {
    var t = e.alternate !== null && e.alternate.child === e.child
        , n = 0
        , r = 0;
    if (t)
        for (var i = e.child; i !== null;)
            n |= i.lanes | i.childLanes,
                r |= 14680064 & i.subtreeFlags,
                r |= 14680064 & i.flags,
                i.return = e,
                i = i.sibling;
    else
        for (i = e.child; i !== null;)
            n |= i.lanes | i.childLanes,
                r |= i.subtreeFlags,
                r |= i.flags,
                i.return = e,
                i = i.sibling;
    return e.subtreeFlags |= r,
        e.childLanes = n,
        t
}
function fM(e, t, n) {
    var r = t.pendingProps;
    switch (Mp(t),
    t.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return It(t),
                null;
        case 1:
            return Yt(t.type) && _c(),
                It(t),
                null;
        case 3:
            return r = t.stateNode,
                Go(),
                Ae(Xt),
                Ae(Mt),
                jp(),
                r.pendingContext && (r.context = r.pendingContext,
                    r.pendingContext = null),
                e !== null && e.child !== null || (sc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024,
                    zn !== null && (mp(zn),
                        zn = null))),
                lp(e, t),
                It(t),
                null;
        case 5:
            Np(t);
            var i = Li(ba.current);
            if (n = t.type,
                e !== null && t.stateNode != null)
                SS(e, t, n, r, i),
                    e.ref !== t.ref && (t.flags |= 512,
                        t.flags |= 2097152);
            else {
                if (!r) {
                    if (t.stateNode === null)
                        throw Error(M(166));
                    return It(t),
                        null
                }
                if (e = Li(cr.current),
                    sc(t)) {
                    r = t.stateNode,
                        n = t.type;
                    var o = t.memoizedProps;
                    switch (r[ar] = t,
                    r[va] = o,
                    e = (1 & t.mode) !== 0,
                    n) {
                        case "dialog":
                            Ve("cancel", r),
                                Ve("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Ve("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < Qs.length; i++)
                                Ve(Qs[i], r);
                            break;
                        case "source":
                            Ve("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Ve("error", r),
                                Ve("load", r);
                            break;
                        case "details":
                            Ve("toggle", r);
                            break;
                        case "input":
                            zb(r, o),
                                Ve("invalid", r);
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!o.multiple
                            },
                                Ve("invalid", r);
                            break;
                        case "textarea":
                            $b(r, o),
                                Ve("invalid", r)
                    }
                    Vh(n, o),
                        i = null;
                    for (var s in o)
                        if (o.hasOwnProperty(s)) {
                            var a = o[s];
                            s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && oc(r.textContent, a, e),
                                i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && oc(r.textContent, a, e),
                                    i = ["children", "" + a]) : aa.hasOwnProperty(s) && a != null && s === "onScroll" && Ve("scroll", r)
                        }
                    switch (n) {
                        case "input":
                            ql(r),
                                Bb(r, o, !0);
                            break;
                        case "textarea":
                            ql(r),
                                Nb(r);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof o.onClick == "function" && (r.onclick = Pc)
                    }
                    r = i,
                        t.updateQueue = r,
                        r !== null && (t.flags |= 4)
                } else {
                    s = i.nodeType === 9 ? i : i.ownerDocument,
                        e === "http://www.w3.org/1999/xhtml" && (e = Kx(n)),
                        e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"),
                            e.innerHTML = "<script><\/script>",
                            e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, {
                                is: r.is
                            }) : (e = s.createElement(n),
                                n === "select" && (s = e,
                                    r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n),
                        e[ar] = t,
                        e[va] = r,
                        wS(e, t, !1, !1),
                        t.stateNode = e;
                    e: {
                        switch (s = Ah(n, r),
                        n) {
                            case "dialog":
                                Ve("cancel", e),
                                    Ve("close", e),
                                    i = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                Ve("load", e),
                                    i = r;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < Qs.length; i++)
                                    Ve(Qs[i], e);
                                i = r;
                                break;
                            case "source":
                                Ve("error", e),
                                    i = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                Ve("error", e),
                                    Ve("load", e),
                                    i = r;
                                break;
                            case "details":
                                Ve("toggle", e),
                                    i = r;
                                break;
                            case "input":
                                zb(e, r),
                                    i = _h(e, r),
                                    Ve("invalid", e);
                                break;
                            case "option":
                                i = r;
                                break;
                            case "select":
                                e._wrapperState = {
                                    wasMultiple: !!r.multiple
                                },
                                    i = Ue({}, r, {
                                        value: void 0
                                    }),
                                    Ve("invalid", e);
                                break;
                            case "textarea":
                                $b(e, r),
                                    i = Mh(e, r),
                                    Ve("invalid", e);
                                break;
                            default:
                                i = r
                        }
                        Vh(n, i),
                            a = i;
                        for (o in a)
                            if (a.hasOwnProperty(o)) {
                                var l = a[o];
                                o === "style" ? Jx(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                                    l != null && Qx(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && la(e, l) : typeof l == "number" && la(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (aa.hasOwnProperty(o) ? l != null && o === "onScroll" && Ve("scroll", e) : l != null && yp(e, o, l, s))
                            }
                        switch (n) {
                            case "input":
                                ql(e),
                                    Bb(e, r, !1);
                                break;
                            case "textarea":
                                ql(e),
                                    Nb(e);
                                break;
                            case "option":
                                r.value != null && e.setAttribute("value", "" + ci(r.value));
                                break;
                            case "select":
                                e.multiple = !!r.multiple,
                                    o = r.value,
                                    o != null ? Ao(e, !!r.multiple, o, !1) : r.defaultValue != null && Ao(e, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (e.onclick = Pc)
                        }
                        switch (n) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                r = !!r.autoFocus;
                                break e;
                            case "img":
                                r = !0;
                                break e;
                            default:
                                r = !1
                        }
                    }
                    r && (t.flags |= 4)
                }
                t.ref !== null && (t.flags |= 512,
                    t.flags |= 2097152)
            }
            return It(t),
                null;
        case 6:
            if (e && t.stateNode != null)
                kS(e, t, e.memoizedProps, r);
            else {
                if (typeof r != "string" && t.stateNode === null)
                    throw Error(M(166));
                if (n = Li(ba.current),
                    Li(cr.current),
                    sc(t)) {
                    if (r = t.stateNode,
                        n = t.memoizedProps,
                        r[ar] = t,
                        (o = r.nodeValue !== n) && (e = sn,
                            e !== null))
                        switch (e.tag) {
                            case 3:
                                oc(r.nodeValue, n, (1 & e.mode) !== 0);
                                break;
                            case 5:
                                e.memoizedProps.suppressHydrationWarning !== !0 && oc(r.nodeValue, n, (1 & e.mode) !== 0)
                        }
                    o && (t.flags |= 4)
                } else
                    r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r),
                        r[ar] = t,
                        t.stateNode = r
            }
            return It(t),
                null;
        case 13:
            if (Ae(He),
                r = t.memoizedState,
                e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
                if ($e && on !== null && 1 & t.mode && !(128 & t.flags))
                    $w(),
                        Wo(),
                        t.flags |= 98560,
                        o = !1;
                else if (o = sc(t),
                    r !== null && r.dehydrated !== null) {
                    if (e === null) {
                        if (!o)
                            throw Error(M(318));
                        if (o = t.memoizedState,
                            o = o !== null ? o.dehydrated : null,
                            !o)
                            throw Error(M(317));
                        o[ar] = t
                    } else
                        Wo(),
                            !(128 & t.flags) && (t.memoizedState = null),
                            t.flags |= 4;
                    It(t),
                        o = !1
                } else
                    zn !== null && (mp(zn),
                        zn = null),
                        o = !0;
                if (!o)
                    return 65536 & t.flags ? t : null
            }
            return 128 & t.flags ? (t.lanes = n,
                t) : (r = r !== null,
                    r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192,
                        1 & t.mode && (e === null || 1 & He.current ? ut === 0 && (ut = 3) : em())),
                    t.updateQueue !== null && (t.flags |= 4),
                    It(t),
                    null);
        case 4:
            return Go(),
                lp(e, t),
                e === null && ma(t.stateNode.containerInfo),
                It(t),
                null;
        case 10:
            return Dp(t.type._context),
                It(t),
                null;
        case 17:
            return Yt(t.type) && _c(),
                It(t),
                null;
        case 19:
            if (Ae(He),
                o = t.memoizedState,
                o === null)
                return It(t),
                    null;
            if (r = (128 & t.flags) !== 0,
                s = o.rendering,
                s === null)
                if (r)
                    Us(o, !1);
                else {
                    if (ut !== 0 || e !== null && 128 & e.flags)
                        for (e = t.child; e !== null;) {
                            if (s = Dc(e),
                                s !== null) {
                                for (t.flags |= 128,
                                    Us(o, !1),
                                    r = s.updateQueue,
                                    r !== null && (t.updateQueue = r,
                                        t.flags |= 4),
                                    t.subtreeFlags = 0,
                                    r = n,
                                    n = t.child; n !== null;)
                                    o = n,
                                        e = r,
                                        o.flags &= 14680066,
                                        s = o.alternate,
                                        s === null ? (o.childLanes = 0,
                                            o.lanes = e,
                                            o.child = null,
                                            o.subtreeFlags = 0,
                                            o.memoizedProps = null,
                                            o.memoizedState = null,
                                            o.updateQueue = null,
                                            o.dependencies = null,
                                            o.stateNode = null) : (o.childLanes = s.childLanes,
                                                o.lanes = s.lanes,
                                                o.child = s.child,
                                                o.subtreeFlags = 0,
                                                o.deletions = null,
                                                o.memoizedProps = s.memoizedProps,
                                                o.memoizedState = s.memoizedState,
                                                o.updateQueue = s.updateQueue,
                                                o.type = s.type,
                                                e = s.dependencies,
                                                o.dependencies = e === null ? null : {
                                                    lanes: e.lanes,
                                                    firstContext: e.firstContext
                                                }),
                                        n = n.sibling;
                                return Oe(He, 1 & He.current | 2),
                                    t.child
                            }
                            e = e.sibling
                        }
                    o.tail !== null && nt() > Xo && (t.flags |= 128,
                        r = !0,
                        Us(o, !1),
                        t.lanes = 4194304)
                }
            else {
                if (!r)
                    if (e = Dc(s),
                        e !== null) {
                        if (t.flags |= 128,
                            r = !0,
                            n = e.updateQueue,
                            n !== null && (t.updateQueue = n,
                                t.flags |= 4),
                            Us(o, !0),
                            o.tail === null && o.tailMode === "hidden" && !s.alternate && !$e)
                            return It(t),
                                null
                    } else
                        2 * nt() - o.renderingStartTime > Xo && n !== 1073741824 && (t.flags |= 128,
                            r = !0,
                            Us(o, !1),
                            t.lanes = 4194304);
                o.isBackwards ? (s.sibling = t.child,
                    t.child = s) : (n = o.last,
                        n !== null ? n.sibling = s : t.child = s,
                        o.last = s)
            }
            return o.tail !== null ? (t = o.tail,
                o.rendering = t,
                o.tail = t.sibling,
                o.renderingStartTime = nt(),
                t.sibling = null,
                n = He.current,
                Oe(He, r ? 1 & n | 2 : 1 & n),
                t) : (It(t),
                    null);
        case 22:
        case 23:
            return Jp(),
                r = t.memoizedState !== null,
                e !== null && e.memoizedState !== null !== r && (t.flags |= 8192),
                r && 1 & t.mode ? 1073741824 & rn && (It(t),
                    6 & t.subtreeFlags && (t.flags |= 8192)) : It(t),
                null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(M(156, t.tag))
}
function dM(e, t) {
    switch (Mp(t),
    t.tag) {
        case 1:
            return Yt(t.type) && _c(),
                e = t.flags,
                65536 & e ? (t.flags = -65537 & e | 128,
                    t) : null;
        case 3:
            return Go(),
                Ae(Xt),
                Ae(Mt),
                jp(),
                e = t.flags,
                65536 & e && !(128 & e) ? (t.flags = -65537 & e | 128,
                    t) : null;
        case 5:
            return Np(t),
                null;
        case 13:
            if (Ae(He),
                e = t.memoizedState,
                e !== null && e.dehydrated !== null) {
                if (t.alternate === null)
                    throw Error(M(340));
                Wo()
            }
            return e = t.flags,
                65536 & e ? (t.flags = -65537 & e | 128,
                    t) : null;
        case 19:
            return Ae(He),
                null;
        case 4:
            return Go(),
                null;
        case 10:
            return Dp(t.type._context),
                null;
        case 22:
        case 23:
            return Jp(),
                null;
        case 24:
            return null;
        default:
            return null
    }
}
var cc = !1
    , Ot = !1
    , hM = typeof WeakSet == "function" ? WeakSet : Set
    , W = null;
function Lo(e, t) {
    var n = e.ref;
    if (n !== null)
        if (typeof n == "function")
            try {
                n(null)
            } catch (r) {
                Ke(e, t, r)
            }
        else
            n.current = null
}
function CS(e, t, n) {
    try {
        n()
    } catch (r) {
        Ke(e, t, r)
    }
}
var Ix = !1;
function pM(e, t) {
    if (Gh = Rc,
        e = Ew(),
        Ip(e)) {
        if ("selectionStart" in e)
            var n = {
                start: e.selectionStart,
                end: e.selectionEnd
            };
        else
            e: {
                n = (n = e.ownerDocument) && n.defaultView || I;
                var r = n.getSelection && n.getSelection();
                if (r && r.rangeCount !== 0) {
                    n = r.anchorNode;
                    var i = r.anchorOffset
                        , o = r.focusNode;
                    r = r.focusOffset;
                    try {
                        n.nodeType,
                            o.nodeType
                    } catch {
                        n = null;
                        break e
                    }
                    var s = 0
                        , a = -1
                        , l = -1
                        , c = 0
                        , u = 0
                        , f = e
                        , d = null;
                    t: for (; ;) {
                        for (var p; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i),
                            f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r),
                            f.nodeType === 3 && (s += f.nodeValue.length),
                            (p = f.firstChild) !== null;)
                            d = f,
                                f = p;
                        for (; ;) {
                            if (f === e)
                                break t;
                            if (d === n && ++c === i && (a = s),
                                d === o && ++u === r && (l = s),
                                (p = f.nextSibling) !== null)
                                break;
                            f = d,
                                d = f.parentNode
                        }
                        f = p
                    }
                    n = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    n = null
            }
        n = n || {
            start: 0,
            end: 0
        }
    } else
        n = null;
    for (qh = {
        focusedElem: e,
        selectionRange: n
    },
        Rc = !1,
        W = t; W !== null;)
        if (t = W,
            e = t.child,
            (1028 & t.subtreeFlags) !== 0 && e !== null)
            e.return = t,
                W = e;
        else
            for (; W !== null;) {
                t = W;
                try {
                    var v = t.alternate;
                    if (1024 & t.flags)
                        switch (t.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (v !== null) {
                                    var g = v.memoizedProps
                                        , b = v.memoizedState
                                        , m = t.stateNode
                                        , h = m.getSnapshotBeforeUpdate(t.elementType === t.type ? g : An(t.type, g), b);
                                    m.__reactInternalSnapshotBeforeUpdate = h
                                }
                                break;
                            case 3:
                                var y = t.stateNode.containerInfo;
                                y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(M(163))
                        }
                } catch (w) {
                    Ke(t, t.return, w)
                }
                if (e = t.sibling,
                    e !== null) {
                    e.return = t.return,
                        W = e;
                    break
                }
                W = t.return
            }
    return v = Ix,
        Ix = !1,
        v
}
function ia(e, t, n) {
    var r = t.updateQueue;
    if (r = r !== null ? r.lastEffect : null,
        r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & e) === e) {
                var o = i.destroy;
                i.destroy = void 0,
                    o !== void 0 && CS(t, n, o)
            }
            i = i.next
        } while (i !== r)
    }
}
function Jc(e, t) {
    if (t = t.updateQueue,
        t = t !== null ? t.lastEffect : null,
        t !== null) {
        var n = t = t.next;
        do {
            if ((n.tag & e) === e) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== t)
    }
}
function cp(e) {
    var t = e.ref;
    if (t !== null) {
        var n = e.stateNode;
        switch (e.tag) {
            case 5:
                e = n;
                break;
            default:
                e = n
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}
function TS(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null,
        TS(t)),
        e.child = null,
        e.deletions = null,
        e.sibling = null,
        e.tag === 5 && (t = e.stateNode,
            t !== null && (delete t[ar],
                delete t[va],
                delete t[Kh],
                delete t[KO],
                delete t[QO])),
        e.stateNode = null,
        e.return = null,
        e.dependencies = null,
        e.memoizedProps = null,
        e.memoizedState = null,
        e.pendingProps = null,
        e.stateNode = null,
        e.updateQueue = null
}
function RS(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Ox(e) {
    e: for (; ;) {
        for (; e.sibling === null;) {
            if (e.return === null || RS(e.return))
                return null;
            e = e.return
        }
        for (e.sibling.return = e.return,
            e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
            if (2 & e.flags || e.child === null || e.tag === 4)
                continue e;
            e.child.return = e,
                e = e.child
        }
        if (!(2 & e.flags))
            return e.stateNode
    }
}
function up(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6)
        e = e.stateNode,
            t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode,
                t.insertBefore(e, n)) : (t = n,
                    t.appendChild(e)),
                n = n._reactRootContainer,
                n != null || t.onclick !== null || (t.onclick = Pc));
    else if (r !== 4 && (e = e.child,
        e !== null))
        for (up(e, t, n),
            e = e.sibling; e !== null;)
            up(e, t, n),
                e = e.sibling
}
function fp(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6)
        e = e.stateNode,
            t ? n.insertBefore(e, t) : n.appendChild(e);
    else if (r !== 4 && (e = e.child,
        e !== null))
        for (fp(e, t, n),
            e = e.sibling; e !== null;)
            fp(e, t, n),
                e = e.sibling
}
var St = null
    , Dn = !1;
function Xr(e, t, n) {
    for (n = n.child; n !== null;)
        ES(e, t, n),
            n = n.sibling
}
function ES(e, t, n) {
    if (lr && typeof lr.onCommitFiberUnmount == "function")
        try {
            lr.onCommitFiberUnmount(Uc, n)
        } catch { }
    switch (n.tag) {
        case 5:
            Ot || Lo(n, t);
        case 6:
            var r = St
                , i = Dn;
            St = null,
                Xr(e, t, n),
                St = r,
                Dn = i,
                St !== null && (Dn ? (e = St,
                    n = n.stateNode,
                    e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : St.removeChild(n.stateNode));
            break;
        case 18:
            St !== null && (Dn ? (e = St,
                n = n.stateNode,
                e.nodeType === 8 ? mh(e.parentNode, n) : e.nodeType === 1 && mh(e, n),
                da(e)) : mh(St, n.stateNode));
            break;
        case 4:
            r = St,
                i = Dn,
                St = n.stateNode.containerInfo,
                Dn = !0,
                Xr(e, t, n),
                St = r,
                Dn = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!Ot && (r = n.updateQueue,
                r !== null && (r = r.lastEffect,
                    r !== null))) {
                i = r = r.next;
                do {
                    var o = i
                        , s = o.destroy;
                    o = o.tag,
                        s !== void 0 && (2 & o || 4 & o) && CS(n, t, s),
                        i = i.next
                } while (i !== r)
            }
            Xr(e, t, n);
            break;
        case 1:
            if (!Ot && (Lo(n, t),
                r = n.stateNode,
                typeof r.componentWillUnmount == "function"))
                try {
                    r.props = n.memoizedProps,
                        r.state = n.memoizedState,
                        r.componentWillUnmount()
                } catch (a) {
                    Ke(n, t, a)
                }
            Xr(e, t, n);
            break;
        case 21:
            Xr(e, t, n);
            break;
        case 22:
            1 & n.mode ? (Ot = (r = Ot) || n.memoizedState !== null,
                Xr(e, t, n),
                Ot = r) : Xr(e, t, n);
            break;
        default:
            Xr(e, t, n)
    }
}
function Mx(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var n = e.stateNode;
        n === null && (n = e.stateNode = new hM),
            t.forEach(function (r) {
                var i = kM.bind(null, e, r);
                n.has(r) || (n.add(r),
                    r.then(i, i))
            })
    }
}
function Vn(e, t) {
    var n = t.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var o = e
                    , s = t
                    , a = s;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            St = a.stateNode,
                                Dn = !1;
                            break e;
                        case 3:
                            St = a.stateNode.containerInfo,
                                Dn = !0;
                            break e;
                        case 4:
                            St = a.stateNode.containerInfo,
                                Dn = !0;
                            break e
                    }
                    a = a.return
                }
                if (St === null)
                    throw Error(M(160));
                ES(o, s, i),
                    St = null,
                    Dn = !1;
                var l = i.alternate;
                l !== null && (l.return = null),
                    i.return = null
            } catch (c) {
                Ke(i, t, c)
            }
        }
    if (12854 & t.subtreeFlags)
        for (t = t.child; t !== null;)
            FS(t, e),
                t = t.sibling
}
function FS(e, t) {
    var n = e.alternate
        , r = e.flags;
    switch (e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (Vn(t, e),
                or(e),
                4 & r) {
                try {
                    ia(3, e, e.return),
                        Jc(3, e)
                } catch (g) {
                    Ke(e, e.return, g)
                }
                try {
                    ia(5, e, e.return)
                } catch (g) {
                    Ke(e, e.return, g)
                }
            }
            break;
        case 1:
            Vn(t, e),
                or(e),
                512 & r && n !== null && Lo(n, n.return);
            break;
        case 5:
            if (Vn(t, e),
                or(e),
                512 & r && n !== null && Lo(n, n.return),
                32 & e.flags) {
                var i = e.stateNode;
                try {
                    la(i, "")
                } catch (g) {
                    Ke(e, e.return, g)
                }
            }
            if (4 & r && (i = e.stateNode,
                i != null)) {
                var o = e.memoizedProps
                    , s = n !== null ? n.memoizedProps : o
                    , a = e.type
                    , l = e.updateQueue;
                if (e.updateQueue = null,
                    l !== null)
                    try {
                        a === "input" && o.type === "radio" && o.name != null && Xx(i, o),
                            Ah(a, s);
                        var c = Ah(a, o);
                        for (s = 0; s < l.length; s += 2) {
                            var u = l[s]
                                , f = l[s + 1];
                            u === "style" ? Jx(i, f) : u === "dangerouslySetInnerHTML" ? Qx(i, f) : u === "children" ? la(i, f) : yp(i, u, f, c)
                        }
                        switch (a) {
                            case "input":
                                Ih(i, o);
                                break;
                            case "textarea":
                                Yx(i, o);
                                break;
                            case "select":
                                var d = i._wrapperState.wasMultiple;
                                i._wrapperState.wasMultiple = !!o.multiple;
                                var p = o.value;
                                p != null ? Ao(i, !!o.multiple, p, !1) : d !== !!o.multiple && (o.defaultValue != null ? Ao(i, !!o.multiple, o.defaultValue, !0) : Ao(i, !!o.multiple, o.multiple ? [] : "", !1))
                        }
                        i[va] = o
                    } catch (g) {
                        Ke(e, e.return, g)
                    }
            }
            break;
        case 6:
            if (Vn(t, e),
                or(e),
                4 & r) {
                if (e.stateNode === null)
                    throw Error(M(162));
                i = e.stateNode,
                    o = e.memoizedProps;
                try {
                    i.nodeValue = o
                } catch (g) {
                    Ke(e, e.return, g)
                }
            }
            break;
        case 3:
            if (Vn(t, e),
                or(e),
                4 & r && n !== null && n.memoizedState.isDehydrated)
                try {
                    da(t.containerInfo)
                } catch (g) {
                    Ke(e, e.return, g)
                }
            break;
        case 4:
            Vn(t, e),
                or(e);
            break;
        case 13:
            Vn(t, e),
                or(e),
                i = e.child,
                8192 & i.flags && (o = i.memoizedState !== null,
                    i.stateNode.isHidden = o,
                    !o || i.alternate !== null && i.alternate.memoizedState !== null || (Qp = nt())),
                4 & r && Mx(e);
            break;
        case 22:
            if (u = n !== null && n.memoizedState !== null,
                1 & e.mode ? (Ot = (c = Ot) || u,
                    Vn(t, e),
                    Ot = c) : Vn(t, e),
                or(e),
                8192 & r) {
                if (c = e.memoizedState !== null,
                    (e.stateNode.isHidden = c) && !u && 1 & e.mode)
                    for (W = e,
                        u = e.child; u !== null;) {
                        for (f = W = u; W !== null;) {
                            switch (d = W,
                            p = d.child,
                            d.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    ia(4, d, d.return);
                                    break;
                                case 1:
                                    Lo(d, d.return);
                                    var v = d.stateNode;
                                    if (typeof v.componentWillUnmount == "function") {
                                        r = d,
                                            n = d.return;
                                        try {
                                            t = r,
                                                v.props = t.memoizedProps,
                                                v.state = t.memoizedState,
                                                v.componentWillUnmount()
                                        } catch (g) {
                                            Ke(r, n, g)
                                        }
                                    }
                                    break;
                                case 5:
                                    Lo(d, d.return);
                                    break;
                                case 22:
                                    if (d.memoizedState !== null) {
                                        Vx(f);
                                        continue
                                    }
                            }
                            p !== null ? (p.return = d,
                                W = p) : Vx(f)
                        }
                        u = u.sibling
                    }
                e: for (u = null,
                    f = e; ;) {
                    if (f.tag === 5) {
                        if (u === null) {
                            u = f;
                            try {
                                i = f.stateNode,
                                    c ? (o = i.style,
                                        typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode,
                                            l = f.memoizedProps.style,
                                            s = l != null && l.hasOwnProperty("display") ? l.display : null,
                                            a.style.display = Zx("display", s))
                            } catch (g) {
                                Ke(e, e.return, g)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (u === null)
                            try {
                                f.stateNode.nodeValue = c ? "" : f.memoizedProps
                            } catch (g) {
                                Ke(e, e.return, g)
                            }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) {
                        f.child.return = f,
                            f = f.child;
                        continue
                    }
                    if (f === e)
                        break e;
                    for (; f.sibling === null;) {
                        if (f.return === null || f.return === e)
                            break e;
                        u === f && (u = null),
                            f = f.return
                    }
                    u === f && (u = null),
                        f.sibling.return = f.return,
                        f = f.sibling
                }
            }
            break;
        case 19:
            Vn(t, e),
                or(e),
                4 & r && Mx(e);
            break;
        case 21:
            break;
        default:
            Vn(t, e),
                or(e)
    }
}
function or(e) {
    var t = e.flags;
    if (2 & t) {
        try {
            e: {
                for (var n = e.return; n !== null;) {
                    if (RS(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(M(160))
            }
            switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    32 & r.flags && (la(i, ""),
                        r.flags &= -33);
                    var o = Ox(e);
                    fp(e, o, i);
                    break;
                case 3:
                case 4:
                    var s = r.stateNode.containerInfo
                        , a = Ox(e);
                    up(e, a, s);
                    break;
                default:
                    throw Error(M(161))
            }
        } catch (l) {
            Ke(e, e.return, l)
        }
        e.flags &= -3
    }
    4096 & t && (e.flags &= -4097)
}
function mM(e, t, n) {
    W = e,
        PS(e, t, n)
}
function PS(e, t, n) {
    for (var r = (1 & e.mode) !== 0; W !== null;) {
        var i = W
            , o = i.child;
        if (i.tag === 22 && r) {
            var s = i.memoizedState !== null || cc;
            if (!s) {
                var a = i.alternate
                    , l = a !== null && a.memoizedState !== null || Ot;
                a = cc;
                var c = Ot;
                if (cc = s,
                    (Ot = l) && !c)
                    for (W = i; W !== null;)
                        s = W,
                            l = s.child,
                            s.tag === 22 && s.memoizedState !== null ? Ax(i) : l !== null ? (l.return = s,
                                W = l) : Ax(i);
                for (; o !== null;)
                    W = o,
                        PS(o, t, n),
                        o = o.sibling;
                W = i,
                    cc = a,
                    Ot = c
            }
            Lx(e, t, n)
        } else
            8772 & i.subtreeFlags && o !== null ? (o.return = i,
                W = o) : Lx(e, t, n)
    }
}
function Lx(e) {
    for (; W !== null;) {
        var t = W;
        if (8772 & t.flags) {
            var n = t.alternate;
            try {
                if (8772 & t.flags)
                    switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Ot || Jc(5, t);
                            break;
                        case 1:
                            var r = t.stateNode;
                            if (4 & t.flags && !Ot)
                                if (n === null)
                                    r.componentDidMount();
                                else {
                                    var i = t.elementType === t.type ? n.memoizedProps : An(t.type, n.memoizedProps);
                                    r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                }
                            var o = t.updateQueue;
                            o !== null && vx(t, o, r);
                            break;
                        case 3:
                            var s = t.updateQueue;
                            if (s !== null) {
                                if (n = null,
                                    t.child !== null)
                                    switch (t.child.tag) {
                                        case 5:
                                            n = t.child.stateNode;
                                            break;
                                        case 1:
                                            n = t.child.stateNode
                                    }
                                vx(t, s, n)
                            }
                            break;
                        case 5:
                            var a = t.stateNode;
                            if (n === null && 4 & t.flags) {
                                n = a;
                                var l = t.memoizedProps;
                                switch (t.type) {
                                    case "button":
                                    case "input":
                                    case "select":
                                    case "textarea":
                                        l.autoFocus && n.focus();
                                        break;
                                    case "img":
                                        l.src && (n.src = l.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (t.memoizedState === null) {
                                var c = t.alternate;
                                if (c !== null) {
                                    var u = c.memoizedState;
                                    if (u !== null) {
                                        var f = u.dehydrated;
                                        f !== null && da(f)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(M(163))
                    }
                Ot || 512 & t.flags && cp(t)
            } catch (d) {
                Ke(t, t.return, d)
            }
        }
        if (t === e) {
            W = null;
            break
        }
        if (n = t.sibling,
            n !== null) {
            n.return = t.return,
                W = n;
            break
        }
        W = t.return
    }
}
function Vx(e) {
    for (; W !== null;) {
        var t = W;
        if (t === e) {
            W = null;
            break
        }
        var n = t.sibling;
        if (n !== null) {
            n.return = t.return,
                W = n;
            break
        }
        W = t.return
    }
}
function Ax(e) {
    for (; W !== null;) {
        var t = W;
        try {
            switch (t.tag) {
                case 0:
                case 11:
                case 15:
                    var n = t.return;
                    try {
                        Jc(4, t)
                    } catch (l) {
                        Ke(t, n, l)
                    }
                    break;
                case 1:
                    var r = t.stateNode;
                    if (typeof r.componentDidMount == "function") {
                        var i = t.return;
                        try {
                            r.componentDidMount()
                        } catch (l) {
                            Ke(t, i, l)
                        }
                    }
                    var o = t.return;
                    try {
                        cp(t)
                    } catch (l) {
                        Ke(t, o, l)
                    }
                    break;
                case 5:
                    var s = t.return;
                    try {
                        cp(t)
                    } catch (l) {
                        Ke(t, s, l)
                    }
            }
        } catch (l) {
            Ke(t, t.return, l)
        }
        if (t === e) {
            W = null;
            break
        }
        var a = t.sibling;
        if (a !== null) {
            a.return = t.return,
                W = a;
            break
        }
        W = t.return
    }
}
var gM = Math.ceil
    , $c = Vr.ReactCurrentDispatcher
    , Yp = Vr.ReactCurrentOwner
    , Rn = Vr.ReactCurrentBatchConfig
    , xe = 0
    , mt = null
    , ot = null
    , kt = 0
    , rn = 0
    , Vo = di(0)
    , ut = 0
    , ka = null
    , $i = 0
    , eu = 0
    , Kp = 0
    , oa = null
    , Gt = null
    , Qp = 0
    , Xo = 1 / 0
    , Rr = null
    , Nc = !1
    , dp = null
    , si = null
    , uc = !1
    , ei = null
    , jc = 0
    , sa = 0
    , hp = null
    , yc = -1
    , bc = 0;
function Bt() {
    return 6 & xe ? nt() : yc !== -1 ? yc : yc = nt()
}
function ai(e) {
    return 1 & e.mode ? 2 & xe && kt !== 0 ? kt & -kt : JO.transition !== null ? (bc === 0 && (bc = fw()),
        bc) : (e = Te,
            e !== 0 || (e = I.event,
                e = e === void 0 ? 16 : yw(e.type)),
            e) : 1
}
function $n(e, t, n, r) {
    if (50 < sa)
        throw sa = 0,
        hp = null,
        Error(M(185));
    Ca(e, n, r),
        2 & xe && e === mt || (e === mt && (!(2 & xe) && (eu |= n),
            ut === 4 && Zr(e, kt)),
            Kt(e, r),
            n === 1 && xe === 0 && !(1 & t.mode) && (Xo = nt() + 500,
                Kc && hi()))
}
function Kt(e, t) {
    var n = e.callbackNode;
    tO(e, t);
    var r = Tc(e, e === mt ? kt : 0);
    if (r === 0)
        n !== null && Wb(n),
            e.callbackNode = null,
            e.callbackPriority = 0;
    else if (t = r & -r,
        e.callbackPriority !== t) {
        if (n != null && Wb(n),
            t === 1)
            e.tag === 0 ? ZO(Dx.bind(null, e)) : Dw(Dx.bind(null, e)),
                XO(function () {
                    !(6 & xe) && hi()
                }),
                n = null;
        else {
            switch (dw(r)) {
                case 1:
                    n = kp;
                    break;
                case 4:
                    n = cw;
                    break;
                case 16:
                    n = Cc;
                    break;
                case 536870912:
                    n = uw;
                    break;
                default:
                    n = Cc
            }
            n = DS(n, _S.bind(null, e))
        }
        e.callbackPriority = t,
            e.callbackNode = n
    }
}
function _S(e, t) {
    if (yc = -1,
        bc = 0,
        6 & xe)
        throw Error(M(327));
    var n = e.callbackNode;
    if (No() && e.callbackNode !== n)
        return null;
    var r = Tc(e, e === mt ? kt : 0);
    if (r === 0)
        return null;
    if (30 & r || r & e.expiredLanes || t)
        t = Hc(e, r);
    else {
        t = r;
        var i = xe;
        xe |= 2;
        var o = OS();
        mt === e && kt === t || (Rr = null,
            Xo = nt() + 500,
            Vi(e, t));
        do
            try {
                bM();
                break
            } catch (a) {
                IS(e, a)
            }
        while (1);
        Ap(),
            $c.current = o,
            xe = i,
            ot !== null ? t = 0 : (mt = null,
                kt = 0,
                t = ut)
    }
    if (t !== 0) {
        if (t === 2 && (i = Nh(e),
            i !== 0 && (r = i,
                t = pp(e, i))),
            t === 1)
            throw n = ka,
            Vi(e, 0),
            Zr(e, r),
            Kt(e, nt()),
            n;
        if (t === 6)
            Zr(e, r);
        else {
            if (i = e.current.alternate,
                !(30 & r) && !vM(i) && (t = Hc(e, r),
                    t === 2 && (o = Nh(e),
                        o !== 0 && (r = o,
                            t = pp(e, o))),
                    t === 1))
                throw n = ka,
                Vi(e, 0),
                Zr(e, r),
                Kt(e, nt()),
                n;
            switch (e.finishedWork = i,
            e.finishedLanes = r,
            t) {
                case 0:
                case 1:
                    throw Error(M(345));
                case 2:
                    Ii(e, Gt, Rr);
                    break;
                case 3:
                    if (Zr(e, r),
                        (130023424 & r) === r && (t = Qp + 500 - nt(),
                            10 < t)) {
                        if (Tc(e, 0) !== 0)
                            break;
                        if (i = e.suspendedLanes,
                            (i & r) !== r) {
                            Bt(),
                                e.pingedLanes |= e.suspendedLanes & i;
                            break
                        }
                        e.timeoutHandle = Yh(Ii.bind(null, e, Gt, Rr), t);
                        break
                    }
                    Ii(e, Gt, Rr);
                    break;
                case 4:
                    if (Zr(e, r),
                        (4194240 & r) === r)
                        break;
                    for (t = e.eventTimes,
                        i = -1; 0 < r;) {
                        var s = 31 - Bn(r);
                        o = 1 << s,
                            s = t[s],
                            s > i && (i = s),
                            r &= ~o
                    }
                    if (r = i,
                        r = nt() - r,
                        r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * gM(r / 1960)) - r,
                        10 < r) {
                        e.timeoutHandle = Yh(Ii.bind(null, e, Gt, Rr), r);
                        break
                    }
                    Ii(e, Gt, Rr);
                    break;
                case 5:
                    Ii(e, Gt, Rr);
                    break;
                default:
                    throw Error(M(329))
            }
        }
    }
    return Kt(e, nt()),
        e.callbackNode === n ? _S.bind(null, e) : null
}
function pp(e, t) {
    var n = oa;
    return e.current.memoizedState.isDehydrated && (Vi(e, t).flags |= 256),
        e = Hc(e, t),
        e !== 2 && (t = Gt,
            Gt = n,
            t !== null && mp(t)),
        e
}
function mp(e) {
    Gt === null ? Gt = e : Gt.push.apply(Gt, e)
}
function vM(e) {
    for (var t = e; ;) {
        if (16384 & t.flags) {
            var n = t.updateQueue;
            if (n !== null && (n = n.stores,
                n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r]
                        , o = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!Nn(o(), i))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = t.child,
            16384 & t.subtreeFlags && n !== null)
            n.return = t,
                t = n;
        else {
            if (t === e)
                break;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e)
                    return !0;
                t = t.return
            }
            t.sibling.return = t.return,
                t = t.sibling
        }
    }
    return !0
}
function Zr(e, t) {
    for (t &= ~Kp,
        t &= ~eu,
        e.suspendedLanes |= t,
        e.pingedLanes &= ~t,
        e = e.expirationTimes; 0 < t;) {
        var n = 31 - Bn(t)
            , r = 1 << n;
        e[n] = -1,
            t &= ~r
    }
}
function Dx(e) {
    if (6 & xe)
        throw Error(M(327));
    No();
    var t = Tc(e, 0);
    if (!(1 & t))
        return Kt(e, nt()),
            null;
    var n = Hc(e, t);
    if (e.tag !== 0 && n === 2) {
        var r = Nh(e);
        r !== 0 && (t = r,
            n = pp(e, r))
    }
    if (n === 1)
        throw n = ka,
        Vi(e, 0),
        Zr(e, t),
        Kt(e, nt()),
        n;
    if (n === 6)
        throw Error(M(345));
    return e.finishedWork = e.current.alternate,
        e.finishedLanes = t,
        Ii(e, Gt, Rr),
        Kt(e, nt()),
        null
}
function Zp(e, t) {
    var n = xe;
    xe |= 1;
    try {
        return e(t)
    } finally {
        xe = n,
            xe === 0 && (Xo = nt() + 500,
                Kc && hi())
    }
}
function Ni(e) {
    ei !== null && ei.tag === 0 && !(6 & xe) && No();
    var t = xe;
    xe |= 1;
    var n = Rn.transition
        , r = Te;
    try {
        if (Rn.transition = null,
            Te = 1,
            e)
            return e()
    } finally {
        Te = r,
            Rn.transition = n,
            xe = t,
            !(6 & xe) && hi()
    }
}
function Jp() {
    rn = Vo.current,
        Ae(Vo)
}
function Vi(e, t) {
    e.finishedWork = null,
        e.finishedLanes = 0;
    var n = e.timeoutHandle;
    if (n !== -1 && (e.timeoutHandle = -1,
        qO(n)),
        ot !== null)
        for (n = ot.return; n !== null;) {
            var r = n;
            switch (Mp(r),
            r.tag) {
                case 1:
                    r = r.type.childContextTypes,
                        r != null && _c();
                    break;
                case 3:
                    Go(),
                        Ae(Xt),
                        Ae(Mt),
                        jp();
                    break;
                case 5:
                    Np(r);
                    break;
                case 4:
                    Go();
                    break;
                case 13:
                    Ae(He);
                    break;
                case 19:
                    Ae(He);
                    break;
                case 10:
                    Dp(r.type._context);
                    break;
                case 22:
                case 23:
                    Jp()
            }
            n = n.return
        }
    if (mt = e,
        ot = e = li(e.current, null),
        kt = rn = t,
        ut = 0,
        ka = null,
        Kp = eu = $i = 0,
        Gt = oa = null,
        Mi !== null) {
        for (t = 0; t < Mi.length; t++)
            if (n = Mi[t],
                r = n.interleaved,
                r !== null) {
                n.interleaved = null;
                var i = r.next
                    , o = n.pending;
                if (o !== null) {
                    var s = o.next;
                    o.next = i,
                        r.next = s
                }
                n.pending = r
            }
        Mi = null
    }
    return e
}
function IS(e, t) {
    do {
        var n = ot;
        try {
            if (Ap(),
                mc.current = Bc,
                zc) {
                for (var r = We.memoizedState; r !== null;) {
                    var i = r.queue;
                    i !== null && (i.pending = null),
                        r = r.next
                }
                zc = !1
            }
            if (Bi = 0,
                pt = ct = We = null,
                ra = !1,
                xa = 0,
                Yp.current = null,
                n === null || n.return === null) {
                ut = 1,
                    ka = t,
                    ot = null;
                break
            }
            e: {
                var o = e
                    , s = n.return
                    , a = n
                    , l = t;
                if (t = kt,
                    a.flags |= 32768,
                    l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                        , u = a
                        , f = u.tag;
                    if (!(1 & u.mode) && (f === 0 || f === 11 || f === 15)) {
                        var d = u.alternate;
                        d ? (u.updateQueue = d.updateQueue,
                            u.memoizedState = d.memoizedState,
                            u.lanes = d.lanes) : (u.updateQueue = null,
                                u.memoizedState = null)
                    }
                    var p = Cx(s);
                    if (p !== null) {
                        p.flags &= -257,
                            Tx(p, s, a, o, t),
                            1 & p.mode && kx(o, c, t),
                            t = p,
                            l = c;
                        var v = t.updateQueue;
                        if (v === null) {
                            var g = new Set;
                            g.add(l),
                                t.updateQueue = g
                        } else
                            v.add(l);
                        break e
                    }
                    if (!(1 & t)) {
                        kx(o, c, t),
                            em();
                        break e
                    }
                    l = Error(M(426))
                } else if ($e && 1 & a.mode) {
                    var b = Cx(s);
                    if (b !== null) {
                        !(65536 & b.flags) && (b.flags |= 256),
                            Tx(b, s, a, o, t),
                            Lp(qo(l, a));
                        break e
                    }
                }
                o = l = qo(l, a),
                    ut !== 4 && (ut = 2),
                    oa === null ? oa = [o] : oa.push(o),
                    o = s;
                do {
                    switch (o.tag) {
                        case 3:
                            o.flags |= 65536,
                                t &= -t,
                                o.lanes |= t;
                            var m = hS(o, l, t);
                            gx(o, m);
                            break e;
                        case 1:
                            a = l;
                            var h = o.type
                                , y = o.stateNode;
                            if (!(128 & o.flags) && (typeof h.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (si === null || !si.has(y)))) {
                                o.flags |= 65536,
                                    t &= -t,
                                    o.lanes |= t;
                                var w = pS(o, a, t);
                                gx(o, w);
                                break e
                            }
                    }
                    o = o.return
                } while (o !== null)
            }
            LS(n)
        } catch (C) {
            t = C,
                ot === n && n !== null && (ot = n = n.return);
            continue
        }
        break
    } while (1)
}
function OS() {
    var e = $c.current;
    return $c.current = Bc,
        e === null ? Bc : e
}
function em() {
    ut !== 0 && ut !== 3 && ut !== 2 || (ut = 4),
        mt === null || !(268435455 & $i) && !(268435455 & eu) || Zr(mt, kt)
}
function Hc(e, t) {
    var n = xe;
    xe |= 2;
    var r = OS();
    mt === e && kt === t || (Rr = null,
        Vi(e, t));
    do
        try {
            yM();
            break
        } catch (i) {
            IS(e, i)
        }
    while (1);
    if (Ap(),
        xe = n,
        $c.current = r,
        ot !== null)
        throw Error(M(261));
    return mt = null,
        kt = 0,
        ut
}
function yM() {
    for (; ot !== null;)
        MS(ot)
}
function bM() {
    for (; ot !== null && !G2();)
        MS(ot)
}
function MS(e) {
    var t = AS(e.alternate, e, rn);
    e.memoizedProps = e.pendingProps,
        t === null ? LS(e) : ot = t,
        Yp.current = null
}
function LS(e) {
    var t = e;
    do {
        var n = t.alternate;
        if (e = t.return,
            32768 & t.flags) {
            if (n = dM(n, t),
                n !== null) {
                n.flags &= 32767,
                    ot = n;
                return
            }
            if (e === null) {
                ut = 6,
                    ot = null;
                return
            }
            e.flags |= 32768,
                e.subtreeFlags = 0,
                e.deletions = null
        } else if (n = fM(n, t, rn),
            n !== null) {
            ot = n;
            return
        }
        if (t = t.sibling,
            t !== null) {
            ot = t;
            return
        }
        ot = t = e
    } while (t !== null);
    ut === 0 && (ut = 5)
}
function Ii(e, t, n) {
    var r = Te
        , i = Rn.transition;
    try {
        Rn.transition = null,
            Te = 1,
            xM(e, t, n, r)
    } finally {
        Rn.transition = i,
            Te = r
    }
    return null
}
function xM(e, t, n, r) {
    do
        No();
    while (ei !== null);
    if (6 & xe)
        throw Error(M(327));
    n = e.finishedWork;
    var i = e.finishedLanes;
    if (n === null)
        return null;
    if (e.finishedWork = null,
        e.finishedLanes = 0,
        n === e.current)
        throw Error(M(177));
    e.callbackNode = null,
        e.callbackPriority = 0;
    var o = n.lanes | n.childLanes;
    if (nO(e, o),
        e === mt && (ot = mt = null,
            kt = 0),
        !(2064 & n.subtreeFlags) && !(2064 & n.flags) || uc || (uc = !0,
            DS(Cc, function () {
                return No(),
                    null
            })),
        o = (15990 & n.flags) !== 0,
        15990 & n.subtreeFlags || o) {
        o = Rn.transition,
            Rn.transition = null;
        var s = Te;
        Te = 1;
        var a = xe;
        xe |= 4,
            Yp.current = null,
            pM(e, n),
            FS(n, e),
            jO(qh),
            Rc = !!Gh,
            qh = Gh = null,
            e.current = n,
            mM(n, e, i),
            q2(),
            xe = a,
            Te = s,
            Rn.transition = o
    } else
        e.current = n;
    if (uc && (uc = !1,
        ei = e,
        jc = i),
        o = e.pendingLanes,
        o === 0 && (si = null),
        K2(n.stateNode, r),
        Kt(e, nt()),
        t !== null)
        for (r = e.onRecoverableError,
            n = 0; n < t.length; n++)
            i = t[n],
                r(i.value, {
                    componentStack: i.stack,
                    digest: i.digest
                });
    if (Nc)
        throw Nc = !1,
        e = dp,
        dp = null,
        e;
    return 1 & jc && e.tag !== 0 && No(),
        o = e.pendingLanes,
        1 & o ? e === hp ? sa++ : (sa = 0,
            hp = e) : sa = 0,
        hi(),
        null
}
function No() {
    if (ei !== null) {
        var e = dw(jc)
            , t = Rn.transition
            , n = Te;
        try {
            if (Rn.transition = null,
                Te = 16 > e ? 16 : e,
                ei === null)
                var r = !1;
            else {
                if (e = ei,
                    ei = null,
                    jc = 0,
                    6 & xe)
                    throw Error(M(331));
                var i = xe;
                for (xe |= 4,
                    W = e.current; W !== null;) {
                    var o = W
                        , s = o.child;
                    if (16 & W.flags) {
                        var a = o.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (W = c; W !== null;) {
                                    var u = W;
                                    switch (u.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            ia(8, u, o)
                                    }
                                    var f = u.child;
                                    if (f !== null)
                                        f.return = u,
                                            W = f;
                                    else
                                        for (; W !== null;) {
                                            u = W;
                                            var d = u.sibling
                                                , p = u.return;
                                            if (TS(u),
                                                u === c) {
                                                W = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = p,
                                                    W = d;
                                                break
                                            }
                                            W = p
                                        }
                                }
                            }
                            var v = o.alternate;
                            if (v !== null) {
                                var g = v.child;
                                if (g !== null) {
                                    v.child = null;
                                    do {
                                        var b = g.sibling;
                                        g.sibling = null,
                                            g = b
                                    } while (g !== null)
                                }
                            }
                            W = o
                        }
                    }
                    if (2064 & o.subtreeFlags && s !== null)
                        s.return = o,
                            W = s;
                    else
                        e: for (; W !== null;) {
                            if (o = W,
                                2048 & o.flags)
                                switch (o.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ia(9, o, o.return)
                                }
                            var m = o.sibling;
                            if (m !== null) {
                                m.return = o.return,
                                    W = m;
                                break e
                            }
                            W = o.return
                        }
                }
                var h = e.current;
                for (W = h; W !== null;) {
                    s = W;
                    var y = s.child;
                    if (2064 & s.subtreeFlags && y !== null)
                        y.return = s,
                            W = y;
                    else
                        e: for (s = h; W !== null;) {
                            if (a = W,
                                2048 & a.flags)
                                try {
                                    switch (a.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Jc(9, a)
                                    }
                                } catch (C) {
                                    Ke(a, a.return, C)
                                }
                            if (a === s) {
                                W = null;
                                break e
                            }
                            var w = a.sibling;
                            if (w !== null) {
                                w.return = a.return,
                                    W = w;
                                break e
                            }
                            W = a.return
                        }
                }
                if (xe = i,
                    hi(),
                    lr && typeof lr.onPostCommitFiberRoot == "function")
                    try {
                        lr.onPostCommitFiberRoot(Uc, e)
                    } catch { }
                r = !0
            }
            return r
        } finally {
            Te = n,
                Rn.transition = t
        }
    }
    return !1
}
function zx(e, t, n) {
    t = qo(n, t),
        t = hS(e, t, 1),
        e = oi(e, t, 1),
        t = Bt(),
        e !== null && (Ca(e, 1, t),
            Kt(e, t))
}
function Ke(e, t, n) {
    if (e.tag === 3)
        zx(e, e, n);
    else
        for (; t !== null;) {
            if (t.tag === 3) {
                zx(t, e, n);
                break
            }
            if (t.tag === 1) {
                var r = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (si === null || !si.has(r))) {
                    e = qo(n, e),
                        e = pS(t, e, 1),
                        t = oi(t, e, 1),
                        e = Bt(),
                        t !== null && (Ca(t, 1, e),
                            Kt(t, e));
                    break
                }
            }
            t = t.return
        }
}
function wM(e, t, n) {
    var r = e.pingCache;
    r !== null && r.delete(t),
        t = Bt(),
        e.pingedLanes |= e.suspendedLanes & n,
        mt === e && (kt & n) === n && (ut === 4 || ut === 3 && (130023424 & kt) === kt && 500 > nt() - Qp ? Vi(e, 0) : Kp |= n),
        Kt(e, t)
}
function VS(e, t) {
    t === 0 && (1 & e.mode ? (t = Kl,
        Kl <<= 1,
        !(130023424 & Kl) && (Kl = 4194304)) : t = 1);
    var n = Bt();
    e = Mr(e, t),
        e !== null && (Ca(e, t, n),
            Kt(e, n))
}
function SM(e) {
    var t = e.memoizedState
        , n = 0;
    t !== null && (n = t.retryLane),
        VS(e, n)
}
function kM(e, t) {
    var n = 0;
    switch (e.tag) {
        case 13:
            var r = e.stateNode
                , i = e.memoizedState;
            i !== null && (n = i.retryLane);
            break;
        case 19:
            r = e.stateNode;
            break;
        default:
            throw Error(M(314))
    }
    r !== null && r.delete(t),
        VS(e, n)
}
var AS;
AS = function (e, t, n) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Xt.current)
            qt = !0;
        else {
            if (!(e.lanes & n) && !(128 & t.flags))
                return qt = !1,
                    uM(e, t, n);
            qt = (131072 & e.flags) !== 0
        }
    else
        qt = !1,
            $e && 1048576 & t.flags && zw(t, Mc, t.index);
    switch (t.lanes = 0,
    t.tag) {
        case 2:
            var r = t.type;
            vc(e, t),
                e = t.pendingProps;
            var i = Ho(t, Mt.current);
            $o(t, n),
                i = Wp(null, t, r, e, i, n);
            var o = Up();
            return t.flags |= 1,
                typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1,
                    t.memoizedState = null,
                    t.updateQueue = null,
                    Yt(r) ? (o = !0,
                        Ic(t)) : o = !1,
                    t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
                    Bp(t),
                    i.updater = Qc,
                    t.stateNode = i,
                    i._reactInternals = t,
                    np(t, r, e, n),
                    t = op(null, t, r, !0, o, n)) : (t.tag = 0,
                        $e && o && Op(t),
                        zt(null, t, i, n),
                        t = t.child),
                t;
        case 16:
            r = t.elementType;
            e: {
                switch (vc(e, t),
                e = t.pendingProps,
                i = r._init,
                r = i(r._payload),
                t.type = r,
                i = t.tag = TM(r),
                e = An(r, e),
                i) {
                    case 0:
                        t = ip(null, t, r, e, n);
                        break e;
                    case 1:
                        t = Fx(null, t, r, e, n);
                        break e;
                    case 11:
                        t = Rx(null, t, r, e, n);
                        break e;
                    case 14:
                        t = Ex(null, t, r, An(r.type, e), n);
                        break e
                }
                throw Error(M(306, r, ""))
            }
            return t;
        case 0:
            return r = t.type,
                i = t.pendingProps,
                i = t.elementType === r ? i : An(r, i),
                ip(e, t, r, i, n);
        case 1:
            return r = t.type,
                i = t.pendingProps,
                i = t.elementType === r ? i : An(r, i),
                Fx(e, t, r, i, n);
        case 3:
            e: {
                if (yS(t),
                    e === null)
                    throw Error(M(387));
                r = t.pendingProps,
                    o = t.memoizedState,
                    i = o.element,
                    jw(e, t),
                    Ac(t, r, null, n);
                var s = t.memoizedState;
                if (r = s.element,
                    o.isDehydrated) {
                    if (o = {
                        element: r,
                        isDehydrated: !1,
                        cache: s.cache,
                        pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                        transitions: s.transitions
                    },
                        t.updateQueue.baseState = o,
                        t.memoizedState = o,
                        256 & t.flags) {
                        i = qo(Error(M(423)), t),
                            t = Px(e, t, r, n, i);
                        break e
                    }
                    if (r !== i) {
                        i = qo(Error(M(424)), t),
                            t = Px(e, t, r, n, i);
                        break e
                    }
                    for (on = ii(t.stateNode.containerInfo.firstChild),
                        sn = t,
                        $e = !0,
                        zn = null,
                        n = Gw(t, null, r, n),
                        t.child = n; n;)
                        n.flags = -3 & n.flags | 4096,
                            n = n.sibling
                } else {
                    if (Wo(),
                        r === i) {
                        t = Lr(e, t, n);
                        break e
                    }
                    zt(e, t, r, n)
                }
                t = t.child
            }
            return t;
        case 5:
            return qw(t),
                e === null && Jh(t),
                r = t.type,
                i = t.pendingProps,
                o = e !== null ? e.memoizedProps : null,
                s = i.children,
                Xh(r, i) ? s = null : o !== null && Xh(r, o) && (t.flags |= 32),
                vS(e, t),
                zt(e, t, s, n),
                t.child;
        case 6:
            return e === null && Jh(t),
                null;
        case 13:
            return bS(e, t, n);
        case 4:
            return $p(t, t.stateNode.containerInfo),
                r = t.pendingProps,
                e === null ? t.child = Uo(t, null, r, n) : zt(e, t, r, n),
                t.child;
        case 11:
            return r = t.type,
                i = t.pendingProps,
                i = t.elementType === r ? i : An(r, i),
                Rx(e, t, r, i, n);
        case 7:
            return zt(e, t, t.pendingProps, n),
                t.child;
        case 8:
            return zt(e, t, t.pendingProps.children, n),
                t.child;
        case 12:
            return zt(e, t, t.pendingProps.children, n),
                t.child;
        case 10:
            e: {
                if (r = t.type._context,
                    i = t.pendingProps,
                    o = t.memoizedProps,
                    s = i.value,
                    Oe(Lc, r._currentValue),
                    r._currentValue = s,
                    o !== null)
                    if (Nn(o.value, s)) {
                        if (o.children === i.children && !Xt.current) {
                            t = Lr(e, t, n);
                            break e
                        }
                    } else
                        for (o = t.child,
                            o !== null && (o.return = t); o !== null;) {
                            var a = o.dependencies;
                            if (a !== null) {
                                s = o.child;
                                for (var l = a.firstContext; l !== null;) {
                                    if (l.context === r) {
                                        if (o.tag === 1) {
                                            l = _r(-1, n & -n),
                                                l.tag = 2;
                                            var c = o.updateQueue;
                                            if (c !== null) {
                                                c = c.shared;
                                                var u = c.pending;
                                                u === null ? l.next = l : (l.next = u.next,
                                                    u.next = l),
                                                    c.pending = l
                                            }
                                        }
                                        o.lanes |= n,
                                            l = o.alternate,
                                            l !== null && (l.lanes |= n),
                                            ep(o.return, n, t),
                                            a.lanes |= n;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (o.tag === 10)
                                s = o.type === t.type ? null : o.child;
                            else if (o.tag === 18) {
                                if (s = o.return,
                                    s === null)
                                    throw Error(M(341));
                                s.lanes |= n,
                                    a = s.alternate,
                                    a !== null && (a.lanes |= n),
                                    ep(s, n, t),
                                    s = o.sibling
                            } else
                                s = o.child;
                            if (s !== null)
                                s.return = o;
                            else
                                for (s = o; s !== null;) {
                                    if (s === t) {
                                        s = null;
                                        break
                                    }
                                    if (o = s.sibling,
                                        o !== null) {
                                        o.return = s.return,
                                            s = o;
                                        break
                                    }
                                    s = s.return
                                }
                            o = s
                        }
                zt(e, t, i.children, n),
                    t = t.child
            }
            return t;
        case 9:
            return i = t.type,
                r = t.pendingProps.children,
                $o(t, n),
                i = En(i),
                r = r(i),
                t.flags |= 1,
                zt(e, t, r, n),
                t.child;
        case 14:
            return r = t.type,
                i = An(r, t.pendingProps),
                i = An(r.type, i),
                Ex(e, t, r, i, n);
        case 15:
            return mS(e, t, t.type, t.pendingProps, n);
        case 17:
            return r = t.type,
                i = t.pendingProps,
                i = t.elementType === r ? i : An(r, i),
                vc(e, t),
                t.tag = 1,
                Yt(r) ? (e = !0,
                    Ic(t)) : e = !1,
                $o(t, n),
                Ww(t, r, i),
                np(t, r, i, n),
                op(null, t, r, !0, e, n);
        case 19:
            return xS(e, t, n);
        case 22:
            return gS(e, t, n)
    }
    throw Error(M(156, t.tag))
}
    ;
function DS(e, t) {
    return lw(e, t)
}
function CM(e, t, n, r) {
    this.tag = e,
        this.key = n,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = t,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = r,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
}
function Tn(e, t, n, r) {
    return new CM(e, t, n, r)
}
function tm(e) {
    return e = e.prototype,
        !(!e || !e.isReactComponent)
}
function TM(e) {
    if (typeof e == "function")
        return tm(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof,
            e === xp)
            return 11;
        if (e === wp)
            return 14
    }
    return 2
}
function li(e, t) {
    var n = e.alternate;
    return n === null ? (n = Tn(e.tag, t, e.key, e.mode),
        n.elementType = e.elementType,
        n.type = e.type,
        n.stateNode = e.stateNode,
        n.alternate = e,
        e.alternate = n) : (n.pendingProps = t,
            n.type = e.type,
            n.flags = 0,
            n.subtreeFlags = 0,
            n.deletions = null),
        n.flags = 14680064 & e.flags,
        n.childLanes = e.childLanes,
        n.lanes = e.lanes,
        n.child = e.child,
        n.memoizedProps = e.memoizedProps,
        n.memoizedState = e.memoizedState,
        n.updateQueue = e.updateQueue,
        t = e.dependencies,
        n.dependencies = t === null ? null : {
            lanes: t.lanes,
            firstContext: t.firstContext
        },
        n.sibling = e.sibling,
        n.index = e.index,
        n.ref = e.ref,
        n
}
function xc(e, t, n, r, i, o) {
    var s = 2;
    if (r = e,
        typeof e == "function")
        tm(e) && (s = 1);
    else if (typeof e == "string")
        s = 5;
    else
        e: switch (e) {
            case To:
                return Ai(n.children, i, o, t);
            case bp:
                s = 8,
                    i |= 8;
                break;
            case Rh:
                return e = Tn(12, n, t, 2 | i),
                    e.elementType = Rh,
                    e.lanes = o,
                    e;
            case Eh:
                return e = Tn(13, n, t, i),
                    e.elementType = Eh,
                    e.lanes = o,
                    e;
            case Fh:
                return e = Tn(19, n, t, i),
                    e.elementType = Fh,
                    e.lanes = o,
                    e;
            case Ux:
                return tu(n, i, o, t);
            default:
                if (typeof e == "object" && e !== null)
                    switch (e.$$typeof) {
                        case Hx:
                            s = 10;
                            break e;
                        case Wx:
                            s = 9;
                            break e;
                        case xp:
                            s = 11;
                            break e;
                        case wp:
                            s = 14;
                            break e;
                        case Yr:
                            s = 16,
                                r = null;
                            break e
                    }
                throw Error(M(130, e == null ? e : typeof e, ""))
        }
    return t = Tn(s, n, t, i),
        t.elementType = e,
        t.type = r,
        t.lanes = o,
        t
}
function Ai(e, t, n, r) {
    return e = Tn(7, e, r, t),
        e.lanes = n,
        e
}
function tu(e, t, n, r) {
    return e = Tn(22, e, r, t),
        e.elementType = Ux,
        e.lanes = n,
        e.stateNode = {
            isHidden: !1
        },
        e
}
function kh(e, t, n) {
    return e = Tn(6, e, null, t),
        e.lanes = n,
        e
}
function Ch(e, t, n) {
    return t = Tn(4, e.children !== null ? e.children : [], e.key, t),
        t.lanes = n,
        t.stateNode = {
            containerInfo: e.containerInfo,
            pendingChildren: null,
            implementation: e.implementation
        },
        t
}
function RM(e, t, n, r, i) {
    this.tag = t,
        this.containerInfo = e,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = ah(0),
        this.expirationTimes = ah(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = ah(0),
        this.identifierPrefix = r,
        this.onRecoverableError = i,
        this.mutableSourceEagerHydrationData = null
}
function nm(e, t, n, r, i, o, s, a, l) {
    return e = new RM(e, t, n, a, l),
        t === 1 ? (t = 1,
            o === !0 && (t |= 8)) : t = 0,
        o = Tn(3, null, null, t),
        e.current = o,
        o.stateNode = e,
        o.memoizedState = {
            element: r,
            isDehydrated: n,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        Bp(o),
        e
}
function EM(e, t, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Co,
        key: r == null ? null : "" + r,
        children: e,
        containerInfo: t,
        implementation: n
    }
}
function zS(e) {
    if (!e)
        return ui;
    e = e._reactInternals;
    e: {
        if (Hi(e) !== e || e.tag !== 1)
            throw Error(M(170));
        var t = e;
        do {
            switch (t.tag) {
                case 3:
                    t = t.stateNode.context;
                    break e;
                case 1:
                    if (Yt(t.type)) {
                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            t = t.return
        } while (t !== null);
        throw Error(M(171))
    }
    if (e.tag === 1) {
        var n = e.type;
        if (Yt(n))
            return Aw(e, n, t)
    }
    return t
}
function BS(e, t, n, r, i, o, s, a, l) {
    return e = nm(n, r, !0, e, i, o, s, a, l),
        e.context = zS(null),
        n = e.current,
        r = Bt(),
        i = ai(n),
        o = _r(r, i),
        o.callback = t ?? null,
        oi(n, o, i),
        e.current.lanes = i,
        Ca(e, i, r),
        Kt(e, r),
        e
}
function nu(e, t, n, r) {
    var i = t.current
        , o = Bt()
        , s = ai(i);
    return n = zS(n),
        t.context === null ? t.context = n : t.pendingContext = n,
        t = _r(o, s),
        t.payload = {
            element: e
        },
        r = r === void 0 ? null : r,
        r !== null && (t.callback = r),
        e = oi(i, t, s),
        e !== null && ($n(e, i, s, o),
            pc(e, i, s)),
        s
}
function Wc(e) {
    if (e = e.current,
        !e.child)
        return null;
    switch (e.child.tag) {
        case 5:
            return e.child.stateNode;
        default:
            return e.child.stateNode
    }
}
function Bx(e, t) {
    if (e = e.memoizedState,
        e !== null && e.dehydrated !== null) {
        var n = e.retryLane;
        e.retryLane = n !== 0 && n < t ? n : t
    }
}
function rm(e, t) {
    Bx(e, t),
        (e = e.alternate) && Bx(e, t)
}
function FM() {
    return null
}
var $S = typeof reportError == "function" ? reportError : function (e) {
    console.error(e)
}
    ;
function im(e) {
    this._internalRoot = e
}
ru.prototype.render = im.prototype.render = function (e) {
    var t = this._internalRoot;
    if (t === null)
        throw Error(M(409));
    nu(e, t, null, null)
}
    ;
ru.prototype.unmount = im.prototype.unmount = function () {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        Ni(function () {
            nu(null, e, null, null)
        }),
            t[Or] = null
    }
}
    ;
function ru(e) {
    this._internalRoot = e
}
ru.prototype.unstable_scheduleHydration = function (e) {
    if (e) {
        var t = mw();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var n = 0; n < Qr.length && t !== 0 && t < Qr[n].priority; n++)
            ;
        Qr.splice(n, 0, e),
            n === 0 && vw(e)
    }
}
    ;
function om(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function iu(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function $x() { }
function PM(e, t, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var o = r;
            r = function () {
                var c = Wc(s);
                o.call(c)
            }
        }
        var s = BS(t, r, e, 0, null, !1, !1, "", $x);
        return e._reactRootContainer = s,
            e[Or] = s.current,
            ma(e.nodeType === 8 ? e.parentNode : e),
            Ni(),
            s
    }
    for (; i = e.lastChild;)
        e.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function () {
            var c = Wc(l);
            a.call(c)
        }
    }
    var l = nm(e, 0, !1, null, null, !1, !1, "", $x);
    return e._reactRootContainer = l,
        e[Or] = l.current,
        ma(e.nodeType === 8 ? e.parentNode : e),
        Ni(function () {
            nu(t, l, n, r)
        }),
        l
}
function ou(e, t, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
        var s = o;
        if (typeof i == "function") {
            var a = i;
            i = function () {
                var l = Wc(s);
                a.call(l)
            }
        }
        nu(t, s, e, i)
    } else
        s = PM(n, t, e, i, r);
    return Wc(s)
}
hw = function (e) {
    switch (e.tag) {
        case 3:
            var t = e.stateNode;
            if (t.current.memoizedState.isDehydrated) {
                var n = Ks(t.pendingLanes);
                n !== 0 && (Cp(t, 1 | n),
                    Kt(t, nt()),
                    !(6 & xe) && (Xo = nt() + 500,
                        hi()))
            }
            break;
        case 13:
            Ni(function () {
                var r = Mr(e, 1);
                if (r !== null) {
                    var i = Bt();
                    $n(r, e, 1, i)
                }
            }),
                rm(e, 1)
    }
}
    ;
Tp = function (e) {
    if (e.tag === 13) {
        var t = Mr(e, 134217728);
        if (t !== null) {
            var n = Bt();
            $n(t, e, 134217728, n)
        }
        rm(e, 134217728)
    }
}
    ;
pw = function (e) {
    if (e.tag === 13) {
        var t = ai(e)
            , n = Mr(e, t);
        if (n !== null) {
            var r = Bt();
            $n(n, e, t, r)
        }
        rm(e, t)
    }
}
    ;
mw = function () {
    return Te
}
    ;
gw = function (e, t) {
    var n = Te;
    try {
        return Te = e,
            t()
    } finally {
        Te = n
    }
}
    ;
zh = function (e, t, n) {
    switch (t) {
        case "input":
            if (Ih(e, n),
                t = n.name,
                n.type === "radio" && t != null) {
                for (n = e; n.parentNode;)
                    n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
                    t = 0; t < n.length; t++) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                        var i = Yc(r);
                        if (!i)
                            throw Error(M(90));
                        qx(r),
                            Ih(r, i)
                    }
                }
            }
            break;
        case "textarea":
            Yx(e, n);
            break;
        case "select":
            t = n.value,
                t != null && Ao(e, !!n.multiple, t, !1)
    }
}
    ;
nw = Zp;
rw = Ni;
var _M = {
    usingClientEntryPoint: !1,
    Events: [Ra, Po, Yc, ew, tw, Zp]
}
    , Gs = {
        findFiberByHostInstance: Oi,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    }
    , IM = {
        bundleType: Gs.bundleType,
        version: Gs.version,
        rendererPackageName: Gs.rendererPackageName,
        rendererConfig: Gs.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Vr.ReactCurrentDispatcher,
        findHostInstanceByFiber: function (e) {
            return e = sw(e),
                e === null ? null : e.stateNode
        },
        findFiberByHostInstance: Gs.findFiberByHostInstance || FM,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (qs = __REACT_DEVTOOLS_GLOBAL_HOOK__,
    !qs.isDisabled && qs.supportsFiber))
    try {
        Uc = qs.inject(IM),
            lr = qs
    } catch { }
var qs;
ln.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _M;
ln.createPortal = function (e, t) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!om(t))
        throw Error(M(200));
    return EM(e, t, null, n)
}
    ;
ln.createRoot = function (e, t) {
    if (!om(e))
        throw Error(M(299));
    var n = !1
        , r = ""
        , i = $S;
    return t != null && (t.unstable_strictMode === !0 && (n = !0),
        t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
        t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
        t = nm(e, 1, !1, null, null, n, !1, r, i),
        e[Or] = t.current,
        ma(e.nodeType === 8 ? e.parentNode : e),
        new im(t)
}
    ;
ln.findDOMNode = function (e) {
    if (e == null)
        return null;
    if (e.nodeType === 1)
        return e;
    var t = e._reactInternals;
    if (t === void 0)
        throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","),
            Error(M(268, e)));
    return e = sw(t),
        e = e === null ? null : e.stateNode,
        e
}
    ;
ln.flushSync = function (e) {
    return Ni(e)
}
    ;
ln.hydrate = function (e, t, n) {
    if (!iu(t))
        throw Error(M(200));
    return ou(null, e, t, !0, n)
}
    ;
ln.hydrateRoot = function (e, t, n) {
    if (!om(e))
        throw Error(M(405));
    var r = n != null && n.hydratedSources || null
        , i = !1
        , o = ""
        , s = $S;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0),
        n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
        n.onRecoverableError !== void 0 && (s = n.onRecoverableError)),
        t = BS(t, null, e, 1, n ?? null, i, !1, o, s),
        e[Or] = t.current,
        ma(e),
        r)
        for (e = 0; e < r.length; e++)
            n = r[e],
                i = n._getVersion,
                i = i(n._source),
                t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
    return new ru(t)
}
    ;
ln.render = function (e, t, n) {
    if (!iu(t))
        throw Error(M(200));
    return ou(null, e, t, !1, n)
}
    ;
ln.unmountComponentAtNode = function (e) {
    if (!iu(e))
        throw Error(M(40));
    return !!e._reactRootContainer && (Ni(function () {
        ou(null, null, e, !1, function () {
            e._reactRootContainer = null,
                e[Or] = null
        })
    }),
        !0)
}
    ;
ln.unstable_batchedUpdates = Zp;
ln.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
    if (!iu(n))
        throw Error(M(200));
    if (e == null || e._reactInternals === void 0)
        throw Error(M(38));
    return ou(e, t, n, !1, r)
}
    ;
ln.version = "18.2.0-next-9e3b772b8-20220608";
function NS() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function")
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(NS)
        } catch (e) {
            console.error(e)
        }
}
NS();
var un = ln
    , jS = un
    , OM = un.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
    , MM = un.createPortal
    , LM = un.createRoot
    , VM = un.findDOMNode
    , AM = un.flushSync
    , DM = un.hydrate
    , zM = un.hydrateRoot
    , BM = un.render
    , $M = un.unmountComponentAtNode
    , NM = un.unstable_batchedUpdates
    , jM = un.unstable_renderSubtreeIntoContainer
    , HM = un.version;
var UM = vn({
    "../../../node_modules/hsluv/dist/hsluv.cjs"(e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
            e.Hsluv = void 0;
        var t = class {
            constructor() {
                this.hex = "#000000",
                    this.rgb_r = 0,
                    this.rgb_g = 0,
                    this.rgb_b = 0,
                    this.xyz_x = 0,
                    this.xyz_y = 0,
                    this.xyz_z = 0,
                    this.luv_l = 0,
                    this.luv_u = 0,
                    this.luv_v = 0,
                    this.lch_l = 0,
                    this.lch_c = 0,
                    this.lch_h = 0,
                    this.hsluv_h = 0,
                    this.hsluv_s = 0,
                    this.hsluv_l = 0,
                    this.hpluv_h = 0,
                    this.hpluv_p = 0,
                    this.hpluv_l = 0,
                    this.r0s = 0,
                    this.r0i = 0,
                    this.r1s = 0,
                    this.r1i = 0,
                    this.g0s = 0,
                    this.g0i = 0,
                    this.g1s = 0,
                    this.g1i = 0,
                    this.b0s = 0,
                    this.b0i = 0,
                    this.b1s = 0,
                    this.b1i = 0
            }
            static fromLinear(n) {
                return n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055
            }
            static toLinear(n) {
                return n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92
            }
            static yToL(n) {
                return n <= t.epsilon ? n / t.refY * t.kappa : 116 * Math.pow(n / t.refY, 1 / 3) - 16
            }
            static lToY(n) {
                return n <= 8 ? t.refY * n / t.kappa : t.refY * Math.pow((n + 16) / 116, 3)
            }
            static rgbChannelToHex(n) {
                let r = Math.round(n * 255)
                    , i = r % 16
                    , o = (r - i) / 16 | 0;
                return t.hexChars.charAt(o) + t.hexChars.charAt(i)
            }
            static hexToRgbChannel(n, r) {
                let i = t.hexChars.indexOf(n.charAt(r))
                    , o = t.hexChars.indexOf(n.charAt(r + 1));
                return (i * 16 + o) / 255
            }
            static distanceFromOriginAngle(n, r, i) {
                let o = r / (Math.sin(i) - n * Math.cos(i));
                return o < 0 ? 1 / 0 : o
            }
            static distanceFromOrigin(n, r) {
                return Math.abs(r) / Math.sqrt(Math.pow(n, 2) + 1)
            }
            static min6(n, r, i, o, s, a) {
                return Math.min(n, Math.min(r, Math.min(i, Math.min(o, Math.min(s, a)))))
            }
            rgbToHex() {
                this.hex = "#",
                    this.hex += t.rgbChannelToHex(this.rgb_r),
                    this.hex += t.rgbChannelToHex(this.rgb_g),
                    this.hex += t.rgbChannelToHex(this.rgb_b)
            }
            hexToRgb() {
                this.hex = this.hex.toLowerCase(),
                    this.rgb_r = t.hexToRgbChannel(this.hex, 1),
                    this.rgb_g = t.hexToRgbChannel(this.hex, 3),
                    this.rgb_b = t.hexToRgbChannel(this.hex, 5)
            }
            xyzToRgb() {
                this.rgb_r = t.fromLinear(t.m_r0 * this.xyz_x + t.m_r1 * this.xyz_y + t.m_r2 * this.xyz_z),
                    this.rgb_g = t.fromLinear(t.m_g0 * this.xyz_x + t.m_g1 * this.xyz_y + t.m_g2 * this.xyz_z),
                    this.rgb_b = t.fromLinear(t.m_b0 * this.xyz_x + t.m_b1 * this.xyz_y + t.m_b2 * this.xyz_z)
            }
            rgbToXyz() {
                let n = t.toLinear(this.rgb_r)
                    , r = t.toLinear(this.rgb_g)
                    , i = t.toLinear(this.rgb_b);
                this.xyz_x = .41239079926595 * n + .35758433938387 * r + .18048078840183 * i,
                    this.xyz_y = .21263900587151 * n + .71516867876775 * r + .072192315360733 * i,
                    this.xyz_z = .019330818715591 * n + .11919477979462 * r + .95053215224966 * i
            }
            xyzToLuv() {
                let n = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z
                    , r = 4 * this.xyz_x
                    , i = 9 * this.xyz_y;
                n !== 0 ? (r /= n,
                    i /= n) : (r = NaN,
                        i = NaN),
                    this.luv_l = t.yToL(this.xyz_y),
                    this.luv_l === 0 ? (this.luv_u = 0,
                        this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (r - t.refU),
                            this.luv_v = 13 * this.luv_l * (i - t.refV))
            }
            luvToXyz() {
                if (this.luv_l === 0) {
                    this.xyz_x = 0,
                        this.xyz_y = 0,
                        this.xyz_z = 0;
                    return
                }
                let n = this.luv_u / (13 * this.luv_l) + t.refU
                    , r = this.luv_v / (13 * this.luv_l) + t.refV;
                this.xyz_y = t.lToY(this.luv_l),
                    this.xyz_x = 0 - 9 * this.xyz_y * n / ((n - 4) * r - n * r),
                    this.xyz_z = (9 * this.xyz_y - 15 * r * this.xyz_y - r * this.xyz_x) / (3 * r)
            }
            luvToLch() {
                if (this.lch_l = this.luv_l,
                    this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v),
                    this.lch_c < 1e-8)
                    this.lch_h = 0;
                else {
                    let n = Math.atan2(this.luv_v, this.luv_u);
                    this.lch_h = n * 180 / Math.PI,
                        this.lch_h < 0 && (this.lch_h = 360 + this.lch_h)
                }
            }
            lchToLuv() {
                let n = this.lch_h / 180 * Math.PI;
                this.luv_l = this.lch_l,
                    this.luv_u = Math.cos(n) * this.lch_c,
                    this.luv_v = Math.sin(n) * this.lch_c
            }
            calculateBoundingLines(n) {
                let r = Math.pow(n + 16, 3) / 1560896
                    , i = r > t.epsilon ? r : n / t.kappa
                    , o = i * (284517 * t.m_r0 - 94839 * t.m_r2)
                    , s = i * (838422 * t.m_r2 + 769860 * t.m_r1 + 731718 * t.m_r0)
                    , a = i * (632260 * t.m_r2 - 126452 * t.m_r1)
                    , l = i * (284517 * t.m_g0 - 94839 * t.m_g2)
                    , c = i * (838422 * t.m_g2 + 769860 * t.m_g1 + 731718 * t.m_g0)
                    , u = i * (632260 * t.m_g2 - 126452 * t.m_g1)
                    , f = i * (284517 * t.m_b0 - 94839 * t.m_b2)
                    , d = i * (838422 * t.m_b2 + 769860 * t.m_b1 + 731718 * t.m_b0)
                    , p = i * (632260 * t.m_b2 - 126452 * t.m_b1);
                this.r0s = o / a,
                    this.r0i = s * n / a,
                    this.r1s = o / (a + 126452),
                    this.r1i = (s - 769860) * n / (a + 126452),
                    this.g0s = l / u,
                    this.g0i = c * n / u,
                    this.g1s = l / (u + 126452),
                    this.g1i = (c - 769860) * n / (u + 126452),
                    this.b0s = f / p,
                    this.b0i = d * n / p,
                    this.b1s = f / (p + 126452),
                    this.b1i = (d - 769860) * n / (p + 126452)
            }
            calcMaxChromaHpluv() {
                let n = t.distanceFromOrigin(this.r0s, this.r0i)
                    , r = t.distanceFromOrigin(this.r1s, this.r1i)
                    , i = t.distanceFromOrigin(this.g0s, this.g0i)
                    , o = t.distanceFromOrigin(this.g1s, this.g1i)
                    , s = t.distanceFromOrigin(this.b0s, this.b0i)
                    , a = t.distanceFromOrigin(this.b1s, this.b1i);
                return t.min6(n, r, i, o, s, a)
            }
            calcMaxChromaHsluv(n) {
                let r = n / 360 * Math.PI * 2
                    , i = t.distanceFromOriginAngle(this.r0s, this.r0i, r)
                    , o = t.distanceFromOriginAngle(this.r1s, this.r1i, r)
                    , s = t.distanceFromOriginAngle(this.g0s, this.g0i, r)
                    , a = t.distanceFromOriginAngle(this.g1s, this.g1i, r)
                    , l = t.distanceFromOriginAngle(this.b0s, this.b0i, r)
                    , c = t.distanceFromOriginAngle(this.b1s, this.b1i, r);
                return t.min6(i, o, s, a, l, c)
            }
            hsluvToLch() {
                if (this.hsluv_l > 99.9999999)
                    this.lch_l = 100,
                        this.lch_c = 0;
                else if (this.hsluv_l < 1e-8)
                    this.lch_l = 0,
                        this.lch_c = 0;
                else {
                    this.lch_l = this.hsluv_l,
                        this.calculateBoundingLines(this.hsluv_l);
                    let n = this.calcMaxChromaHsluv(this.hsluv_h);
                    this.lch_c = n / 100 * this.hsluv_s
                }
                this.lch_h = this.hsluv_h
            }
            lchToHsluv() {
                if (this.lch_l > 99.9999999)
                    this.hsluv_s = 0,
                        this.hsluv_l = 100;
                else if (this.lch_l < 1e-8)
                    this.hsluv_s = 0,
                        this.hsluv_l = 0;
                else {
                    this.calculateBoundingLines(this.lch_l);
                    let n = this.calcMaxChromaHsluv(this.lch_h);
                    this.hsluv_s = this.lch_c / n * 100,
                        this.hsluv_l = this.lch_l
                }
                this.hsluv_h = this.lch_h
            }
            hpluvToLch() {
                if (this.hpluv_l > 99.9999999)
                    this.lch_l = 100,
                        this.lch_c = 0;
                else if (this.hpluv_l < 1e-8)
                    this.lch_l = 0,
                        this.lch_c = 0;
                else {
                    this.lch_l = this.hpluv_l,
                        this.calculateBoundingLines(this.hpluv_l);
                    let n = this.calcMaxChromaHpluv();
                    this.lch_c = n / 100 * this.hpluv_p
                }
                this.lch_h = this.hpluv_h
            }
            lchToHpluv() {
                if (this.lch_l > 99.9999999)
                    this.hpluv_p = 0,
                        this.hpluv_l = 100;
                else if (this.lch_l < 1e-8)
                    this.hpluv_p = 0,
                        this.hpluv_l = 0;
                else {
                    this.calculateBoundingLines(this.lch_l);
                    let n = this.calcMaxChromaHpluv();
                    this.hpluv_p = this.lch_c / n * 100,
                        this.hpluv_l = this.lch_l
                }
                this.hpluv_h = this.lch_h
            }
            hsluvToRgb() {
                this.hsluvToLch(),
                    this.lchToLuv(),
                    this.luvToXyz(),
                    this.xyzToRgb()
            }
            hpluvToRgb() {
                this.hpluvToLch(),
                    this.lchToLuv(),
                    this.luvToXyz(),
                    this.xyzToRgb()
            }
            hsluvToHex() {
                this.hsluvToRgb(),
                    this.rgbToHex()
            }
            hpluvToHex() {
                this.hpluvToRgb(),
                    this.rgbToHex()
            }
            rgbToHsluv() {
                this.rgbToXyz(),
                    this.xyzToLuv(),
                    this.luvToLch(),
                    this.lchToHpluv(),
                    this.lchToHsluv()
            }
            rgbToHpluv() {
                this.rgbToXyz(),
                    this.xyzToLuv(),
                    this.luvToLch(),
                    this.lchToHpluv(),
                    this.lchToHpluv()
            }
            hexToHsluv() {
                this.hexToRgb(),
                    this.rgbToHsluv()
            }
            hexToHpluv() {
                this.hexToRgb(),
                    this.rgbToHpluv()
            }
        }
            ;
        e.Hsluv = t,
            t.hexChars = "0123456789abcdef",
            t.refY = 1,
            t.refU = .19783000664283,
            t.refV = .46831999493879,
            t.kappa = 903.2962962,
            t.epsilon = .0088564516,
            t.m_r0 = 3.240969941904521,
            t.m_r1 = -1.537383177570093,
            t.m_r2 = -.498610760293,
            t.m_g0 = -.96924363628087,
            t.m_g1 = 1.87596750150772,
            t.m_g2 = .041555057407175,
            t.m_b0 = .055630079696993,
            t.m_b1 = -.20397695888897,
            t.m_b2 = 1.056971514242878
    }
})
    , GM = vn({
        "../../../node_modules/eventemitter3/index.js"(e, t) {
            "use strict";
            var n = Object.prototype.hasOwnProperty
                , r = "~";
            function i() { }
            Object.create && (i.prototype = Object.create(null),
                new i().__proto__ || (r = !1));
            function o(c, u, f) {
                this.fn = c,
                    this.context = u,
                    this.once = f || !1
            }
            function s(c, u, f, d, p) {
                if (typeof f != "function")
                    throw new TypeError("The listener must be a function");
                var v = new o(f, d || c, p)
                    , g = r ? r + u : u;
                return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], v] : c._events[g].push(v) : (c._events[g] = v,
                    c._eventsCount++),
                    c
            }
            function a(c, u) {
                --c._eventsCount === 0 ? c._events = new i : delete c._events[u]
            }
            function l() {
                this._events = new i,
                    this._eventsCount = 0
            }
            l.prototype.eventNames = function () {
                var u = [], f, d;
                if (this._eventsCount === 0)
                    return u;
                for (d in f = this._events)
                    n.call(f, d) && u.push(r ? d.slice(1) : d);
                return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u
            }
                ,
                l.prototype.listeners = function (u) {
                    var f = r ? r + u : u
                        , d = this._events[f];
                    if (!d)
                        return [];
                    if (d.fn)
                        return [d.fn];
                    for (var p = 0, v = d.length, g = new Array(v); p < v; p++)
                        g[p] = d[p].fn;
                    return g
                }
                ,
                l.prototype.listenerCount = function (u) {
                    var f = r ? r + u : u
                        , d = this._events[f];
                    return d ? d.fn ? 1 : d.length : 0
                }
                ,
                l.prototype.emit = function (u, f, d, p, v, g) {
                    var b = r ? r + u : u;
                    if (!this._events[b])
                        return !1;
                    var m = this._events[b], h = arguments.length, y, w;
                    if (m.fn) {
                        switch (m.once && this.removeListener(u, m.fn, void 0, !0),
                        h) {
                            case 1:
                                return m.fn.call(m.context),
                                    !0;
                            case 2:
                                return m.fn.call(m.context, f),
                                    !0;
                            case 3:
                                return m.fn.call(m.context, f, d),
                                    !0;
                            case 4:
                                return m.fn.call(m.context, f, d, p),
                                    !0;
                            case 5:
                                return m.fn.call(m.context, f, d, p, v),
                                    !0;
                            case 6:
                                return m.fn.call(m.context, f, d, p, v, g),
                                    !0
                        }
                        for (w = 1,
                            y = new Array(h - 1); w < h; w++)
                            y[w - 1] = arguments[w];
                        m.fn.apply(m.context, y)
                    } else {
                        var C = m.length, S;
                        for (w = 0; w < C; w++)
                            switch (m[w].once && this.removeListener(u, m[w].fn, void 0, !0),
                            h) {
                                case 1:
                                    m[w].fn.call(m[w].context);
                                    break;
                                case 2:
                                    m[w].fn.call(m[w].context, f);
                                    break;
                                case 3:
                                    m[w].fn.call(m[w].context, f, d);
                                    break;
                                case 4:
                                    m[w].fn.call(m[w].context, f, d, p);
                                    break;
                                default:
                                    if (!y)
                                        for (S = 1,
                                            y = new Array(h - 1); S < h; S++)
                                            y[S - 1] = arguments[S];
                                    m[w].fn.apply(m[w].context, y)
                            }
                    }
                    return !0
                }
                ,
                l.prototype.on = function (u, f, d) {
                    return s(this, u, f, d, !1)
                }
                ,
                l.prototype.once = function (u, f, d) {
                    return s(this, u, f, d, !0)
                }
                ,
                l.prototype.removeListener = function (u, f, d, p) {
                    var v = r ? r + u : u;
                    if (!this._events[v])
                        return this;
                    if (!f)
                        return a(this, v),
                            this;
                    var g = this._events[v];
                    if (g.fn)
                        g.fn === f && (!p || g.once) && (!d || g.context === d) && a(this, v);
                    else {
                        for (var b = 0, m = [], h = g.length; b < h; b++)
                            (g[b].fn !== f || p && !g[b].once || d && g[b].context !== d) && m.push(g[b]);
                        m.length ? this._events[v] = m.length === 1 ? m[0] : m : a(this, v)
                    }
                    return this
                }
                ,
                l.prototype.removeAllListeners = function (u) {
                    var f;
                    return u ? (f = r ? r + u : u,
                        this._events[f] && a(this, f)) : (this._events = new i,
                            this._eventsCount = 0),
                        this
                }
                ,
                l.prototype.off = l.prototype.removeListener,
                l.prototype.addListener = l.prototype.on,
                l.prefixed = r,
                l.EventEmitter = l,
                typeof t < "u" && (t.exports = l)
        }
    })
    , Km = vn({
        "../../../node_modules/process/browser.js"(e, t) {
            var n = t.exports = {}, r, i;
            function o() {
                throw new Error("setTimeout has not been defined")
            }
            function s() {
                throw new Error("clearTimeout has not been defined")
            }
            (function () {
                try {
                    typeof setTimeout == "function" ? r = setTimeout : r = o
                } catch {
                    r = o
                }
                try {
                    typeof clearTimeout == "function" ? i = clearTimeout : i = s
                } catch {
                    i = s
                }
            }
            )();
            function a(m) {
                if (r === setTimeout)
                    return setTimeout(m, 0);
                if ((r === o || !r) && setTimeout)
                    return r = setTimeout,
                        setTimeout(m, 0);
                try {
                    return r(m, 0)
                } catch {
                    try {
                        return r.call(null, m, 0)
                    } catch {
                        return r.call(this, m, 0)
                    }
                }
            }
            function l(m) {
                if (i === clearTimeout)
                    return clearTimeout(m);
                if ((i === s || !i) && clearTimeout)
                    return i = clearTimeout,
                        clearTimeout(m);
                try {
                    return i(m)
                } catch {
                    try {
                        return i.call(null, m)
                    } catch {
                        return i.call(this, m)
                    }
                }
            }
            var c = [], u = !1, f, d = -1;
            function p() {
                !u || !f || (u = !1,
                    f.length ? c = f.concat(c) : d = -1,
                    c.length && v())
            }
            function v() {
                if (!u) {
                    var m = a(p);
                    u = !0;
                    for (var h = c.length; h;) {
                        for (f = c,
                            c = []; ++d < h;)
                            f && f[d].run();
                        d = -1,
                            h = c.length
                    }
                    f = null,
                        u = !1,
                        l(m)
                }
            }
            n.nextTick = function (m) {
                var h = new Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var y = 1; y < arguments.length; y++)
                        h[y - 1] = arguments[y];
                c.push(new g(m, h)),
                    c.length === 1 && !u && a(v)
            }
                ;
            function g(m, h) {
                this.fun = m,
                    this.array = h
            }
            g.prototype.run = function () {
                this.fun.apply(null, this.array)
            }
                ,
                n.title = "browser",
                n.browser = !0,
                n.env = {},
                n.argv = [],
                n.version = "",
                n.versions = {};
            function b() { }
            n.on = b,
                n.addListener = b,
                n.once = b,
                n.off = b,
                n.removeListener = b,
                n.removeAllListeners = b,
                n.emit = b,
                n.prependListener = b,
                n.prependOnceListener = b,
                n.listeners = function (m) {
                    return []
                }
                ,
                n.binding = function (m) {
                    throw new Error("process.binding is not supported")
                }
                ,
                n.cwd = function () {
                    return "/"
                }
                ,
                n.chdir = function (m) {
                    throw new Error("process.chdir is not supported")
                }
                ,
                n.umask = function () {
                    return 0
                }
        }
    })
    , qM = vn({
        "../../../node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js"(e, t) {
            (function (n, r) {
                typeof e == "object" && typeof t < "u" ? r(e) : typeof define == "function" && define.amd ? define(["exports"], r) : (n = typeof globalThis < "u" ? globalThis : n || self,
                    r(n.ResizeObserver = {}))
            }
            )(e, function (n) {
                "use strict";
                var r = [], i = function () {
                    return r.some(function (_) {
                        return _.activeTargets.length > 0
                    })
                }, o = function () {
                    return r.some(function (_) {
                        return _.skippedTargets.length > 0
                    })
                }, s = "ResizeObserver loop completed with undelivered notifications.", a = function () {
                    var _;
                    typeof ErrorEvent == "function" ? _ = new ErrorEvent("error", {
                        message: s
                    }) : (_ = document.createEvent("Event"),
                        _.initEvent("error", !1, !1),
                        _.message = s),
                        I.dispatchEvent(_)
                }, l;
                (function (_) {
                    _.BORDER_BOX = "border-box",
                        _.CONTENT_BOX = "content-box",
                        _.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box"
                }
                )(l || (l = {}));
                var c = function (_) {
                    return Object.freeze(_)
                }, u = function () {
                    function _(O, L) {
                        this.inlineSize = O,
                            this.blockSize = L,
                            c(this)
                    }
                    return _
                }(), f = function () {
                    function _(O, L, K, ve) {
                        return this.x = O,
                            this.y = L,
                            this.width = K,
                            this.height = ve,
                            this.top = this.y,
                            this.left = this.x,
                            this.bottom = this.top + this.height,
                            this.right = this.left + this.width,
                            c(this)
                    }
                    return _.prototype.toJSON = function () {
                        var O = this
                            , L = O.x
                            , K = O.y
                            , ve = O.top
                            , Lt = O.right
                            , bt = O.bottom
                            , tt = O.left
                            , vr = O.width
                            , en = O.height;
                        return {
                            x: L,
                            y: K,
                            top: ve,
                            right: Lt,
                            bottom: bt,
                            left: tt,
                            width: vr,
                            height: en
                        }
                    }
                        ,
                        _.fromRect = function (O) {
                            return new _(O.x, O.y, O.width, O.height)
                        }
                        ,
                        _
                }(), d = function (_) {
                    return _ instanceof SVGElement && "getBBox" in _
                }, p = function (_) {
                    if (d(_)) {
                        var O = _.getBBox()
                            , L = O.width
                            , K = O.height;
                        return !L && !K
                    }
                    var ve = _
                        , Lt = ve.offsetWidth
                        , bt = ve.offsetHeight;
                    return !(Lt || bt || _.getClientRects().length)
                }, v = function (_) {
                    var O, L;
                    if (_ instanceof Element)
                        return !0;
                    var K = (L = (O = _) === null || O === void 0 ? void 0 : O.ownerDocument) === null || L === void 0 ? void 0 : L.defaultView;
                    return !!(K && _ instanceof K.Element)
                }, g = function (_) {
                    switch (_.tagName) {
                        case "INPUT":
                            if (_.type !== "image")
                                break;
                        case "VIDEO":
                        case "AUDIO":
                        case "EMBED":
                        case "OBJECT":
                        case "CANVAS":
                        case "IFRAME":
                        case "IMG":
                            return !0
                    }
                    return !1
                }, b = typeof I < "u" ? I : {}, m = new WeakMap, h = /auto|scroll/, y = /^tb|vertical/, w = /msie|trident/i.test(b.navigator && b.navigator.userAgent), C = function (_) {
                    return parseFloat(_ || "0")
                }, S = function (_, O, L) {
                    return _ === void 0 && (_ = 0),
                        O === void 0 && (O = 0),
                        L === void 0 && (L = !1),
                        new u((L ? O : _) || 0, (L ? _ : O) || 0)
                }, T = c({
                    devicePixelContentBoxSize: S(),
                    borderBoxSize: S(),
                    contentBoxSize: S(),
                    contentRect: new f(0, 0, 0, 0)
                }), R = function (_, O) {
                    if (O === void 0 && (O = !1),
                        m.has(_) && !O)
                        return m.get(_);
                    if (p(_))
                        return m.set(_, T),
                            T;
                    var L = getComputedStyle(_)
                        , K = d(_) && _.ownerSVGElement && _.getBBox()
                        , ve = !w && L.boxSizing === "border-box"
                        , Lt = y.test(L.writingMode || "")
                        , bt = !K && h.test(L.overflowY || "")
                        , tt = !K && h.test(L.overflowX || "")
                        , vr = K ? 0 : C(L.paddingTop)
                        , en = K ? 0 : C(L.paddingRight)
                        , xi = K ? 0 : C(L.paddingBottom)
                        , io = K ? 0 : C(L.paddingLeft)
                        , vR = K ? 0 : C(L.borderTopWidth)
                        , yR = K ? 0 : C(L.borderRightWidth)
                        , bR = K ? 0 : C(L.borderBottomWidth)
                        , xR = K ? 0 : C(L.borderLeftWidth)
                        , Lg = io + en
                        , Vg = vr + xi
                        , sf = xR + yR
                        , af = vR + bR
                        , Ag = tt ? _.offsetHeight - af - _.clientHeight : 0
                        , Dg = bt ? _.offsetWidth - sf - _.clientWidth : 0
                        , wR = ve ? Lg + sf : 0
                        , SR = ve ? Vg + af : 0
                        , el = K ? K.width : C(L.width) - wR - Dg
                        , tl = K ? K.height : C(L.height) - SR - Ag
                        , kR = el + Lg + Dg + sf
                        , CR = tl + Vg + Ag + af
                        , zg = c({
                            devicePixelContentBoxSize: S(Math.round(el * devicePixelRatio), Math.round(tl * devicePixelRatio), Lt),
                            borderBoxSize: S(kR, CR, Lt),
                            contentBoxSize: S(el, tl, Lt),
                            contentRect: new f(io, vr, el, tl)
                        });
                    return m.set(_, zg),
                        zg
                }, F = function (_, O, L) {
                    var K = R(_, L)
                        , ve = K.borderBoxSize
                        , Lt = K.contentBoxSize
                        , bt = K.devicePixelContentBoxSize;
                    switch (O) {
                        case l.DEVICE_PIXEL_CONTENT_BOX:
                            return bt;
                        case l.BORDER_BOX:
                            return ve;
                        default:
                            return Lt
                    }
                }, P = function () {
                    function _(O) {
                        var L = R(O);
                        this.target = O,
                            this.contentRect = L.contentRect,
                            this.borderBoxSize = c([L.borderBoxSize]),
                            this.contentBoxSize = c([L.contentBoxSize]),
                            this.devicePixelContentBoxSize = c([L.devicePixelContentBoxSize])
                    }
                    return _
                }(), B = function (_) {
                    if (p(_))
                        return 1 / 0;
                    for (var O = 0, L = _.parentNode; L;)
                        O += 1,
                            L = L.parentNode;
                    return O
                }, $ = function () {
                    var _ = 1 / 0
                        , O = [];
                    r.forEach(function (bt) {
                        if (bt.activeTargets.length !== 0) {
                            var tt = [];
                            bt.activeTargets.forEach(function (en) {
                                var xi = new P(en.target)
                                    , io = B(en.target);
                                tt.push(xi),
                                    en.lastReportedSize = F(en.target, en.observedBox),
                                    io < _ && (_ = io)
                            }),
                                O.push(function () {
                                    bt.callback.call(bt.observer, tt, bt.observer)
                                }),
                                bt.activeTargets.splice(0, bt.activeTargets.length)
                        }
                    });
                    for (var L = 0, K = O; L < K.length; L++) {
                        var ve = K[L];
                        ve()
                    }
                    return _
                }, N = function (_) {
                    r.forEach(function (L) {
                        L.activeTargets.splice(0, L.activeTargets.length),
                            L.skippedTargets.splice(0, L.skippedTargets.length),
                            L.observationTargets.forEach(function (ve) {
                                ve.isActive() && (B(ve.target) > _ ? L.activeTargets.push(ve) : L.skippedTargets.push(ve))
                            })
                    })
                }, U = function () {
                    var _ = 0;
                    for (N(_); i();)
                        _ = $(),
                            N(_);
                    return o() && a(),
                        _ > 0
                }, j, ae = [], te = function () {
                    return ae.splice(0).forEach(function (_) {
                        return _()
                    })
                }, Y = function (_) {
                    if (!j) {
                        var O = 0
                            , L = document.createTextNode("")
                            , K = {
                                characterData: !0
                            };
                        new MutationObserver(function () {
                            return te()
                        }
                        ).observe(L, K),
                            j = function () {
                                L.textContent = "" + (O ? O-- : O++)
                            }
                    }
                    ae.push(_),
                        j()
                }, ne = function (_) {
                    Y(function () {
                        requestAnimationFrame(_)
                    })
                }, G = 0, he = function () {
                    return !!G
                }, se = 250, le = {
                    attributes: !0,
                    characterData: !0,
                    childList: !0,
                    subtree: !0
                }, q = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], Je = function (_) {
                    return _ === void 0 && (_ = 0),
                        Date.now() + _
                }, Re = !1, et = function () {
                    function _() {
                        var O = this;
                        this.stopped = !0,
                            this.listener = function () {
                                return O.schedule()
                            }
                    }
                    return _.prototype.run = function (O) {
                        var L = this;
                        if (O === void 0 && (O = se),
                            !Re) {
                            Re = !0;
                            var K = Je(O);
                            ne(function () {
                                var ve = !1;
                                try {
                                    ve = U()
                                } finally {
                                    if (Re = !1,
                                        O = K - Je(),
                                        !he())
                                        return;
                                    ve ? L.run(1e3) : O > 0 ? L.run(O) : L.start()
                                }
                            })
                        }
                    }
                        ,
                        _.prototype.schedule = function () {
                            this.stop(),
                                this.run()
                        }
                        ,
                        _.prototype.observe = function () {
                            var O = this
                                , L = function () {
                                    return O.observer && O.observer.observe(document.body, le)
                                };
                            document.body ? L() : b.addEventListener("DOMContentLoaded", L)
                        }
                        ,
                        _.prototype.start = function () {
                            var O = this;
                            this.stopped && (this.stopped = !1,
                                this.observer = new MutationObserver(this.listener),
                                this.observe(),
                                q.forEach(function (L) {
                                    return b.addEventListener(L, O.listener, !0)
                                }))
                        }
                        ,
                        _.prototype.stop = function () {
                            var O = this;
                            this.stopped || (this.observer && this.observer.disconnect(),
                                q.forEach(function (L) {
                                    return b.removeEventListener(L, O.listener, !0)
                                }),
                                this.stopped = !0)
                        }
                        ,
                        _
                }(), Pe = new et, mn = function (_) {
                    !G && _ > 0 && Pe.start(),
                        G += _,
                        !G && Pe.stop()
                }, Tt = function (_) {
                    return !d(_) && !g(_) && getComputedStyle(_).display === "inline"
                }, qn = function () {
                    function _(O, L) {
                        this.target = O,
                            this.observedBox = L || l.CONTENT_BOX,
                            this.lastReportedSize = {
                                inlineSize: 0,
                                blockSize: 0
                            }
                    }
                    return _.prototype.isActive = function () {
                        var O = F(this.target, this.observedBox, !0);
                        return Tt(this.target) && (this.lastReportedSize = O),
                            this.lastReportedSize.inlineSize !== O.inlineSize || this.lastReportedSize.blockSize !== O.blockSize
                    }
                        ,
                        _
                }(), pe = function () {
                    function _(O, L) {
                        this.activeTargets = [],
                            this.skippedTargets = [],
                            this.observationTargets = [],
                            this.observer = O,
                            this.callback = L
                    }
                    return _
                }(), Jt = new WeakMap, dt = function (_, O) {
                    for (var L = 0; L < _.length; L += 1)
                        if (_[L].target === O)
                            return L;
                    return -1
                }, gn = function () {
                    function _() { }
                    return _.connect = function (O, L) {
                        var K = new pe(O, L);
                        Jt.set(O, K)
                    }
                        ,
                        _.observe = function (O, L, K) {
                            var ve = Jt.get(O)
                                , Lt = ve.observationTargets.length === 0;
                            dt(ve.observationTargets, L) < 0 && (Lt && r.push(ve),
                                ve.observationTargets.push(new qn(L, K && K.box)),
                                mn(1),
                                Pe.schedule())
                        }
                        ,
                        _.unobserve = function (O, L) {
                            var K = Jt.get(O)
                                , ve = dt(K.observationTargets, L)
                                , Lt = K.observationTargets.length === 1;
                            ve >= 0 && (Lt && r.splice(r.indexOf(K), 1),
                                K.observationTargets.splice(ve, 1),
                                mn(-1))
                        }
                        ,
                        _.disconnect = function (O) {
                            var L = this
                                , K = Jt.get(O);
                            K.observationTargets.slice().forEach(function (ve) {
                                return L.unobserve(O, ve.target)
                            }),
                                K.activeTargets.splice(0, K.activeTargets.length)
                        }
                        ,
                        _
                }(), Ja = function () {
                    function _(O) {
                        if (arguments.length === 0)
                            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
                        if (typeof O != "function")
                            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
                        gn.connect(this, O)
                    }
                    return _.prototype.observe = function (O, L) {
                        if (arguments.length === 0)
                            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
                        if (!v(O))
                            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
                        gn.observe(this, O, L)
                    }
                        ,
                        _.prototype.unobserve = function (O) {
                            if (arguments.length === 0)
                                throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
                            if (!v(O))
                                throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
                            gn.unobserve(this, O)
                        }
                        ,
                        _.prototype.disconnect = function () {
                            gn.disconnect(this)
                        }
                        ,
                        _.toString = function () {
                            return "function ResizeObserver () { [polyfill code] }"
                        }
                        ,
                        _
                }();
                n.ResizeObserver = Ja,
                    n.ResizeObserverEntry = P,
                    n.ResizeObserverSize = u,
                    Object.defineProperty(n, "__esModule", {
                        value: !0
                    })
            })
        }
    })
    , XM = vn({
        "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) {
            "use strict";
            var t = typeof Symbol == "function" && Symbol.for
                , n = t ? Symbol.for("react.element") : 60103
                , r = t ? Symbol.for("react.portal") : 60106
                , i = t ? Symbol.for("react.fragment") : 60107
                , o = t ? Symbol.for("react.strict_mode") : 60108
                , s = t ? Symbol.for("react.profiler") : 60114
                , a = t ? Symbol.for("react.provider") : 60109
                , l = t ? Symbol.for("react.context") : 60110
                , c = t ? Symbol.for("react.async_mode") : 60111
                , u = t ? Symbol.for("react.concurrent_mode") : 60111
                , f = t ? Symbol.for("react.forward_ref") : 60112
                , d = t ? Symbol.for("react.suspense") : 60113
                , p = t ? Symbol.for("react.suspense_list") : 60120
                , v = t ? Symbol.for("react.memo") : 60115
                , g = t ? Symbol.for("react.lazy") : 60116
                , b = t ? Symbol.for("react.block") : 60121
                , m = t ? Symbol.for("react.fundamental") : 60117
                , h = t ? Symbol.for("react.responder") : 60118
                , y = t ? Symbol.for("react.scope") : 60119;
            function w(S) {
                if (typeof S == "object" && S !== null) {
                    var T = S.$$typeof;
                    switch (T) {
                        case n:
                            switch (S = S.type,
                            S) {
                                case c:
                                case u:
                                case i:
                                case s:
                                case o:
                                case d:
                                    return S;
                                default:
                                    switch (S = S && S.$$typeof,
                                    S) {
                                        case l:
                                        case f:
                                        case g:
                                        case v:
                                        case a:
                                            return S;
                                        default:
                                            return T
                                    }
                            }
                        case r:
                            return T
                    }
                }
            }
            function C(S) {
                return w(S) === u
            }
            e.AsyncMode = c,
                e.ConcurrentMode = u,
                e.ContextConsumer = l,
                e.ContextProvider = a,
                e.Element = n,
                e.ForwardRef = f,
                e.Fragment = i,
                e.Lazy = g,
                e.Memo = v,
                e.Portal = r,
                e.Profiler = s,
                e.StrictMode = o,
                e.Suspense = d,
                e.isAsyncMode = function (S) {
                    return C(S) || w(S) === c
                }
                ,
                e.isConcurrentMode = C,
                e.isContextConsumer = function (S) {
                    return w(S) === l
                }
                ,
                e.isContextProvider = function (S) {
                    return w(S) === a
                }
                ,
                e.isElement = function (S) {
                    return typeof S == "object" && S !== null && S.$$typeof === n
                }
                ,
                e.isForwardRef = function (S) {
                    return w(S) === f
                }
                ,
                e.isFragment = function (S) {
                    return w(S) === i
                }
                ,
                e.isLazy = function (S) {
                    return w(S) === g
                }
                ,
                e.isMemo = function (S) {
                    return w(S) === v
                }
                ,
                e.isPortal = function (S) {
                    return w(S) === r
                }
                ,
                e.isProfiler = function (S) {
                    return w(S) === s
                }
                ,
                e.isStrictMode = function (S) {
                    return w(S) === o
                }
                ,
                e.isSuspense = function (S) {
                    return w(S) === d
                }
                ,
                e.isValidElementType = function (S) {
                    return typeof S == "string" || typeof S == "function" || S === i || S === u || S === s || S === o || S === d || S === p || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === v || S.$$typeof === a || S.$$typeof === l || S.$$typeof === f || S.$$typeof === m || S.$$typeof === h || S.$$typeof === y || S.$$typeof === b)
                }
                ,
                e.typeOf = w
        }
    })
    , YM = vn({
        "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) {
            "use strict";
            t.exports = XM()
        }
    })
    , Gu = vn({
        "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) {
            "use strict";
            var n = YM()
                , r = {
                    childContextTypes: !0,
                    contextType: !0,
                    contextTypes: !0,
                    defaultProps: !0,
                    displayName: !0,
                    getDefaultProps: !0,
                    getDerivedStateFromError: !0,
                    getDerivedStateFromProps: !0,
                    mixins: !0,
                    propTypes: !0,
                    type: !0
                }
                , i = {
                    name: !0,
                    length: !0,
                    prototype: !0,
                    caller: !0,
                    callee: !0,
                    arguments: !0,
                    arity: !0
                }
                , o = {
                    $$typeof: !0,
                    render: !0,
                    defaultProps: !0,
                    displayName: !0,
                    propTypes: !0
                }
                , s = {
                    $$typeof: !0,
                    compare: !0,
                    defaultProps: !0,
                    displayName: !0,
                    propTypes: !0,
                    type: !0
                }
                , a = {};
            a[n.ForwardRef] = o,
                a[n.Memo] = s;
            function l(b) {
                return n.isMemo(b) ? s : a[b.$$typeof] || r
            }
            var c = Object.defineProperty
                , u = Object.getOwnPropertyNames
                , f = Object.getOwnPropertySymbols
                , d = Object.getOwnPropertyDescriptor
                , p = Object.getPrototypeOf
                , v = Object.prototype;
            function g(b, m, h) {
                if (typeof m != "string") {
                    if (v) {
                        var y = p(m);
                        y && y !== v && g(b, y, h)
                    }
                    var w = u(m);
                    f && (w = w.concat(f(m)));
                    for (var C = l(b), S = l(m), T = 0; T < w.length; ++T) {
                        var R = w[T];
                        if (!i[R] && !(h && h[R]) && !(S && S[R]) && !(C && C[R])) {
                            var F = d(m, R);
                            try {
                                c(b, R, F)
                            } catch { }
                        }
                    }
                }
                return b
            }
            t.exports = g
        }
    })
    , KM = vn({
        "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) {
            (function () {
                function n(m, h) {
                    document.addEventListener ? m.addEventListener("scroll", h, !1) : m.attachEvent("scroll", h)
                }
                function r(m) {
                    document.body ? m() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function h() {
                        document.removeEventListener("DOMContentLoaded", h),
                            m()
                    }) : document.attachEvent("onreadystatechange", function h() {
                        (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", h),
                            m())
                    })
                }
                function i(m) {
                    this.a = document.createElement("div"),
                        this.a.setAttribute("aria-hidden", "true"),
                        this.a.appendChild(document.createTextNode(m)),
                        this.b = document.createElement("span"),
                        this.c = document.createElement("span"),
                        this.h = document.createElement("span"),
                        this.f = document.createElement("span"),
                        this.g = -1,
                        this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                        this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                        this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                        this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",
                        this.b.appendChild(this.h),
                        this.c.appendChild(this.f),
                        this.a.appendChild(this.b),
                        this.a.appendChild(this.c)
                }
                function o(m, h) {
                    m.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + h + ";"
                }
                function s(m) {
                    var h = m.a.offsetWidth
                        , y = h + 100;
                    return m.f.style.width = y + "px",
                        m.c.scrollLeft = y,
                        m.b.scrollLeft = m.b.scrollWidth + 100,
                        m.g !== h ? (m.g = h,
                            !0) : !1
                }
                function a(m, h) {
                    function y() {
                        var C = w;
                        s(C) && C.a.parentNode && h(C.g)
                    }
                    var w = m;
                    n(m.b, y),
                        n(m.c, y),
                        s(m)
                }
                function l(m, h) {
                    var y = h || {};
                    this.family = m,
                        this.style = y.style || "normal",
                        this.weight = y.weight || "normal",
                        this.stretch = y.stretch || "normal"
                }
                var c = null
                    , u = null
                    , f = null
                    , d = null;
                function p() {
                    if (u === null)
                        if (v() && /Apple/.test(I.navigator.vendor)) {
                            var m = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(I.navigator.userAgent);
                            u = !!m && 603 > parseInt(m[1], 10)
                        } else
                            u = !1;
                    return u
                }
                function v() {
                    return d === null && (d = !!document.fonts),
                        d
                }
                function g() {
                    if (f === null) {
                        var m = document.createElement("div");
                        try {
                            m.style.font = "condensed 100px sans-serif"
                        } catch { }
                        f = m.style.font !== ""
                    }
                    return f
                }
                function b(m, h) {
                    return [m.style, m.weight, g() ? m.stretch : "", "100px", h].join(" ")
                }
                l.prototype.load = function (m, h) {
                    var y = this
                        , w = m || "BESbswy"
                        , C = 0
                        , S = h || 3e3
                        , T = new Date().getTime();
                    return new Promise(function (R, F) {
                        if (v() && !p()) {
                            var P = new Promise(function ($, N) {
                                function U() {
                                    new Date().getTime() - T >= S ? N(Error("" + S + "ms timeout exceeded")) : document.fonts.load(b(y, '"' + y.family + '"'), w).then(function (j) {
                                        1 <= j.length ? $() : setTimeout(U, 25)
                                    }, N)
                                }
                                U()
                            }
                            )
                                , B = new Promise(function ($, N) {
                                    C = setTimeout(function () {
                                        N(Error("" + S + "ms timeout exceeded"))
                                    }, S)
                                }
                                );
                            Promise.race([B, P]).then(function () {
                                clearTimeout(C),
                                    R(y)
                            }, F)
                        } else
                            r(function () {
                                function $() {
                                    var q;
                                    (q = te != -1 && Y != -1 || te != -1 && ne != -1 || Y != -1 && ne != -1) && ((q = te != Y && te != ne && Y != ne) || (c === null && (q = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(I.navigator.userAgent),
                                        c = !!q && (536 > parseInt(q[1], 10) || parseInt(q[1], 10) === 536 && 11 >= parseInt(q[2], 10))),
                                        q = c && (te == G && Y == G && ne == G || te == he && Y == he && ne == he || te == se && Y == se && ne == se)),
                                        q = !q),
                                        q && (le.parentNode && le.parentNode.removeChild(le),
                                            clearTimeout(C),
                                            R(y))
                                }
                                function N() {
                                    if (new Date().getTime() - T >= S)
                                        le.parentNode && le.parentNode.removeChild(le),
                                            F(Error("" + S + "ms timeout exceeded"));
                                    else {
                                        var q = document.hidden;
                                        (q === !0 || q === void 0) && (te = U.a.offsetWidth,
                                            Y = j.a.offsetWidth,
                                            ne = ae.a.offsetWidth,
                                            $()),
                                            C = setTimeout(N, 50)
                                    }
                                }
                                var U = new i(w)
                                    , j = new i(w)
                                    , ae = new i(w)
                                    , te = -1
                                    , Y = -1
                                    , ne = -1
                                    , G = -1
                                    , he = -1
                                    , se = -1
                                    , le = document.createElement("div");
                                le.dir = "ltr",
                                    o(U, b(y, "sans-serif")),
                                    o(j, b(y, "serif")),
                                    o(ae, b(y, "monospace")),
                                    le.appendChild(U.a),
                                    le.appendChild(j.a),
                                    le.appendChild(ae.a),
                                    document.body.appendChild(le),
                                    G = U.a.offsetWidth,
                                    he = j.a.offsetWidth,
                                    se = ae.a.offsetWidth,
                                    N(),
                                    a(U, function (q) {
                                        te = q,
                                            $()
                                    }),
                                    o(U, b(y, '"' + y.family + '",sans-serif')),
                                    a(j, function (q) {
                                        Y = q,
                                            $()
                                    }),
                                    o(j, b(y, '"' + y.family + '",serif')),
                                    a(ae, function (q) {
                                        ne = q,
                                            $()
                                    }),
                                    o(ae, b(y, '"' + y.family + '",monospace'))
                            })
                    }
                    )
                }
                    ,
                    typeof t == "object" ? t.exports = l : (I.FontFaceObserver = l,
                        I.FontFaceObserver.prototype.load = l.prototype.load)
            }
            )()
        }
    });
function Mm(e, t) {
    let n = {
        style: t
    };
    return x.isValidElement(e) ? x.cloneElement(e, n) : x.createElement(e, n)
}
var QM = class extends Error {
}
    , bu = class extends Error {
    }
    , ZM = class extends ke {
        constructor(e) {
            super(e),
                this.state = {
                    error: void 0,
                    forceUpdateKey: e.forceUpdateKey
                }
        }
        static getDerivedStateFromError(e) {
            return {
                error: e
            }
        }
        static getDerivedStateFromProps(e, t) {
            if (e.forceUpdateKey !== t.forceUpdateKey) {
                let n = {
                    forceUpdateKey: e.forceUpdateKey
                };
                return t.error && (n.error = void 0),
                    n
            }
            return null
        }
        render() {
            if (this.state.error === void 0)
                return this.props.children;
            if (!(this.state.error instanceof QM)) {
                let n = new bu;
                throw n.cause = this.state.error,
                n
            }
            let { notFoundPage: e, defaultPageStyle: t } = this.props;
            if (!e)
                throw this.state.error;
            return Mm(e, t)
        }
    }
    , JM = ":([a-z]\\w*)"
    , Qi = new RegExp(JM, "gi");
function Lk(e, t) {
    return e.replace(Qi, (n, r) => {
        let i = t[r];
        return typeof i != "string" || i.length === 0 ? n : encodeURIComponent(i)
    }
    )
}
function Vk(e, t) {
    if (!e.startsWith("/") || !t.startsWith("/"))
        throw new Error("from/to paths are expected to be absolute");
    let [n] = HS(e)
        , [r, i] = HS(t)
        , o = eL(n, r);
    return o === "" && (o = "."),
        !o.startsWith(".") && !o.startsWith("/") && (o = "./" + o),
        o + "/" + i
}
function HS(e) {
    let t = e.lastIndexOf("/");
    return [e.substring(0, t + 1), e.substring(t + 1)]
}
var sm = 46
    , ts = 47
    , yi = (e, t) => e.charCodeAt(t)
    , WS = (e, t) => e.lastIndexOf(t)
    , rs = (e, t, n) => e.slice(t, n);
function eL(e, t) {
    if (e === t || (e = "/" + GS(e),
        t = "/" + GS(t),
        e === t))
        return "";
    let n = 1
        , r = e.length
        , i = r - n
        , o = 1
        , s = t.length - o
        , a = i < s ? i : s
        , l = -1
        , c = 0;
    for (; c < a; c++) {
        let f = yi(e, n + c);
        if (f !== yi(t, o + c))
            break;
        f === ts && (l = c)
    }
    if (c === a)
        if (s > a) {
            if (yi(t, o + c) === ts)
                return rs(t, o + c + 1);
            if (c === 0)
                return rs(t, o + c)
        } else
            i > a && (yi(e, n + c) === ts ? l = c : c === 0 && (l = 0));
    let u = "";
    for (c = n + l + 1; c <= r; ++c)
        (c === r || yi(e, c) === ts) && (u += u.length === 0 ? ".." : "/..");
    return `${u}${rs(t, o + l)}`
}
var tL = !1
    , su = "/"
    , US = e => e === ts;
function GS(e) {
    let t = ""
        , n = 0
        , r = -1
        , i = 0
        , o = 0;
    for (let s = 0; s <= e.length; ++s) {
        if (s < e.length)
            o = yi(e, s);
        else {
            if (US(o))
                break;
            o = ts
        }
        if (US(o)) {
            if (!(r === s - 1 || i === 1))
                if (i === 2) {
                    if (t.length < 2 || n !== 2 || yi(t, t.length - 1) !== sm || yi(t, t.length - 2) !== sm) {
                        if (t.length > 2) {
                            let a = WS(t, su);
                            a === -1 ? (t = "",
                                n = 0) : (t = rs(t, 0, a),
                                    n = t.length - 1 - WS(t, su)),
                                r = s,
                                i = 0;
                            continue
                        } else if (t.length !== 0) {
                            t = "",
                                n = 0,
                                r = s,
                                i = 0;
                            continue
                        }
                    }
                    tL && (t += t.length > 0 ? `${su}..` : "..",
                        n = 2)
                } else
                    t.length > 0 ? t += `${su}${rs(e, r + 1, s)}` : t = rs(e, r + 1, s),
                        n = s - r - 1;
            r = s,
                i = 0
        } else
            o === sm && i !== -1 ? ++i : i = -1
    }
    return t
}
function Ak(e) {
    let t = typeof I < "u" ? I.location.search : "";
    return t ? nL(t, e) : e
}
function nL(e, t) {
    let n = t.indexOf("#")
        , r = n === -1 ? t : t.substring(0, n)
        , i = n === -1 ? "" : t.substring(n)
        , o = r.indexOf("?");
    if (o === -1)
        return r + e + i;
    let s = new URLSearchParams(e)
        , a = r.substring(o + 1)
        , l = new URLSearchParams(a);
    for (let [c, u] of s)
        l.has(c) || l.append(c, u);
    return r.substring(0, o + 1) + l.toString() + i
}
function Na(e) {
    return typeof e == "object" && e !== null && !Array.isArray(e)
}
function Ki(e) {
    return typeof e == "string"
}
var rL = "preload";
function Dk(e) {
    return typeof e == "object" && e !== null && !x.isValidElement(e) && rL in e
}
function RH(e) {
    let t = x.lazy(e), n, r, i = x.forwardRef(function (s, a) {
        return x.createElement(r ?? t, a ? {
            ref: a,
            ...s
        } : s)
    });
    return i.preload = () => (n || (n = e().then(o => (r = o.default,
        r))),
        n),
        i
}
function qu(e, t) {
    if (t && e)
        return e.elements && t in e.elements ? e.elements[t] : t
}
function iL(e) {
    return /bot|-google|google-|yandex|ia_archiver/iu.test(e)
}
function zk(e) {
    if ("scheduler" in I) {
        if ("yield" in scheduler)
            return scheduler.yield(e);
        if ("postTask" in scheduler)
            return scheduler.postTask(() => { }
                , e)
    }
    return e?.priority === "user-blocking" ? Promise.resolve() : new Promise(t => {
        setTimeout(t)
    }
    )
}
async function Bk(e, t) {
    return await zk(t),
        e()
}
function Zi(e) {
    return new Promise(t => {
        setTimeout(t, 100),
            requestAnimationFrame(() => {
                Bk(t, e)
            }
            )
    }
    )
}
function oL(e, t, n, r = ze) {
    r(() => {
        let i = async s => (await Zi(n),
            s())
            , o = i(e);
        return () => {
            (async () => {
                let s = await o;
                s && i(s)
            }
            )()
        }
    }
        , t)
}
var Qm = () => { }
    , sL = [];
async function aL(e, t, n, r, i, o, s) {
    var a, l, c;
    let u = e
        , f = !1
        , d = {
            ...o
        }
        , p = Array.from(u.matchAll(Qi))
        , v = await Promise.all(p.map(async h => {
            var y;
            let w = h?.[0]
                , C = h?.[1];
            if (!w || !C)
                throw new Error("Failed to replace path variables: unexpected regex match group");
            let S = o[C];
            if (!S || !Ki(S))
                throw new Error(`No slug found for path variable ${C}`);
            let T = await ((y = s?.[i]) === null || y === void 0 ? void 0 : y.call(s));
            if (!T || !t)
                return S;
            let R = await T.getRecordIdBySlug(S, t);
            if (!R)
                return S;
            let F = await T.getSlugByRecordId(R, n);
            if (!F) {
                f = !0;
                let P = await T.getSlugByRecordId(R, r);
                return P && (d[C] = P),
                    P ?? S
            }
            return d[C] = F,
                F
        }
        ))
        , g = 0
        , b = ""
        , m = !1;
    for (let h = 0; h < p.length; h++) {
        let y = p[h]
            , w = v[h];
        !y || !w || (b += u.substring(g, y.index),
            g = ((a = y.index) !== null && a !== void 0 ? a : 0) + ((c = (l = y[0]) === null || l === void 0 ? void 0 : l.length) !== null && c !== void 0 ? c : 0),
            b += v[h],
            m = !0)
    }
    return m && (u = b),
    {
        path: u,
        pathVariables: d,
        isMissingInLocale: f
    }
}
async function lL({ currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: o, preserveQueryParams: s }) {
    let { path: a } = r
        , l = {
            path: a,
            pathVariables: i,
            isMissingInLocale: !1
        };
    if (!a)
        return l;
    if (i && r.collectionId)
        try {
            l = await aL(a, e, t, n, r.collectionId, i, o)
        } catch { }
    return t.slug && (l.path = "/" + t.slug + l.path),
        s && l.path && (l.path = Ak(l.path)),
        l
}
function cL(e, t, { global: n, routes: r }) {
    var i;
    return ((i = r[e]) === null || i === void 0 ? void 0 : i[t]) || n
}
var uL = {
    global: void 0,
    routes: {}
}
    , $k = x.createContext(uL);
function _H({ children: e, value: t }) {
    return k($k.Provider, {
        value: t,
        children: e
    })
}
function fL() {
    return x.useContext($k)
}
var am = 10
    , dL = 1e4;
function hL(e) {
    let t = am
        , n = e.next(0)
        , r = [n.value];
    for (; !n.done && t < dL;)
        n = e.next(t),
            r.push(n.value),
            t += am;
    return r.length === 1 && r.push(n.value),
    {
        easing: `linear(${r.join(",")})`,
        duration: t - am
    }
}
var Br = e => `--view-transition-${e}`;
function Lm(e) {
    return [parseFloat(e), e.endsWith("px") ? "px" : "%"]
}
function Nk(e) {
    let { innerWidth: t, innerHeight: n } = I
        , [r, i] = Lm(e.x)
        , [o, s] = Lm(e.y);
    return {
        x: i === "px" ? r : t * (r / 100),
        y: s === "px" ? o : n * (o / 100)
    }
}
var pL = {
    makeKeyframe: (e, t, n) => {
        let r = 0;
        return (n === "exit" && e.angularDirection === "clockwise" && t === "start" || n === "exit" && e.angularDirection === "counter-clockwise" && t === "end" || n === "enter" && e.angularDirection === "counter-clockwise" && t === "start" || n === "enter" && e.angularDirection === "clockwise" && t === "end") && (r = e.sweepAngle / 360 * 100),
            `${Br("conic-offset")}: ${r}%;`
    }
    ,
    makeStyles: (e, t) => {
        let n = `var(${Br("conic-offset")})`
            , r = t === "exit" && e.angularDirection === "clockwise" || t === "enter" && e.angularDirection === "counter-clockwise"
            , i = r ? "transparent" : "black"
            , o = r ? "black" : "transparent"
            , s = "conic-gradient(from ";
        return s += `${e.angle}deg at ${e.x} ${e.y}, `,
            s += `${i} 0%, ${i} ${n}, `,
            s += `${o} ${n}, ${o} 100%)`,
            `mask-image: ${s}; -webkit-mask-image: ${s};`
    }
    ,
    makePropertyRules: () => `
        @property ${Br("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `
}
    , mL = {
        makeKeyframe: (e, t) => {
            let { x: n, y: r } = Nk(e);
            return t === "start" ? `clip-path: circle(0 at ${n}px ${r}px);` : `clip-path: circle(${Math.hypot(Math.max(n, I.innerWidth - n), Math.max(r, I.innerHeight - r))}px at ${n}px ${r}px);`
        }
    }
    , gL = {
        makeKeyframe: (e, t) => {
            let { x: n, y: r } = Nk(e)
                , i = I.innerHeight - r
                , o = I.innerWidth - n;
            return t === "start" ? `clip-path: inset(${r}px ${o}px ${i}px ${n}px round ${e.round}px);` : "clip-path: inset(0 round 0);"
        }
    }
    , vL = {
        makeKeyframe: (e, t, n) => {
            let [, r] = Lm(e.width)
                , i = `0${r}`;
            return (t === "start" && n === "exit" || t === "end" && n === "enter") && (i = e.width),
                `${Br("blinds-width")}: ${i};`
        }
        ,
        makeStyles: (e, t) => {
            let n = `var(${Br("blinds-width")})`
                , r = t === "exit" ? "transparent" : "black"
                , i = t === "exit" ? "black" : "transparent"
                , o = "repeating-linear-gradient(";
            return o += e.angle + 90 + "deg, ",
                o += `${r} 0px, ${r} ${n}, `,
                o += `${i} ${n}, ${i} ${e.width})`,
                `mask-image: ${o}; -webkit-mask-image: ${o};`
        }
        ,
        makePropertyRules: () => `
            @property ${Br("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `
    }
    , yL = {
        makeKeyframe: (e, t, n) => {
            let r = t === "start" && n === "exit" || t === "end" && n === "enter" ? 1 : 0;
            return `${Br("wipe-offset")}: ${r};`
        }
        ,
        makeStyles: (e, t) => {
            let n = `var(${Br("wipe-offset")})`
                , r = t === "exit" ? "transparent" : "black"
                , i = t === "exit" ? "black" : "transparent"
                , o = "linear-gradient(";
            return o += e.angle + 90 + "deg, ",
                o += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `,
                o += `${i} calc(calc(100% + ${e.width}) * ${n}))`,
                `mask-image: ${o}; -webkit-mask-image: ${o};`
        }
        ,
        makePropertyRules: () => `
            @property ${Br("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `
    }
    , bL = {
        circle: mL,
        conic: pL,
        inset: gL,
        blinds: vL,
        wipe: yL
    }
    , xL = {
        opacity: 1,
        x: "0px",
        y: "0px",
        scale: 1,
        rotate: 0,
        rotateX: 0,
        rotateY: 0,
        mask: void 0
    };
function qS(e, t, n, r) {
    var i;
    let o = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `;
    return e.mask && (o += ((i = r?.makeKeyframe) === null || i === void 0 ? void 0 : i.call(r, e.mask, t, n)) || ""),
        o
}
function wL(e) {
    return e ? bL[e] : void 0
}
function XS(e, { transition: t, ...n }) {
    var r;
    let i = "view-transition-" + e
        , o = {
            duration: "0s",
            easing: "linear"
        };
    if (t.type === "tween")
        o.duration = t.duration + "s",
            o.easing = `cubic-bezier(${t.ease.join(",")})`;
    else if (SL(t)) {
        let { easing: c, duration: u } = hL(Ls({
            keyframes: [0, 1],
            ...kL(t),
            restDelta: .001,
            restSpeed: 1e-4
        }));
        o.duration = u + "ms",
            o.easing = c
    }
    let s = wL((r = n?.mask) === null || r === void 0 ? void 0 : r.type)
        , a = qS(n, "start", e, s)
        , l = qS({
            ...xL,
            mask: n.mask
        }, "end", e, s);
    return e === "exit" && ([a, l] = [l, a]),
        `
        ${n.mask && s?.makePropertyRules ? s.makePropertyRules(n.mask) : ""}

        @keyframes ${i} {
            0% {
                ${a}
            }

            100% {
                ${l}
            }
        }

        ::view-transition-${e === "enter" ? "new" : "old"}(root) {
            animation-name: ${i};
            animation-duration: ${o.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${o.easing};
            animation-fill-mode: both;
            ${n.mask && s?.makeStyles ? s.makeStyles(n.mask, e) : ""}
        }
    `
}
function SL(e) {
    return e.type === "spring"
}
function kL(e) {
    return e.durationBasedSpring ? {
        duration: e.duration,
        bounce: e.bounce
    } : {
        stiffness: e.stiffness,
        damping: e.damping,
        mass: e.mass
    }
}
var jk = "view-transition-styles"
    , CL = {
        x: "0px",
        y: "0px",
        scale: 1,
        opacity: 1,
        rotate3d: !1,
        rotate: 0,
        rotateX: 0,
        rotateY: 0,
        mask: void 0,
        transition: {
            type: "tween",
            delay: 0,
            duration: .2,
            ease: [.27, 0, .51, 1],
            stiffness: 400,
            damping: 30,
            mass: 1
        }
    };
function TL({ exit: e = CL, enter: t }) {
    let n = document.createElement("style");
    n.id = jk;
    let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `;
    (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `),
        r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `,
        r += XS("exit", e),
        r += XS("enter", t),
        n.textContent = r,
        document.head.appendChild(n)
}
var RL = (() => typeof I < "u" ? I.requestIdleCallback || I.setTimeout : setTimeout)();
function EL() {
    RL(() => {
        J.render(() => {
            performance.mark("framer-vt-remove");
            let e = document.getElementById(jk);
            e && document.head.removeChild(e)
        }
        )
    }
    )
}
var YS = () => { }
    ;
function FL() {
    return !!document.startViewTransition
}
function PL(e) {
    return new Promise(t => {
        J.render(() => {
            performance.mark("framer-vt-style"),
                TL(e),
                t()
        }
        )
    }
    )
}
async function KS(e, t, n) {
    if (!FL()) {
        e();
        return
    }
    if (await PL(t),
        n?.aborted)
        return;
    performance.mark("framer-vt");
    let r = document.startViewTransition(async () => {
        performance.mark("framer-vt-freeze"),
            !n?.aborted && (n?.addEventListener("abort", () => r.skipTransition()),
                await e())
    }
    );
    return r.updateCallbackDone.then(() => {
        performance.mark("framer-vt-unfreeze")
    }
    ).catch(YS),
        Promise.all([r.ready, r.finished]).then(() => {
            performance.mark("framer-vt-finished"),
                EL()
        }
        ).catch(YS),
        r
}
function Hk() {
    let e = fL()
        , t = V(void 0);
    return H(() => {
        t.current && (t.current(),
            t.current = void 0)
    }
    ),
        Q((n, r, i, o, s) => {
            let a = cL(n, r, e);
            if (a) {
                let l = new Promise(f => {
                    t.current = f
                }
                )
                    , c = async () => {
                        i(),
                            await l
                    }
                    , u = async () => (await Zi({
                        priority: "user-blocking",
                        signal: s
                    }).catch(Qm),
                        KS(c, a, s));
                return o ? u() : KS(c, a)
            } else
                return i()
        }
            , [e])
}
function Wk(e) {
    let t = `${e}-start`
        , n = `${e}-end`
        , r = V(void 0);
    return oL(() => {
        r.current && (r.current(),
            r.current = void 0)
    }
        , void 0, {
        priority: "user-blocking"
    }),
        Q(() => {
            let i = new Promise(o => {
                r.current = o
            }
            );
            return performance.mark(t),
                i.finally(() => {
                    performance.mark(n),
                        performance.measure(e, t, n)
                }
                ).catch(o => {
                    console.error(o)
                }
                )
        }
            , [e, t, n])
}
async function QS(e, t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, localeId: s, preserveQueryParams: a }, l = !1, c = !1) {
    let { path: u } = t;
    if (u)
        try {
            let f = Xu(t, {
                currentRoutePath: n,
                currentPathVariables: r,
                hash: i,
                pathVariables: o,
                preserveQueryParams: a
            });
            return await Uk({
                routeId: e,
                hash: i,
                pathVariables: o,
                localeId: s
            }, f, l, c)
        } catch { }
}
function _L(e) {
    let t = "routeId";
    return Na(e) && Ki(e[t])
}
function IL(e, t, n = !1) {
    performance.mark("framer-history-replace"),
        (n ? I.history.__proto__.replaceState : I.history.replaceState).call(I.history, e, "", t)
}
var au = !0
    , ZS = (() => {
        if (typeof _e > "u")
            return !1;
        let e = _e.userAgent
            , t = e.indexOf("Chrome/")
            , n = +e.slice(t + 7, e.indexOf(".", t));
        return n > 101 && n < 128
    }
    )();
async function Uk(e, t, n = !1, r = !1) {
    if (n && await Zi({
        priority: "user-blocking"
    }),
        performance.mark("framer-history-push"),
        !r) {
        I.history.pushState(e, "", t);
        return
    }
    let i = !1, o;
    au && (o = () => {
        var s;
        if (i = !0,
            ZS)
            return;
        let a = "Popstate called after intercept(). Please report this to the Framer team.";
        console.error(a),
            (s = I.__framer_events) === null || s === void 0 || s.push(["published_site_load_recoverable_error", {
                message: a,
                userAgent: _e.userAgent
            }])
    }
        ,
        I.addEventListener("popstate", o, {
            once: !0
        })),
        ZS && au ? I.history.__proto__.pushState.call(I.history, e, "", t) : I.history.pushState(e, "", t),
        au && queueMicrotask(() => {
            i || (au = !1,
                I.removeEventListener("popstate", o))
        }
        )
}
function OL({ disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r }) {
    ze(() => {
        e || (performance.mark("framer-history-set-initial-state"),
            IL({
                routeId: t,
                pathVariables: n,
                localeId: r
            }, void 0, !0))
    }
        , [])
}
function ML(e, t) {
    let n = Hk()
        , r = Wk("framer-route-change-popstate")
        , i = V(void 0)
        , o = Q(async ({ state: a }) => {
            var l, c, u, f, d, p;
            if (!((l = I.navigation) === null || l === void 0) && l.transition && ((u = (c = I.navigation) === null || c === void 0 ? void 0 : c.transition) === null || u === void 0 ? void 0 : u.navigationType) !== "traverse" || !Na(a))
                return;
            let { routeId: v, hash: g, pathVariables: b, localeId: m } = a;
            if (!Ki(v))
                return;
            r();
            let h = () => {
                t(v, Ki(m) ? m : void 0, Ki(g) ? g : void 0, Na(b) ? b : void 0, !1, !0)
            }
                , y = await n(e.current, v, h, !1);
            y ? y.updateCallbackDone.then((f = i.current) === null || f === void 0 ? void 0 : f.resolve).catch((d = i.current) === null || d === void 0 ? void 0 : d.reject) : (p = i.current) === null || p === void 0 || p.resolve()
        }
            , [e, r, t, n])
        , s = Q(a => {
            a.navigationType === "traverse" && a.intercept({
                async handler() {
                    await new Promise((l, c) => {
                        i.current = {
                            resolve: l,
                            reject: c
                        }
                    }
                    ),
                        i.current = void 0
                },
                scroll: "after-transition"
            })
        }
            , []);
    H(() => {
        var a;
        return I.addEventListener("popstate", o),
            (a = I.navigation) === null || a === void 0 || a.addEventListener("navigate", s),
            () => {
                var l;
                I.removeEventListener("popstate", o),
                    (l = I.navigation) === null || l === void 0 || l.removeEventListener("navigate", s)
            }
    }
        , [o, s])
}
function LL(e, t, n) {
    let r = qu(t, e);
    if (!r)
        return;
    let i = Object.assign({}, t?.elements, n);
    return r.replace(Qi, (o, s) => {
        var a;
        return String((a = i[s]) !== null && a !== void 0 ? a : o)
    }
    )
}
function Xu(e, { currentRoutePath: t, currentPathVariables: n, hash: r, pathVariables: i, hashVariables: o, relative: s = !0, preserveQueryParams: a }) {
    var l;
    let c = t ?? "/";
    n && (c = c.replace(Qi, (v, g) => String(n[g] || v)));
    let f = (l = e?.path) !== null && l !== void 0 ? l : "/";
    i && (f = f.replace(Qi, (v, g) => String(i[g] || v)));
    let d = LL(r, e, o)
        , p = c === f && d;
    return s && (f = Vk(c, f)),
        (a || p) && (f = Ak(f)),
        d && (f = `${f}#${d}`),
        f
}
async function VL(e, t, n) {
    if (!e.path || !t)
        return !1;
    let i = `${n.slug ? `/${n.slug}` : ""}${Lk(e.path, t)}`;
    return (await fetch(i, {
        method: "HEAD",
        redirect: "manual"
    })).type === "opaqueredirect" ? (I.location.href = I.location.origin + i,
        !0) : !1
}
async function AL(e) {
    let t = await lL(e);
    if (t) {
        try {
            localStorage.setItem("preferredLocale", e.nextLocale.code)
        } catch { }
        try {
            if (!Ki(t.path))
                throw new Error("Expected result.path to be a string");
            if (t.isMissingInLocale && await VL(e.route, t.pathVariables, e.nextLocale))
                return
        } catch { }
        return t
    }
}
function DL() {
    let e = V(Promise.resolve())
        , t = V()
        , n = Q(r => {
            if (r.navigationType === "traverse")
                return;
            let i = t.current;
            i?.signal.addEventListener("abort", () => {
                i.abort("user aborted")
            }
            ),
                r.intercept({
                    handler: () => e.current
                })
        }
            , []);
    return Q((r, i, o) => {
        if (!I.navigation) {
            i();
            return
        }
        e.current = r,
            t.current = o,
            I.navigation.addEventListener("navigate", n),
            i(!0),
            r.catch(Qm).finally(() => {
                I.navigation.removeEventListener("navigate", n)
            }
            )
    }
        , [n])
}
function Dr(e, t, n) {
    try {
        performance.measure(e, t, n)
    } catch (r) {
        console.warn(`Could not measure ${e}`, r)
    }
}
var pr = !1;
function MH() {
    pr = !0,
        performance.mark("framer-hydration-start")
}
var JS = !1
    , e1 = !1
    , t1 = !1;
function zL() {
    let e = "framer-hydration-router";
    ht(() => {
        JS || !pr || (JS = !0,
            performance.mark(`${e}-insertion-effect`))
    }
        , []),
        ze(() => {
            e1 || !pr || (e1 = !0,
                performance.mark(`${e}-layout-effect`))
        }
            , []),
        H(() => {
            t1 || !pr || (t1 = !0,
                performance.mark(`${e}-effect`))
        }
            , [])
}
var n1 = !1
    , r1 = !1
    , i1 = !1
    , Gk = !1;
function BL() {
    let e = "framer-hydration-"
        , t = `${e}layout-effects-end`
        , n = `${e}effects-end`
        , r = `${e}browser-render-start`
        , i = `${e}render-end`;
    return ht(() => {
        n1 || !pr || (n1 = !0,
            performance.mark(i),
            Dr(`${e}render`, `${e}start`, i),
            performance.mark(`${e}insertion-effects-start`))
    }
        , []),
        ze(() => {
            if (!(r1 || !pr)) {
                if (r1 = !0,
                    performance.mark(`${e}layout-effects-start`),
                    document.visibilityState !== "visible") {
                    Gk = !0;
                    return
                }
                requestAnimationFrame(() => {
                    var o, s, a;
                    performance.mark(r),
                        Dr(`${e}uho`, (s = (o = performance.getEntriesByName(n)[0]) === null || o === void 0 ? void 0 : o.name) !== null && s !== void 0 ? s : (a = performance.getEntriesByName(t)[0]) === null || a === void 0 ? void 0 : a.name, r)
                }
                )
            }
        }
            , []),
        H(() => {
            var o;
            if (i1 || !pr)
                return;
            i1 = !0;
            let s = `${e}effects-start`;
            performance.mark(s),
                ((o = performance.getEntriesByName(r)[0]) === null || o === void 0 ? void 0 : o.name) || (Dr(`${e}commit`, t, s),
                    performance.mark(`${e}effects-sync`))
        }
            , []),
        null
}
var o1 = !1
    , s1 = !1
    , a1 = !1;
function $L() {
    let e = "framer-hydration-"
        , t = `${e}layout-effects-end`
        , n = `${e}effects-end`
        , r = `${e}browser-render-start`
        , i = `${e}start`
        , o = `${e}insertion-effects-end`
        , s = `${e}first-paint`
        , a = `${e}browser-raf-end`;
    return ht(() => {
        o1 || !pr || (o1 = !0,
            performance.mark(o),
            Dr(`${e}insertion-effects`, `${e}insertion-effects-start`, o))
    }
        , []),
        ze(() => {
            s1 || !pr || (s1 = !0,
                performance.mark(t),
                Dr(`${e}layout-effects`, `${e}layout-effects-start`, t),
                !(Gk || document.visibilityState !== "visible") && requestAnimationFrame(() => {
                    performance.mark(a),
                        Dr(`${e}raf`, r, a),
                        Bk(() => {
                            performance.mark(s),
                                Dr(`${e}time-to-first-paint`, i, s),
                                Dr(`${e}browser-render`, a, s)
                        }
                        )
                }
                ))
        }
            , []),
        H(() => {
            var l, c, u;
            a1 || !pr || (a1 = !0,
                performance.mark(n),
                Dr(`${e}effects`, (c = (l = performance.getEntriesByName(s)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(`${e}effects-start`)[0]) === null || u === void 0 ? void 0 : u.name, n))
        }
            , []),
        null
}
function NL() {
    return BL(),
        null
}
function jL() {
    return $L(),
        null
}
var l1 = {
    Start: NL,
    End: jL
}
    , Va = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset"]
    , qk = e => {
        var t, n;
        !((n = (t = e.target) === null || t === void 0 ? void 0 : t.closest) === null || n === void 0) && n.call(t, "#main") && (e.stopPropagation(),
            performance.mark("framer-react-event-handling-prevented"))
    }
    , Xk = !1;
function VH() {
    if (!Va)
        return;
    Xk = !0,
        performance.mark("framer-react-event-handling-start");
    let e = {
        capture: !0
    };
    Va.forEach(t => document.body.addEventListener(t, qk, e))
}
function HL() {
    return H(() => {
        if (!Xk || !Va)
            return;
        let e = {
            capture: !0
        };
        Va.forEach(t => document.body.removeEventListener(t, qk, e)),
            Va = void 0,
            performance.mark("framer-react-event-handling-end")
    }
        , []),
        null
}
var Zm = !1;
function DH() {
    Zm = !0
}
function WL() {
    Zm = !1
}
function UL() {
    let e = V(typeof I > "u" || Zm);
    return H(() => {
        e.current = !1
    }
        , []),
        e
}
function GL(e, t) {
    if (e.routeId !== t.routeId)
        return !1;
    if (e.pathVariables === t.pathVariables)
        return !0;
    let n = e.pathVariables || {}
        , r = t.pathVariables || {};
    return n.length === r.length && Object.keys(n).every(i => n[i] === r[i])
}
function Yk(e) {
    return x.useCallback(t => e[t], [e])
}
var Jm = (() => x.createContext({}))();
function qL({ api: e, children: t }) {
    return k(Jm.Provider, {
        value: e,
        children: t
    })
}
function bi() {
    return x.useContext(Jm)
}
function XL({ routes: e, children: t }) {
    let n = Yk(e);
    return k(Jm.Provider, {
        value: {
            getRoute: n
        },
        children: t
    })
}
var YL = class extends ke {
    constructor() {
        super(...arguments),
            this.state = {
                error: void 0
            }
    }
    static getDerivedStateFromError(e) {
        return e instanceof bu || console.error("Derived error in SuspenseErrorBoundary", e),
        {
            error: e
        }
    }
    componentDidCatch(e, t) {
        var n;
        if (e instanceof bu)
            return;
        let r = t?.componentStack;
        if (console.error("Caught error in SuspenseErrorBoundary", e, r),
            typeof I < "u") {
            let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null;
            (n = I.__framer_events) === null || n === void 0 || n.push(["published_site_load_recoverable_error", {
                message: String(e),
                stack: i,
                componentStack: i ? void 0 : r
            }])
        }
    }
    render() {
        if (this.state.error === void 0)
            return this.props.children;
        if (this.state.error instanceof bu)
            throw this.state.error.cause;
        return I.__framer_STPD_OPT_OUT__ = !0,
            k(br, {
                children: this.props.fallbackChildren
            })
    }
}
    , KL = (() => typeof I < "u" ? new Promise(() => { }
    ) : null)();
function QL() {
    if (typeof I > "u" || I.__framer_STPD_OPT_OUT__)
        return null;
    throw KL
}
function eg({ children: e }) {
    return k(YL, {
        fallbackChildren: e,
        children: k(br, {
            fallback: k(QL, {}),
            children: e
        })
    })
}
var c1 = "default";
function ZL() {
    let [e, t] = x.useState(0);
    return [e, x.useCallback(() => t(n => n + 1), [])]
}
var JL = async () => { }
    , eV = {
        activeLocale: null,
        locales: [],
        setLocale: JL
    }
    , Kk = x.createContext(eV);
function Yu() {
    return x.useContext(Kk)
}
function u1(e, t, n) {
    let r = e && document.getElementById(e);
    if (r) {
        oV(r, t);
        return
    }
    n || I.scrollTo(0, 0)
}
function tV(e) {
    let t = V([]);
    return ze(() => {
        var n;
        !((n = t.current) === null || n === void 0) && n.length && (t.current.forEach(r => r()),
            t.current = [])
    }
        , [e]),
        Q(n => {
            t.current.push(n)
        }
            , [])
}
function nV(e) {
    let t = DL()
        , n = Wk("framer-route-change")
        , r = V(void 0);
    return Q(async (i, o, s = !0) => {
        var a;
        if (WL(),
            !e)
            return await o?.(),
                i(),
                n(),
                new Promise(p => {
                    p()
                }
                );
        (a = r.current) === null || a === void 0 || a.abort();
        let l = s ? new AbortController : void 0;
        r.current = l;
        let c = l?.signal
            , u = n();
        if (!o)
            return r.current = void 0,
                i(c),
                u;
        let f, d = new Promise((p, v) => {
            f = p,
                c?.aborted ? v() : c?.addEventListener("abort", v)
        }
        );
        return await Zi({
            priority: "user-blocking",
            signal: c
        }).catch(Qm),
            i(c),
            t(d, o, l),
            u.then(() => {
                f()
            }
            )
    }
        , [e, n, t])
}
function rV({ defaultPageStyle: e, disableHistory: t, initialPathVariables: n, initialRoute: r, notFoundPage: i, collectionUtils: o, routes: s, initialLocaleId: a, locales: l = sL, preserveQueryParams: c = !1, enableAsyncURLUpdates: u = !1, LayoutTemplate: f, editorBar: d }) {
    zL(),
        OL({
            disabled: t,
            routeId: r,
            initialPathVariables: n,
            initialLocaleId: a
        });
    let p = Hk()
        , [v, g] = ZL()
        , b = tV(v)
        , m = nV(u)
        , h = V(r)
        , y = V(n)
        , w = V(a)
        , C = w.current
        , S = ue(() => {
            var Y;
            return (Y = l.find(({ id: ne }) => C ? ne === C : ne === c1)) !== null && Y !== void 0 ? Y : null
        }
            , [C, l])
        , T = ue(() => ({
            activeLocale: S,
            locales: l,
            setLocale: async Y => {
                let ne;
                Ki(Y) ? ne = Y : Na(Y) && (ne = Y.id);
                let G = l.find(({ id: q }) => q === c1)
                    , he = l.find(({ id: q }) => q === ne);
                if (!he)
                    return;
                let se = h.current
                    , le = s[se];
                if (le)
                    try {
                        let q = await AL({
                            currentLocale: S,
                            nextLocale: he,
                            route: le,
                            routeId: se,
                            defaultLocale: G,
                            pathVariables: y.current,
                            collectionUtils: o,
                            preserveQueryParams: c
                        });
                        if (!q)
                            return;
                        let Je = y.current
                            , Re = _L(I.history.state) ? I.history.state.paginationInfo : void 0
                            , et = q.path;
                        y.current = q.pathVariables,
                            w.current = he.id,
                            m(() => {
                                p(se, se, () => at(g), u)
                            }
                                , async (mn = !1) => {
                                    if (et)
                                        return Uk({
                                            routeId: se,
                                            pathVariables: Je,
                                            localeId: he.id,
                                            paginationInfo: Re
                                        }, et, !1, mn)
                                }
                                , !1)
                    } catch { }
            }
        }), [S, o, u, g, l, c, s, m, p])
        , R = Q((Y, ne, G, he, se = !1, le = !1, q) => {
            let Je = h.current;
            if (h.current = Y,
                y.current = he,
                w.current = ne,
                b(() => {
                    u1(G, se, le)
                }
                ),
                le) {
                at(g);
                return
            }
            m(Re => {
                p(Je, Y, () => at(g), u, Re)
            }
                , q)
        }
            , [u, g, b, m, p]);
    ML(h, R);
    let F = Q(async (Y, ne, G, he) => {
        var se, le;
        let q = s[Y];
        if (G) {
            let Tt = new Set
                , qn = (se = q?.path) !== null && se !== void 0 ? se : "/";
            for (let pe of qn.matchAll(Qi)) {
                let Jt = pe[1];
                if (Jt === void 0)
                    throw new Error("A matching path variable should not be undefined");
                Tt.add(Jt)
            }
            G = Object.fromEntries(Object.entries(G).filter(([pe]) => Tt.has(pe)))
        }
        let Je = qu(q, ne)
            , Re = y.current
            , et = w.current;
        if (GL({
            routeId: h.current,
            pathVariables: Re
        }, {
            routeId: Y,
            pathVariables: G
        })) {
            let Tt = s[Y];
            ((le = I.history.state) === null || le === void 0 ? void 0 : le.hash) !== ne && !t && Tt && await QS(Y, Tt, {
                currentRoutePath: Tt.path,
                currentPathVariables: Re,
                pathVariables: G,
                hash: ne,
                localeId: et,
                preserveQueryParams: c
            }, u),
                u1(Je, he, !1);
            return
        }
        if (!q)
            return;
        let Pe = s[h.current];
        R(Y, et, Je, G, he, !1, t ? void 0 : async (Tt = !1) => QS(Y, q, {
            currentRoutePath: Pe?.path,
            currentPathVariables: Re,
            hash: ne,
            pathVariables: G,
            localeId: et,
            preserveQueryParams: c
        }, !1, Tt))
    }
        , [s, R, t, c, u])
        , P = Yk(s)
        , B = h.current
        , $ = y.current
        , N = ue(() => ({
            navigate: F,
            getRoute: P,
            currentRouteId: B,
            currentPathVariables: $,
            routes: s,
            collectionUtils: o,
            preserveQueryParams: c
        }), [F, P, B, $, s, o, c])
        , U = s[h.current];
    if (!U)
        throw new Error(`Router cannot find route for ${h.current}`);
    let j = !S || !U.includedLocales || U.includedLocales.includes(S.id)
        , ae = U.path && $ ? Lk(U.path, $) : U.path
        , te = String(C) + ae;
    return k(qL, {
        api: N,
        children: k(Kk.Provider, {
            value: T,
            children: ge(eg, {
                children: [k(ZM, {
                    notFoundPage: i,
                    defaultPageStyle: e,
                    forceUpdateKey: v,
                    children: k(iV, {
                        LayoutTemplate: f,
                        routeId: B,
                        children: ge(bn, {
                            children: [k(l1.Start, {}), j ? Mm(U.page, f ? {
                                ...e,
                                display: "content"
                            } : e) : i && Mm(i, e)]
                        }, te)
                    })
                }), k(HL, {}), k(l1.End, {}), d]
            })
        })
    })
}
function iV({ LayoutTemplate: e, routeId: t, children: n }) {
    return e ? k(e, {
        routeId: t,
        children: n
    }) : n
}
function oV(e, t) {
    let n = t ? {
        behavior: "smooth",
        block: "start",
        inline: "nearest"
    } : void 0;
    e.scrollIntoView(n)
}
var lu, lm, f1;
function sV(e) {
    if (f1 !== e) {
        lu = {};
        for (let [t, { path: n }] of Object.entries(e))
            n && (lu[n] = {
                path: n,
                depth: aV(n),
                routeId: t
            });
        lm = Object.values(lu),
            lm.sort(({ depth: t }, { depth: n }) => n - t),
            f1 = e
    }
    return [lu, lm]
}
function Qk(e, t, n = !0, r = []) {
    let [i, o] = sV(e), s, a, l = t;
    if (r.length > 0) {
        let d = l.split("/").find(Boolean);
        if (d && (s = r.find(({ slug: p }) => p === d),
            s && (a = s.id,
                l = l.substring(s.slug.length + 1))),
            !a) {
            let p = r.find(({ slug: v }) => v === "");
            p && (a = p.id)
        }
    }
    let c = i[l];
    if (c) {
        let d = d1(l, c.path);
        if (d.isMatch)
            return {
                routeId: c.routeId,
                localeId: a,
                pathVariables: d.pathVariables
            }
    }
    for (let { path: d, routeId: p } of o) {
        let v = d1(l, d);
        if (v.isMatch)
            return {
                routeId: p,
                localeId: a,
                pathVariables: v.pathVariables
            }
    }
    if (!n)
        throw new Error("No exact match found for path");
    let u = i["/"];
    if (u)
        return {
            routeId: u.routeId,
            localeId: a
        };
    let f = Object.keys(e)[0];
    if (!f)
        throw new Error("Router should not have undefined routes");
    return {
        routeId: f,
        localeId: a
    }
}
function aV(e) {
    let t = e.replace(/^\/|\/$/gu, "");
    return t === "" ? 0 : t.split("/").length
}
function d1(e, t) {
    let n = []
        , i = lV(t).replace(Qi, (c, u) => (n.push(u),
            "([^/]+)"))
        , o = new RegExp(i + "$")
        , s = e.match(o);
    if (!s)
        return {
            isMatch: !1
        };
    if (s.length === 1)
        return {
            isMatch: !0
        };
    let a = {}
        , l = s.slice(1);
    for (let c = 0; c < n.length; ++c) {
        let u = n[c];
        if (u === void 0)
            continue;
        let f = l[c]
            , d = a[u];
        if (d) {
            if (d !== f)
                return {
                    isMatch: !1
                };
            continue
        }
        if (f === void 0)
            throw new Error("Path variable values cannot be undefined");
        a[u] = f
    }
    return {
        isMatch: !0,
        pathVariables: a
    }
}
function lV(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d")
}
var cV = "page";
function h1(e) {
    return Na(e) && cV in e && e.page !== void 0
}
var uV = (() => x.createContext(void 0))();
function ro() {
    var e;
    let t = bi()
        , n = D(uV)
        , r = n ?? t.currentRouteId;
    if (!r)
        return;
    let i = (e = t.getRoute) === null || e === void 0 ? void 0 : e.call(t, r);
    if (i)
        return {
            ...i,
            id: r,
            pathVariables: n ? void 0 : t.currentPathVariables
        }
}
function KH() {
    var e;
    return (e = ro()) === null || e === void 0 ? void 0 : e.pathVariables
}
function fV(e) {
    var t;
    let n = bi();
    if (e)
        return (t = n.getRoute) === null || t === void 0 ? void 0 : t.call(n, e)
}
var tg = (() => typeof I < "u" && !iL(_e.userAgent))();
function dV(e, t = !0) {
    let { getRoute: n } = bi();
    H(() => {
        if (!(!n || !t || !tg))
            for (let r of e)
                Zk(n(r))
    }
        , [e, n, t])
}
async function Zk(e) {
    if (!tg || !e)
        return;
    let t = e.page;
    if (!(!t || !Dk(t))) {
        await zk();
        try {
            await t.preload()
        } catch { }
    }
}
function e8(e, t) {
    var n;
    let r = ro()
        , i = (n = fV(t)) !== null && n !== void 0 ? n : r;
    return x.useMemo(() => i ? qu(i, e) : e, [e, i])
}
var p1 = new Set;
function ja(e, ...t) {
    p1.has(e) || (p1.add(e),
        console.warn(e, ...t))
}
function hV(e, t, n) {
    let r = n ? `, use ${n} instead` : ""
        , i = `Deprecation warning: ${e} will be removed in version ${t}${r}.`;
    ja(i)
}
var Jk = class {
    constructor() {
        E(this, "observers", new Set),
            E(this, "transactions", {})
    }
    add(e) {
        this.observers.add(e);
        let t = !1;
        return () => {
            t || (t = !0,
                this.remove(e))
        }
    }
    remove(e) {
        this.observers.delete(e)
    }
    notify(e, t) {
        if (t) {
            let n = this.transactions[t] || e;
            n.value = e.value,
                this.transactions[t] = n
        } else
            this.callObservers(e)
    }
    finishTransaction(e) {
        let t = this.transactions[e];
        return delete this.transactions[e],
            this.callObservers(t, e)
    }
    callObservers(e, t) {
        let n = [];
        return new Set(this.observers).forEach(r => {
            typeof r == "function" ? r(e, t) : (r.update(e, t),
                n.push(r.finish))
        }
        ),
            n
    }
}
    , ft = (() => {
        function e(t) {
            return hV("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)"),
                Wn(t) ? t : new mV(t)
        }
        return e.transaction = t => {
            let n = Math.random()
                , r = new Set;
            t((s, a) => {
                s.set(a, n),
                    r.add(s)
            }
                , n);
            let o = [];
            r.forEach(s => {
                o.push(...s.finishTransaction(n))
            }
            ),
                o.forEach(s => {
                    s(n)
                }
                )
        }
            ,
            e.getNumber = (t, n = 0) => e.get(t, n),
            e.get = (t, n) => t == null ? n : Wn(t) ? t.get() : t,
            e.objectToValues = t => {
                if (!t)
                    return t;
                let n = {};
                for (let r in t) {
                    let i = t[r];
                    Wn(i) ? n[r] = i.get() : n[r] = i
                }
                return n
            }
            ,
            e
    }
    )()
    , m1 = "onUpdate"
    , g1 = "finishTransaction";
function Wn(e) {
    return e !== null && typeof e == "object" && m1 in e && e[m1] instanceof Function && g1 in e && e[g1] instanceof Function
}
function pV(e, t) {
    return {
        interpolate(n, r) {
            let i = n.get()
                , o = r.get()
                , s = ft(i);
            return a => {
                let l = t.interpolate(i, o)(a);
                return s.set(l),
                    s
            }
        },
        difference(n, r) {
            let i = n.get();
            return t.difference(i, r.get())
        }
    }
}
var mV = class {
    constructor(e) {
        this.value = e,
            E(this, "observers", new Jk)
    }
    static interpolationFor(e, t) {
        if (Wn(e))
            return pV(e, t)
    }
    get() {
        return this.value
    }
    set(e, t) {
        let n = this.value;
        Wn(e) && (e = e.get()),
            this.value = e;
        let r = {
            value: e,
            oldValue: n
        };
        this.observers.notify(r, t)
    }
    finishTransaction(e) {
        return this.observers.finishTransaction(e)
    }
    onUpdate(e) {
        return this.observers.add(e)
    }
}
    ;
function cu(e, t) {
    let r = 10 ** Math.round(Math.abs(t));
    return Math.round(e * r) / r
}
function v1(e, t) {
    return t === 0 ? Math.round(e) : (t -= t | 0,
        t < 0 && (t = 1 - t),
        Math.round(e - t) + t)
}
function hn(e, t) {
    return {
        x: e,
        y: t
    }
}
(e => {
    e.add = (...i) => i.reduce((o, s) => ({
        x: o.x + s.x,
        y: o.y + s.y
    }), {
        x: 0,
        y: 0
    }),
        e.subtract = (i, o) => ({
            x: i.x - o.x,
            y: i.y - o.y
        }),
        e.multiply = (i, o) => ({
            x: i.x * o,
            y: i.y * o
        }),
        e.divide = (i, o) => ({
            x: i.x / o,
            y: i.y / o
        }),
        e.absolute = i => ({
            x: Math.abs(i.x),
            y: Math.abs(i.y)
        }),
        e.reverse = i => ({
            x: i.x * -1,
            y: i.y * -1
        }),
        e.pixelAligned = (i, o = {
            x: 0,
            y: 0
        }) => ({
            x: v1(i.x, o.x),
            y: v1(i.y, o.y)
        }),
        e.distance = (i, o) => {
            let s = Math.abs(i.x - o.x)
                , a = Math.abs(i.y - o.y);
            return Math.sqrt(s * s + a * a)
        }
        ,
        e.angle = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI - 90,
        e.angleFromX = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI,
        e.isEqual = (i, o) => i.x === o.x && i.y === o.y,
        e.rotationNormalizer = () => {
            let i;
            return o => {
                typeof i != "number" && (i = o);
                let s = i - o
                    , a = Math.abs(s) + 180
                    , l = Math.floor(a / 360);
                return s < 180 && (o -= l * 360),
                    s > 180 && (o += l * 360),
                    i = o,
                    o
            }
        }
        ;
    function t(i, o) {
        return {
            x: (i.x + o.x) / 2,
            y: (i.y + o.y) / 2
        }
    }
    e.center = t;
    function n(i) {
        let o = 0
            , s = 0;
        i.forEach(c => {
            o += c.x,
                s += c.y
        }
        );
        let a = o / i.length
            , l = s / i.length;
        return {
            x: a,
            y: l
        }
    }
    e.centroid = n;
    function r(i) {
        let o = e.centroid(i)
            , s = new Map;
        for (let a = 0; a < i.length; a++) {
            let l = i[a];
            s.set(l, Math.atan2(l.x - o.x, l.y - o.y))
        }
        return i.sort((a, l) => s.get(a) - s.get(l))
    }
    e.sortClockwise = r
}
)(hn || (hn = {}));
var Vm = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};
function pi(e, t, n, r = !1) {
    let [i, o] = t
        , [s, a] = n
        , l = o - i;
    if (l === 0)
        return (a + s) / 2;
    let c = a - s;
    if (c === 0)
        return s;
    let u = s + (e - i) / l * c;
    if (r === !0)
        if (s < a) {
            if (u < s)
                return s;
            if (u > a)
                return a
        } else {
            if (u > s)
                return s;
            if (u < a)
                return a
        }
    return u
}
function is(e) {
    return !Number.isNaN(e) && Number.isFinite(e)
}
function mi(e) {
    let t = Am(e);
    return t !== void 0 ? e.includes("%") ? t / 100 : t : 0
}
function Am(e) {
    let t = /\d?\.?\d+/u.exec(e);
    return t ? Number(t[0]) : void 0
}
var gV = (() => UM().Hsluv)()
    , Qt = new gV;
function vV(e, t, n) {
    return Qt.rgb_r = e / 255,
        Qt.rgb_g = t / 255,
        Qt.rgb_b = n / 255,
        Qt.rgbToHsluv(),
    {
        h: Qt.hsluv_h,
        s: Qt.hsluv_s,
        l: Qt.hsluv_l
    }
}
function yV(e, t, n, r = 1) {
    return Qt.hsluv_h = e,
        Qt.hsluv_s = t,
        Qt.hsluv_l = n,
        Qt.hsluvToRgb(),
    {
        r: Qt.rgb_r * 255,
        g: Qt.rgb_g * 255,
        b: Qt.rgb_b * 255,
        a: r
    }
}
function uu(e, t, n, r) {
    let i = Math.round(e)
        , o = Math.round(t * 100)
        , s = Math.round(n * 100);
    return r === void 0 || r === 1 ? "hsv(" + i + ", " + o + "%, " + s + "%)" : "hsva(" + i + ", " + o + "%, " + s + "%, " + r + ")"
}
function bV(e, t, n) {
    return {
        r: is(e) ? Ht(e, 255) * 255 : 0,
        g: is(t) ? Ht(t, 255) * 255 : 0,
        b: is(n) ? Ht(n, 255) * 255 : 0
    }
}
function y1(e, t, n, r) {
    let i = [um(Math.round(e).toString(16)), um(Math.round(t).toString(16)), um(Math.round(n).toString(16))];
    return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}
function ng(e, t, n) {
    let r, i, o = Ht(e, 255), s = Ht(t, 255), a = Ht(n, 255), l = Math.max(o, s, a), c = Math.min(o, s, a), u = i = r = (l + c) / 2;
    if (l === c)
        u = i = 0;
    else {
        let f = l - c;
        switch (i = r > .5 ? f / (2 - l - c) : f / (l + c),
        l) {
            case o:
                u = (s - a) / f + (s < a ? 6 : 0);
                break;
            case s:
                u = (a - o) / f + 2;
                break;
            case a:
                u = (o - s) / f + 4;
                break
        }
        u /= 6
    }
    return {
        h: u * 360,
        s: i,
        l: r
    }
}
function cm(e, t, n) {
    return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function xV(e, t, n) {
    let r, i, o;
    if (e = Ht(e, 360),
        t = Ht(t * 100, 100),
        n = Ht(n * 100, 100),
        t === 0)
        r = i = o = n;
    else {
        let s = n < .5 ? n * (1 + t) : n + t - n * t
            , a = 2 * n - s;
        r = cm(a, s, e + 1 / 3),
            i = cm(a, s, e),
            o = cm(a, s, e - 1 / 3)
    }
    return {
        r: r * 255,
        g: i * 255,
        b: o * 255
    }
}
function b1(e, t, n) {
    e = Ht(e, 255),
        t = Ht(t, 255),
        n = Ht(n, 255);
    let r = Math.max(e, t, n), i = Math.min(e, t, n), o = r - i, s, a = r === 0 ? 0 : o / r, l = r;
    if (r === i)
        s = 0;
    else {
        switch (r) {
            case e:
                s = (t - n) / o + (t < n ? 6 : 0);
                break;
            case t:
                s = (n - e) / o + 2;
                break;
            case n:
                s = (e - t) / o + 4;
                break
        }
        s /= 6
    }
    return {
        h: s,
        s: a,
        v: l
    }
}
function wV(e, t, n) {
    e = Ht(e, 360) * 6,
        t = Ht(t * 100, 100),
        n = Ht(n * 100, 100);
    let r = Math.floor(e)
        , i = e - r
        , o = n * (1 - t)
        , s = n * (1 - i * t)
        , a = n * (1 - (1 - i) * t)
        , l = r % 6
        , c = [n, s, o, o, a, n][l]
        , u = [a, n, n, s, o, o][l]
        , f = [o, o, a, n, n, s][l];
    return {
        r: c * 255,
        g: u * 255,
        b: f * 255
    }
}
function Ht(e, t) {
    let n, r;
    if (typeof t == "string" ? n = parseFloat(t) : n = t,
        typeof e == "string") {
        SV(e) && (e = "100%");
        let i = kV(e);
        r = Math.min(n, Math.max(0, parseFloat(e))),
            i && (r = Math.floor(r * n) / 100)
    } else
        r = e;
    return Math.abs(r - n) < 1e-6 ? 1 : r % n / n
}
function SV(e) {
    return typeof e == "string" && e.includes(".") && parseFloat(e) === 1
}
function kV(e) {
    return typeof e == "string" && e.includes("%")
}
function um(e) {
    return e.length === 1 ? "0" + e : "" + e
}
var ur = (() => {
    let e = "[-\\+]?\\d+%?"
        , n = "(?:" + "[-\\+]?\\d*\\.\\d+%?" + ")|(?:" + e + ")"
        , r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?"
        , i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?";
    return {
        rgb: new RegExp("rgb" + r),
        rgba: new RegExp("rgba" + i),
        hsl: new RegExp("hsl" + r),
        hsla: new RegExp("hsla" + i),
        hsv: new RegExp("hsv" + r),
        hsva: new RegExp("hsva" + i),
        hex3: /^([\da-f])([\da-f])([\da-f])$/iu,
        hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu,
        hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu,
        hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu
    }
}
)();
function rg(e) {
    if (e.includes("gradient(") || e.includes("var("))
        return !1;
    let t = /^[\s,#]+/u
        , n = e.replace(t, "").trimEnd().toLowerCase()
        , r = Vm[n];
    if (r && (n = r),
        n === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    let i;
    return (i = ur.rgb.exec(n)) ? {
        r: parseInt(i[1] ?? ""),
        g: parseInt(i[2] ?? ""),
        b: parseInt(i[3] ?? ""),
        a: 1,
        format: "rgb"
    } : (i = ur.rgba.exec(n)) ? {
        r: parseInt(i[1] ?? ""),
        g: parseInt(i[2] ?? ""),
        b: parseInt(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "rgb"
    } : (i = ur.hsl.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: mi(i[2] ?? ""),
        l: mi(i[3] ?? ""),
        a: 1,
        format: "hsl"
    } : (i = ur.hsla.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: mi(i[2] ?? ""),
        l: mi(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "hsl"
    } : (i = ur.hsv.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: mi(i[2] ?? ""),
        v: mi(i[3] ?? ""),
        a: 1,
        format: "hsv"
    } : (i = ur.hsva.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: mi(i[2] ?? ""),
        v: mi(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "hsv"
    } : (i = ur.hex8.exec(n)) ? {
        r: dn(i[1] ?? ""),
        g: dn(i[2] ?? ""),
        b: dn(i[3] ?? ""),
        a: x1(i[4] ?? ""),
        format: r ? "name" : "hex"
    } : (i = ur.hex6.exec(n)) ? {
        r: dn(i[1] ?? ""),
        g: dn(i[2] ?? ""),
        b: dn(i[3] ?? ""),
        a: 1,
        format: r ? "name" : "hex"
    } : (i = ur.hex4.exec(n)) ? {
        r: dn(`${i[1]}${i[1]}`),
        g: dn(`${i[2]}${i[2]}`),
        b: dn(`${i[3]}${i[3]}`),
        a: x1(i[4] + "" + i[4]),
        format: r ? "name" : "hex"
    } : (i = ur.hex3.exec(n)) ? {
        r: dn(`${i[1]}${i[1]}`),
        g: dn(`${i[2]}${i[2]}`),
        b: dn(`${i[3]}${i[3]}`),
        a: 1,
        format: r ? "name" : "hex"
    } : !1
}
function dn(e) {
    return parseInt(e, 16)
}
function x1(e) {
    return dn(e) / 255
}
var w1 = new Map
    , Z = (() => {
        function e(o, s, a, l) {
            if (typeof o == "string") {
                let u = w1.get(o);
                return u || (u = t(o),
                    u === void 0 ? {
                        ...e("black"),
                        isValid: !1
                    } : (w1.set(o, u),
                        u))
            }
            let c = t(o, s, a, l);
            return c !== void 0 ? c : {
                ...e("black"),
                isValid: !1
            }
        }
        function t(o, s, a, l) {
            if (o === "")
                return;
            let c = CV(o, s, a, l);
            if (c) {
                let u = {
                    r: c.r,
                    g: c.g,
                    b: c.b,
                    a: c.a,
                    h: c.h,
                    s: c.s,
                    l: c.l,
                    initialValue: typeof o == "string" && c.format !== "hsv" ? o : void 0,
                    roundA: Math.round(100 * c.a) / 100,
                    format: c.format,
                    mix: e.mix,
                    toValue: () => e.toRgbString(u)
                };
                return u
            } else
                return
        }
        let n = {
            isRGB(o) {
                return o === "rgb" || o === "rgba"
            },
            isHSL(o) {
                return o === "hsl" || o === "hsla"
            }
        };
        e.inspect = (o, s) => o.format === "hsl" ? `<${o.constructor.name} h:${o.h} s:${o.s} l:${o.l} a:${o.a}>` : o.format === "hex" || o.format === "name" ? `<${o.constructor.name} "${s}">` : `<${o.constructor.name} r:${o.r} g:${o.g} b:${o.b} a:${o.a}>`,
            e.isColor = o => typeof o == "string" ? e.isColorString(o) : e.isColorObject(o),
            e.isColorString = o => typeof o == "string" ? rg(o) !== !1 : !1,
            e.isColorObject = o => o && typeof o != "string" && typeof o.r == "number" && typeof o.g == "number" && typeof o.b == "number" && typeof o.h == "number" && typeof o.s == "number" && typeof o.l == "number" && typeof o.a == "number" && typeof o.roundA == "number" && typeof o.format == "string",
            e.toString = o => e.toRgbString(o),
            e.toHex = (o, s = !1) => y1(o.r, o.g, o.b, s),
            e.toHexString = (o, s = !1) => `#${e.toHex(o, s)}`,
            e.toRgbString = o => o.a === 1 ? "rgb(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ")" : "rgba(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ", " + o.roundA + ")",
            e.toHusl = o => ({
                ...vV(o.r, o.g, o.b),
                a: o.roundA
            }),
            e.toHslString = o => {
                let s = e.toHsl(o)
                    , a = Math.round(s.h)
                    , l = Math.round(s.s * 100)
                    , c = Math.round(s.l * 100);
                return o.a === 1 ? "hsl(" + a + ", " + l + "%, " + c + "%)" : "hsla(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")"
            }
            ,
            e.toHsv = o => {
                let s = b1(o.r, o.g, o.b);
                return {
                    h: s.h * 360,
                    s: s.s,
                    v: s.v,
                    a: o.a
                }
            }
            ,
            e.toHsvString = o => {
                let s = b1(o.r, o.g, o.b)
                    , a = Math.round(s.h * 360)
                    , l = Math.round(s.s * 100)
                    , c = Math.round(s.v * 100);
                return o.a === 1 ? "hsv(" + a + ", " + l + "%, " + c + "%)" : "hsva(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")"
            }
            ,
            e.toName = o => {
                if (o.a === 0)
                    return "transparent";
                if (o.a < 1)
                    return !1;
                let s = y1(o.r, o.g, o.b, !0);
                for (let a of Object.keys(Vm))
                    if (Vm[a] === s)
                        return a;
                return !1
            }
            ,
            e.toHsl = o => ({
                h: Math.round(o.h),
                s: o.s,
                l: o.l,
                a: o.a
            }),
            e.toRgb = o => ({
                r: Math.round(o.r),
                g: Math.round(o.g),
                b: Math.round(o.b),
                a: o.a
            }),
            e.brighten = (o, s = 10) => {
                let a = e.toRgb(o);
                return a.r = Math.max(0, Math.min(255, a.r - Math.round(255 * -(s / 100)))),
                    a.g = Math.max(0, Math.min(255, a.g - Math.round(255 * -(s / 100)))),
                    a.b = Math.max(0, Math.min(255, a.b - Math.round(255 * -(s / 100)))),
                    e(a)
            }
            ,
            e.lighten = (o, s = 10) => {
                let a = e.toHsl(o);
                return a.l += s / 100,
                    a.l = Math.min(1, Math.max(0, a.l)),
                    e(a)
            }
            ,
            e.darken = (o, s = 10) => {
                let a = e.toHsl(o);
                return a.l -= s / 100,
                    a.l = Math.min(1, Math.max(0, a.l)),
                    e(a)
            }
            ,
            e.saturate = (o, s = 10) => {
                let a = e.toHsl(o);
                return a.s += s / 100,
                    a.s = Math.min(1, Math.max(0, a.s)),
                    e(a)
            }
            ,
            e.desaturate = (o, s = 10) => {
                let a = e.toHsl(o);
                return a.s -= s / 100,
                    a.s = Math.min(1, Math.max(0, a.s)),
                    e(a)
            }
            ,
            e.grayscale = o => e.desaturate(o, 100),
            e.hueRotate = (o, s) => {
                let a = e.toHsl(o);
                return a.h += s,
                    a.h = a.h > 360 ? a.h - 360 : a.h,
                    e(a)
            }
            ,
            e.alpha = (o, s = 1) => e({
                r: o.r,
                g: o.g,
                b: o.b,
                a: s
            }),
            e.transparent = o => e.alpha(o, 0),
            e.multiplyAlpha = (o, s = 1) => e({
                r: o.r,
                g: o.g,
                b: o.b,
                a: o.a * s
            }),
            e.interpolate = (o, s, a = "rgb") => {
                if (!e.isColorObject(o) || !e.isColorObject(s))
                    throw new TypeError("Both arguments for Color.interpolate must be Color objects");
                return l => e.mixAsColor(o, s, l, !1, a)
            }
            ,
            e.mix = (o, s, { model: a = "rgb" } = {}) => {
                let l = typeof o == "string" ? e(o) : o
                    , c = e.interpolate(l, s, a);
                return u => e.toRgbString(c(u))
            }
            ,
            e.mixAsColor = (o, s, a = .5, l = !1, c = "rgb") => {
                let u = null;
                if (n.isRGB(c))
                    u = e({
                        r: pi(a, [0, 1], [o.r, s.r], l),
                        g: pi(a, [0, 1], [o.g, s.g], l),
                        b: pi(a, [0, 1], [o.b, s.b], l),
                        a: pi(a, [0, 1], [o.a, s.a], l)
                    });
                else {
                    let f, d;
                    n.isHSL(c) ? (f = e.toHsl(o),
                        d = e.toHsl(s)) : (f = e.toHusl(o),
                            d = e.toHusl(s)),
                        f.s === 0 ? f.h = d.h : d.s === 0 && (d.h = f.h);
                    let p = f.h
                        , v = d.h
                        , g = v - p;
                    g > 180 ? g = v - 360 - p : g < -180 && (g = v + 360 - p);
                    let b = {
                        h: pi(a, [0, 1], [p, p + g], l),
                        s: pi(a, [0, 1], [f.s, d.s], l),
                        l: pi(a, [0, 1], [f.l, d.l], l),
                        a: pi(a, [0, 1], [o.a, s.a], l)
                    };
                    n.isHSL(c) ? u = e(b) : u = e(yV(b.h, b.s, b.l, b.a))
                }
                return u
            }
            ,
            e.random = (o = 1) => {
                function s() {
                    return Math.floor(Math.random() * 255)
                }
                return e("rgba(" + s() + ", " + s() + ", " + s() + ", " + o + ")")
            }
            ,
            e.grey = (o = .5, s = 1) => (o = Math.floor(o * 255),
                e("rgba(" + o + ", " + o + ", " + o + ", " + s + ")")),
            e.gray = e.grey,
            e.rgbToHsl = (o, s, a) => ng(o, s, a),
            e.isValidColorProperty = (o, s) => !!((o.toLowerCase().slice(-5) === "color" || o === "fill" || o === "stroke") && typeof s == "string" && e.isColorString(s)),
            e.difference = (o, s) => {
                let a = (o.r + s.r) / 2
                    , l = o.r - s.r
                    , c = o.g - s.g
                    , u = o.b - s.b
                    , f = Math.pow(l, 2)
                    , d = Math.pow(c, 2)
                    , p = Math.pow(u, 2);
                return Math.sqrt(2 * f + 4 * d + 3 * p + a * (f - p) / 256)
            }
            ,
            e.equal = (o, s, a = .1) => !(Math.abs(o.r - s.r) >= a || Math.abs(o.g - s.g) >= a || Math.abs(o.b - s.b) >= a || Math.abs(o.a - s.a) * 256 >= a);
        let r = bo([0, 255], [0, 1]);
        function i(o) {
            o = r(o);
            let s = Math.abs(o);
            return s < .04045 ? o / 12.92 : (Math.sign(o) || 1) * Math.pow((s + .055) / 1.055, 2.4)
        }
        return e.luminance = o => {
            let { r: s, g: a, b: l } = e.toRgb(o);
            return .2126 * i(s) + .7152 * i(a) + .0722 * i(l)
        }
            ,
            e.contrast = (o, s) => {
                let a = e.luminance(o)
                    , l = e.luminance(s);
                return (Math.max(a, l) + .05) / (Math.min(a, l) + .05)
            }
            ,
            e
    }
    )();
function CV(e, t, n, r = 1) {
    let i;
    return typeof e == "number" && !Number.isNaN(e) && typeof t == "number" && !Number.isNaN(t) && typeof n == "number" && !Number.isNaN(n) ? i = Dm({
        r: e,
        g: t,
        b: n,
        a: r
    }) : typeof e == "string" ? i = TV(e) : typeof e == "object" && (e.hasOwnProperty("r") && e.hasOwnProperty("g") && e.hasOwnProperty("b") ? i = Dm(e) : i = eC(e)),
        i
}
function TV(e) {
    let t = rg(e);
    if (t)
        return t.format === "hsl" ? eC(t) : t.format === "hsv" ? RV(t) : Dm(t)
}
function RV(e) {
    let t = wV(e.h, e.s, e.v);
    return {
        ...ng(t.r, t.g, t.b),
        ...t,
        format: "rgb",
        a: e.a !== void 0 ? tC(e.a) : 1
    }
}
function Dm(e) {
    let t = bV(e.r, e.g, e.b);
    return {
        ...ng(t.r, t.g, t.b),
        ...t,
        format: "rgb",
        a: e.a !== void 0 ? tC(e.a) : 1
    }
}
function eC(e) {
    let t, n, r, i = {
        r: 0,
        g: 0,
        b: 0
    }, o = {
        h: 0,
        s: 0,
        l: 0
    };
    return t = is(e.h) ? e.h : 0,
        t = (t + 360) % 360,
        n = is(e.s) ? e.s : 1,
        typeof e.s == "string" && (n = Am(e.s)),
        r = is(e.l) ? e.l : .5,
        typeof e.l == "string" && (r = Am(e.l)),
        i = xV(t, n, r),
        o = {
            h: t,
            s: n,
            l: r
        },
    {
        ...i,
        ...o,
        a: e.a === void 0 ? 1 : e.a,
        format: "hsl"
    }
}
function tC(e) {
    return e = parseFloat(e),
        e < 0 && (e = 0),
        (Number.isNaN(e) || e > 1) && (e = 1),
        e
}
var S1 = e => e instanceof Fl;
var EV = (() => GM().EventEmitter)()
    , FV = class {
        constructor() {
            E(this, "_emitter", new EV)
        }
        eventNames() {
            return this._emitter.eventNames()
        }
        eventListeners() {
            let e = {};
            for (let t of this._emitter.eventNames())
                e[t] = this._emitter.listeners(t);
            return e
        }
        on(e, t) {
            this.addEventListener(e, t, !1, !1, this)
        }
        off(e, t) {
            this.removeEventListeners(e, t)
        }
        once(e, t) {
            this.addEventListener(e, t, !0, !1, this)
        }
        unique(e, t) {
            this.addEventListener(e, t, !1, !0, this)
        }
        addEventListener(e, t, n, r, i) {
            if (r) {
                for (let o of this._emitter.eventNames())
                    if (t === this._emitter.listeners(o))
                        return
            }
            n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i)
        }
        removeEventListeners(e, t) {
            e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners()
        }
        removeAllEventListeners() {
            this._emitter.removeAllListeners()
        }
        countEventListeners(e, t) {
            if (e)
                return this._emitter.listeners(e).length;
            {
                let n = 0;
                for (let r of this._emitter.eventNames())
                    n += this._emitter.listeners(r).length;
                return n
            }
        }
        emit(e, ...t) {
            this._emitter.emit(e, ...t)
        }
    }
    , PV = {
        addEventListener: () => { }
        ,
        removeEventListener: () => { }
        ,
        dispatchEvent: () => !1,
        ResizeObserver: void 0,
        onpointerdown: !1,
        onpointermove: !1,
        onpointerup: !1,
        ontouchstart: !1,
        ontouchmove: !1,
        ontouchend: !1,
        onmousedown: !1,
        onmousemove: !1,
        onmouseup: !1,
        devicePixelRatio: 1,
        scrollX: 0,
        scrollY: 0,
        location: {
            href: "",
            pathname: ""
        },
        document: {
            cookie: ""
        },
        setTimeout: () => 0,
        clearTimeout: () => { }
        ,
        setInterval: () => 0,
        clearInterval: () => { }
        ,
        requestAnimationFrame: () => 0,
        cancelAnimationFrame: () => { }
        ,
        requestIdleCallback: () => 0,
        getSelection: () => null,
        matchMedia: e => ({
            matches: !1,
            media: e,
            onchange: () => { }
            ,
            addEventListener: () => { }
            ,
            removeEventListener: () => { }
            ,
            addListener: () => { }
            ,
            removeListener: () => { }
            ,
            dispatchEvent: () => !1
        }),
        innerHeight: 0,
        innerWidth: 0,
        SVGSVGElement: {},
        open: function (e, t, n) { },
        __framer_events: []
    }
    , it = typeof I > "u" ? PV : I
    , _V = e => {
        setTimeout(e, 1 / 60)
    }
    , IV = (() => it.requestAnimationFrame || _V)()
    , k1 = e => IV(e)
    , Fa = (() => 1 / 60)()
    , OV = class extends FV {
        constructor(e = !1) {
            super(),
                E(this, "_started", !1),
                E(this, "_frame", 0),
                E(this, "_frameTasks", []),
                E(this, "tick", () => {
                    this._started && (k1(this.tick),
                        this.emit("update", this._frame, Fa),
                        this.emit("render", this._frame, Fa),
                        this._processFrameTasks(),
                        this._frame++)
                }
                ),
                e && this.start()
        }
        addFrameTask(e) {
            this._frameTasks.push(e)
        }
        _processFrameTasks() {
            var e;
            let t = this._frameTasks
                , n = t.length;
            if (n !== 0) {
                for (let r = 0; r < n; r++)
                    (e = t[r]) == null || e.call(t);
                t.length = 0
            }
        }
        static set TimeStep(e) {
            Fa = e
        }
        static get TimeStep() {
            return Fa
        }
        start() {
            return this._started ? this : (this._frame = 0,
                this._started = !0,
                k1(this.tick),
                this)
        }
        stop() {
            return this._started = !1,
                this
        }
        get frame() {
            return this._frame
        }
        get time() {
            return this._frame * Fa
        }
    }
    , nC = new OV
    , zm = {
        target: "PREVIEW",
        zoom: 1
    };
var fe = {
    canvas: "CANVAS",
    export: "EXPORT",
    thumbnail: "THUMBNAIL",
    preview: "PREVIEW",
    current: () => zm.target,
    hasRestrictions: () => {
        let e = zm.target;
        return e === "CANVAS" || e === "EXPORT"
    }
};
var fu = e => ({
    correct: (t, { delta: n, treeScale: r }) => {
        if (typeof t == "string" && (t = parseFloat(t)),
            t === 0)
            return "0px";
        let i = t;
        return n && r && (i = Math.round(t / n[e].scale / r[e]),
            i = Math.max(i, 1)),
            i + "px"
    }
});
Fd({
    borderTopWidth: fu("y"),
    borderLeftWidth: fu("x"),
    borderRightWidth: fu("x"),
    borderBottomWidth: fu("y")
});
function A(e, ...t) {
    var n, r;
    if (e)
        return;
    let i = Error("Assertion Error" + (t.length > 0 ? ": " + t.join(" ") : ""));
    if (i.stack)
        try {
            let o = i.stack.split(`
`);
            (n = o[1]) != null && n.includes("assert") ? (o.splice(1, 1),
                i.stack = o.join(`
`)) : (r = o[0]) != null && r.includes("assert") && (o.splice(0, 1),
                i.stack = o.join(`
`))
        } catch { }
    throw i
}
function Ce(e, t) {
    throw t || new Error(e ? `Unexpected value: ${e}` : "Application entered invalid state")
}
var ss = x.createContext({
    getLayoutId: e => null,
    persistLayoutIdCache: () => { }
    ,
    top: !1,
    enabled: !0
});
function MV({ children: e }) {
    if (D(ss).top)
        return k(lt, {
            children: e
        });
    let n = V({
        byId: {},
        byName: {},
        byLastId: {},
        byPossibleId: {},
        byLastName: {},
        byLayoutId: {},
        count: {
            byId: {},
            byName: {}
        }
    })
        , r = V({
            byId: {},
            byName: {},
            byLastId: {},
            byPossibleId: {},
            byLastName: {},
            byLayoutId: {}
        })
        , i = V(new Set).current
        , o = Q(({ id: l, name: c, duplicatedFrom: u }) => {
            if (!l)
                return null;
            let f = c ? "byName" : "byId"
                , d = n.current[f][l];
            if (d)
                return d;
            let p = c || l;
            if (!u && !i.has(p) && (!n.current.byLayoutId[p] || n.current.byLayoutId[p] === p))
                return n.current.count[f][p] === void 0 && (n.current.count[f][p] = 0,
                    n.current.byLayoutId[p] = p,
                    r.current[f][l] = p),
                    i.add(p),
                    p;
            let v;
            if (u?.length)
                for (let S = u.length - 1; S >= 0; S--) {
                    let T = u[S];
                    A(!!T, "duplicatedId must be defined");
                    let R = n.current[f][T]
                        , F = n.current.byLastId[T];
                    if (F && !v) {
                        let $ = n.current.byLayoutId[F]
                            , N = !$ || $ === c;
                        F && !i.has(F) && (!c || N) && (v = [F, T])
                    }
                    let P = R ? n.current.byLayoutId[R] : void 0
                        , B = !P || P === c;
                    if (R && !i.has(R) && (!c || B))
                        return r.current[f][l] = R,
                            r.current.byLastId[T] = R,
                            i.add(R),
                            R
                }
            let g = n.current.byLastId[l];
            if (g && !i.has(g))
                return i.add(g),
                    r.current.byId[l] = g,
                    g;
            if (v) {
                let [S, T] = v;
                return r.current[f][l] = S,
                    r.current.byLastId[T] = S,
                    i.add(S),
                    S
            }
            let b = n.current.byPossibleId[l];
            if (b && !i.has(b))
                return i.add(b),
                    r.current.byId[l] = b,
                    b;
            let m = u?.[0]
                , h = c || m || l
                , y = (n.current.count[f][h] ?? -1) + 1
                , { layoutId: w, value: C } = LV(h, y, i);
            if (n.current.count[f][h] = C,
                r.current[f][l] = w,
                u?.length && !c) {
                let S = u[u.length - 1];
                if (S && (r.current.byLastId[S] = w),
                    u.length > 1)
                    for (let T = 0; T < u.length - 1; T++) {
                        let R = u[T];
                        R !== void 0 && (r.current.byPossibleId[R] || (r.current.byPossibleId[R] = w))
                    }
            }
            return r.current.byLayoutId[w] = p,
                i.add(w),
                w
        }
            , [])
        , s = Q(() => {
            n.current = {
                byId: {
                    ...n.current.byId,
                    ...r.current.byId
                },
                byLastId: {
                    ...n.current.byLastId,
                    ...r.current.byLastId
                },
                byPossibleId: {
                    ...n.current.byPossibleId,
                    ...r.current.byPossibleId
                },
                byName: {
                    ...n.current.byName,
                    ...r.current.byName
                },
                byLastName: {
                    ...n.current.byLastName,
                    ...r.current.byLastName
                },
                byLayoutId: {
                    ...n.current.byLayoutId,
                    ...r.current.byLayoutId
                },
                count: {
                    ...n.current.count,
                    byName: {}
                }
            },
                r.current = {
                    byId: {},
                    byName: {},
                    byLastId: {},
                    byPossibleId: {},
                    byLastName: {},
                    byLayoutId: {}
                },
                i.clear()
        }
            , [])
        , a = V({
            getLayoutId: o,
            persistLayoutIdCache: s,
            top: !0,
            enabled: !0
        }).current;
    return k(ss.Provider, {
        value: a,
        children: e
    })
}
function LV(e, t, n) {
    let r = t
        , i = r ? `${e}-${r}` : e;
    for (; n.has(i);)
        r++,
            i = `${e}-${r}`;
    return {
        layoutId: i,
        value: r
    }
}
function VV({ enabled: e = !0, ...t }) {
    let n = D(ss)
        , r = ue(() => ({
            ...n,
            enabled: e
        }), [e]);
    return k(ss.Provider, {
        ...t,
        value: r
    })
}
function yt(e) {
    let t = V(null);
    return t.current === null && (t.current = e()),
        t.current
}
var AV = {
    background: void 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    lineHeight: "1.4em",
    textOverflow: "ellipsis",
    overflow: "hidden",
    minHeight: 0,
    width: "100%",
    height: "100%"
}
    , DV = (() => ({
        ...AV,
        border: "1px solid rgba(149, 149, 149, 0.15)",
        borderRadius: 6,
        fontSize: "12px",
        backgroundColor: "rgba(149, 149, 149, 0.1)",
        color: "#a5a5a5"
    }))()
    , rC = {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        maxWidth: "100%",
        flexShrink: 0,
        padding: "0 10px"
    }
    , zV = (() => ({
        ...rC,
        fontWeight: 500
    }))()
    , BV = (() => ({
        ...rC,
        whiteSpace: "pre",
        maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))",
        WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)"
    }))();
function l8(e) {
    let { error: t, file: n } = e
        , r = n ? `Error in ${$V(n)}` : "Error"
        , i = t instanceof Error ? t.message : "" + t;
    return ge("div", {
        style: DV,
        children: [k("div", {
            className: "text",
            style: zV,
            children: r
        }), i && k("div", {
            className: "text",
            style: BV,
            children: i
        })]
    })
}
function $V(e) {
    return e.startsWith("./") ? e.replace("./", "") : e
}
function re(e) {
    return Number.isFinite(e)
}
function NV(e) {
    return !e || !Object.keys(e).length && e.constructor === Object
}
function Aa(e) {
    return typeof e != "string" && typeof e != "number"
}
function Da(e) {
    return e !== null && typeof e < "u" && typeof e != "boolean" && !NV(e)
}
function jV(e) {
    return e * (Math.PI / 180)
}
var _n = (() => {
    function e(t, n) {
        return {
            a: t,
            b: n
        }
    }
    return e.offset = (t, n) => {
        let r = hn.angleFromX(t.a, t.b)
            , i = jV(r)
            , o = n * Math.sin(i)
            , s = n * Math.cos(i);
        return e({
            x: t.a.x + o,
            y: t.a.y - s
        }, {
            x: t.b.x + o,
            y: t.b.y - s
        })
    }
        ,
        e.intersection = (t, n, r) => {
            let i = t.a.x
                , o = t.a.y
                , s = t.b.x
                , a = t.b.y
                , l = n.a.x
                , c = n.a.y
                , u = n.b.x
                , f = n.b.y
                , d = (u - l) * (c - o) - (f - c) * (l - i)
                , p = (u - l) * (a - o) - (f - c) * (s - i)
                , v = (s - i) * (c - o) - (a - o) * (l - i);
            if (d === 0 && p === 0 || p === 0)
                return null;
            let g = d / p
                , b = v / p;
            return r && (g < 0 || g > 1 || b < 0 || b > 1) ? null : {
                x: i + g * (s - i),
                y: o + g * (a - o)
            }
        }
        ,
        e.intersectionAngle = (t, n) => {
            let r = t.b.x - t.a.x
                , i = t.b.y - t.a.y
                , o = n.b.x - n.a.x
                , s = n.b.y - n.a.y;
            return Math.atan2(r * s - i * o, r * o + i * s) * (180 / Math.PI)
        }
        ,
        e.isOrthogonal = t => t.a.x === t.b.x || t.a.y === t.b.y,
        e.perpendicular = (t, n) => {
            let r = t.a.x - t.b.x
                , i = t.a.y - t.b.y
                , o = hn(n.x - i, n.y + r);
            return e(o, n)
        }
        ,
        e.projectPoint = (t, n) => {
            let r = e.perpendicular(t, n);
            return e.intersection(t, r)
        }
        ,
        e.pointAtPercentDistance = (t, n) => {
            let r = e.distance(t)
                , i = n * r / r;
            return {
                x: i * t.b.x + (1 - i) * t.a.x,
                y: i * t.b.y + (1 - i) * t.a.y
            }
        }
        ,
        e.distance = t => hn.distance(t.a, t.b),
        e
}
)()
    , oe = {
        equals: function (e, t) {
            return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
        },
        atOrigin: e => ({
            ...e,
            x: 0,
            y: 0
        }),
        fromTwoPoints: (e, t) => ({
            x: Math.min(e.x, t.x),
            y: Math.min(e.y, t.y),
            width: Math.abs(e.x - t.x),
            height: Math.abs(e.y - t.y)
        }),
        fromRect: e => ({
            x: e.left,
            y: e.top,
            width: e.right - e.left,
            height: e.bottom - e.top
        }),
        multiply: (e, t) => ({
            x: e.x * t,
            y: e.y * t,
            width: e.width * t,
            height: e.height * t
        }),
        divide: (e, t) => oe.multiply(e, 1 / t),
        offset: (e, t) => {
            let n = typeof t.x == "number" ? t.x : 0
                , r = typeof t.y == "number" ? t.y : 0;
            return {
                ...e,
                x: e.x + n,
                y: e.y + r
            }
        }
        ,
        inflate: (e, t) => {
            if (t === 0)
                return e;
            let n = 2 * t;
            return {
                x: e.x - t,
                y: e.y - t,
                width: e.width + n,
                height: e.height + n
            }
        }
        ,
        pixelAligned: e => {
            let t = Math.round(e.x)
                , n = Math.round(e.y)
                , r = Math.round(e.x + e.width)
                , i = Math.round(e.y + e.height)
                , o = Math.max(r - t, 0)
                , s = Math.max(i - n, 0);
            return {
                x: t,
                y: n,
                width: o,
                height: s
            }
        }
        ,
        halfPixelAligned: e => {
            let t = Math.round(e.x * 2) / 2
                , n = Math.round(e.y * 2) / 2
                , r = Math.round((e.x + e.width) * 2) / 2
                , i = Math.round((e.y + e.height) * 2) / 2
                , o = Math.max(r - t, 1)
                , s = Math.max(i - n, 1);
            return {
                x: t,
                y: n,
                width: o,
                height: s
            }
        }
        ,
        round: (e, t = 0) => {
            let n = cu(e.x, t)
                , r = cu(e.y, t)
                , i = cu(e.width, t)
                , o = cu(e.height, t);
            return {
                x: n,
                y: r,
                width: i,
                height: o
            }
        }
        ,
        roundToOutside: e => {
            let t = Math.floor(e.x)
                , n = Math.floor(e.y)
                , r = Math.ceil(e.x + e.width)
                , i = Math.ceil(e.y + e.height)
                , o = Math.max(r - t, 0)
                , s = Math.max(i - n, 0);
            return {
                x: t,
                y: n,
                width: o,
                height: s
            }
        }
        ,
        minX: e => e.x,
        maxX: e => e.x + e.width,
        minY: e => e.y,
        maxY: e => e.y + e.height,
        positions: e => ({
            minX: e.x,
            midX: e.x + e.width / 2,
            maxX: oe.maxX(e),
            minY: e.y,
            midY: e.y + e.height / 2,
            maxY: oe.maxY(e)
        }),
        center: e => ({
            x: e.x + e.width / 2,
            y: e.y + e.height / 2
        }),
        boundingRectFromPoints: e => {
            let t = 1 / 0
                , n = -1 / 0
                , r = 1 / 0
                , i = -1 / 0;
            for (let o = 0; o < e.length; o++) {
                let s = e[o];
                t = Math.min(t, s.x),
                    n = Math.max(n, s.x),
                    r = Math.min(r, s.y),
                    i = Math.max(i, s.y)
            }
            return {
                x: t,
                y: r,
                width: n - t,
                height: i - r
            }
        }
        ,
        fromPoints: e => {
            let [t, n, r, i] = e
                , { x: o, y: s } = t
                , a = hn.distance(t, n)
                , l = hn.distance(t, i);
            return {
                x: o,
                y: s,
                width: a,
                height: l
            }
        }
        ,
        merge: (...e) => {
            let t = {
                x: Math.min(...e.map(oe.minX)),
                y: Math.min(...e.map(oe.minY))
            }
                , n = {
                    x: Math.max(...e.map(oe.maxX)),
                    y: Math.max(...e.map(oe.maxY))
                };
            return oe.fromTwoPoints(t, n)
        }
        ,
        intersection: (e, t) => {
            let n = Math.max(e.x, t.x)
                , r = Math.min(e.x + e.width, t.x + t.width)
                , i = Math.max(e.y, t.y)
                , o = Math.min(e.y + e.height, t.y + t.height);
            return {
                x: n,
                y: i,
                width: r - n,
                height: o - i
            }
        }
        ,
        points: e => [{
            x: oe.minX(e),
            y: oe.minY(e)
        }, {
            x: oe.minX(e),
            y: oe.maxY(e)
        }, {
            x: oe.maxX(e),
            y: oe.minY(e)
        }, {
            x: oe.maxX(e),
            y: oe.maxY(e)
        }],
        pointsAtOrigin: e => [{
            x: 0,
            y: 0
        }, {
            x: e.width,
            y: 0
        }, {
            x: e.width,
            y: e.height
        }, {
            x: 0,
            y: e.height
        }],
        transform: (e, t) => {
            let { x: n, y: r } = t.transformPoint({
                x: e.x,
                y: e.y
            })
                , { x: i, y: o } = t.transformPoint({
                    x: e.x + e.width,
                    y: e.y
                })
                , { x: s, y: a } = t.transformPoint({
                    x: e.x + e.width,
                    y: e.y + e.height
                })
                , { x: l, y: c } = t.transformPoint({
                    x: e.x,
                    y: e.y + e.height
                })
                , u = Math.min(n, i, s, l)
                , f = Math.max(n, i, s, l) - u
                , d = Math.min(r, o, a, c)
                , p = Math.max(r, o, a, c) - d;
            return {
                x: u,
                y: d,
                width: f,
                height: p
            }
        }
        ,
        containsPoint: (e, t) => !(t.x < oe.minX(e) || t.x > oe.maxX(e) || t.y < oe.minY(e) || t.y > oe.maxY(e) || Number.isNaN(e.x) || Number.isNaN(e.y)),
        containsRect: (e, t) => {
            for (let n of oe.points(t))
                if (!oe.containsPoint(e, n))
                    return !1;
            return !0
        }
        ,
        toCSS: e => ({
            display: "block",
            transform: `translate(${e.x}px, ${e.y}px)`,
            width: `${e.width}px`,
            height: `${e.height}px`
        }),
        inset: (e, t) => ({
            x: e.x + t,
            y: e.y + t,
            width: Math.max(0, e.width - 2 * t),
            height: Math.max(0, e.height - 2 * t)
        }),
        intersects: (e, t) => !(t.x >= oe.maxX(e) || oe.maxX(t) <= e.x || t.y >= oe.maxY(e) || oe.maxY(t) <= e.y),
        overlapHorizontally: (e, t) => {
            let n = oe.maxX(e)
                , r = oe.maxX(t);
            return n > t.x && r > e.x
        }
        ,
        overlapVertically: (e, t) => {
            let n = oe.maxY(e)
                , r = oe.maxY(t);
            return n > t.y && r > e.y
        }
        ,
        doesNotIntersect: (e, t) => t.find(n => oe.intersects(n, e)) === void 0,
        isEqual: (e, t) => oe.equals(e, t),
        cornerPoints: e => {
            let t = e.x
                , n = e.x + e.width
                , r = e.y
                , i = e.y + e.height;
            return [{
                x: t,
                y: r
            }, {
                x: n,
                y: r
            }, {
                x: n,
                y: i
            }, {
                x: t,
                y: i
            }]
        }
        ,
        midPoints: e => {
            let t = e.x
                , n = e.x + e.width / 2
                , r = e.x + e.width
                , i = e.y
                , o = e.y + e.height / 2
                , s = e.y + e.height;
            return [{
                x: n,
                y: i
            }, {
                x: r,
                y: o
            }, {
                x: n,
                y: s
            }, {
                x: t,
                y: o
            }]
        }
        ,
        pointDistance: (e, t) => {
            let n = 0
                , r = 0;
            return t.x < e.x ? n = e.x - t.x : t.x > oe.maxX(e) && (n = t.x - oe.maxX(e)),
                t.y < e.y ? r = e.y - t.y : t.y > oe.maxY(e) && (r = t.y - oe.maxY(e)),
                hn.distance({
                    x: n,
                    y: r
                }, {
                    x: 0,
                    y: 0
                })
        }
        ,
        fromAny: (e, t = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }) => ({
            x: e.x || t.x,
            y: e.y || t.y,
            width: e.width || t.width,
            height: e.height || t.height
        }),
        delta: (e, t) => {
            let n = {
                x: oe.minX(e),
                y: oe.minY(e)
            }
                , r = {
                    x: oe.minX(t),
                    y: oe.minY(t)
                };
            return {
                x: n.x - r.x,
                y: n.y - r.y
            }
        }
        ,
        withMinSize: (e, t) => {
            let { width: n, height: r } = t
                , i = e.width - n
                , o = e.height - r;
            return {
                width: Math.max(e.width, n),
                height: Math.max(e.height, r),
                x: e.width < n ? e.x + i / 2 : e.x,
                y: e.height < r ? e.y + o / 2 : e.y
            }
        }
        ,
        anyPointsOutsideRect: (e, t) => {
            let n = oe.minX(e)
                , r = oe.minY(e)
                , i = oe.maxX(e)
                , o = oe.maxY(e);
            for (let s of t)
                if (s.x < n || s.x > i || s.y < r || s.y > o)
                    return !0;
            return !1
        }
        ,
        edges: e => {
            let [t, n, r, i] = oe.cornerPoints(e);
            return [_n(t, n), _n(n, r), _n(r, i), _n(i, t)]
        }
        ,
        rebaseRectOnto: (e, t, n, r) => {
            let i = {
                ...e
            };
            switch (n) {
                case "bottom":
                case "top":
                    switch (r) {
                        case "start":
                            i.x = t.x;
                            break;
                        case "center":
                            i.x = t.x + t.width / 2 - e.width / 2;
                            break;
                        case "end":
                            i.x = t.x + t.width - e.width;
                            break;
                        default:
                            Ce(r)
                    }
                    break;
                case "left":
                    i.x = t.x - e.width;
                    break;
                case "right":
                    i.x = t.x + t.width;
                    break;
                default:
                    Ce(n)
            }
            switch (n) {
                case "left":
                case "right":
                    switch (r) {
                        case "start":
                            i.y = t.y;
                            break;
                        case "center":
                            i.y = t.y + t.height / 2 - e.height / 2;
                            break;
                        case "end":
                            i.y = t.y + t.height - e.height;
                            break;
                        default:
                            Ce(r)
                    }
                    break;
                case "top":
                    i.y = t.y - e.height;
                    break;
                case "bottom":
                    i.y = t.y + t.height;
                    break;
                default:
                    Ce(n)
            }
            return i
        }
    };
var iC = {
    quickfix: e => ((e.widthType === 2 || e.heightType === 2) && (e.aspectRatio = null),
        re(e.aspectRatio) && (e.left && e.right && (e.widthType = 0),
            e.top && e.bottom && (e.heightType = 0),
            e.left && e.right && e.top && e.bottom && (e.bottom = !1),
            e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)),
        e.left && e.right && ((e.fixedSize || e.widthType === 2 || re(e.maxWidth)) && (e.right = !1),
            e.widthType = 0),
        e.top && e.bottom && ((e.fixedSize || e.heightType === 2 || re(e.maxHeight)) && (e.bottom = !1),
            e.heightType = 0),
        e)
};
function Ru(e) {
    if (typeof e == "string") {
        let t = e.trim();
        if (t === "auto")
            return 2;
        if (t.endsWith("fr"))
            return 3;
        if (t.endsWith("%"))
            return 1;
        if (t.endsWith("vw") || t.endsWith("vh"))
            return 4
    }
    return 0
}
var oC = {
    fromProperties: e => {
        let { left: t, right: n, top: r, bottom: i, width: o, height: s, centerX: a, centerY: l, aspectRatio: c, autoSize: u } = e
            , f = iC.quickfix({
                left: re(t) || Wn(t),
                right: re(n) || Wn(n),
                top: re(r) || Wn(r),
                bottom: re(i) || Wn(i),
                widthType: Ru(o),
                heightType: Ru(s),
                aspectRatio: c || null,
                fixedSize: u === !0
            })
            , d = null
            , p = null
            , v = 0
            , g = 0;
        if (f.widthType !== 0 && typeof o == "string") {
            let h = parseFloat(o);
            o.endsWith("fr") ? (v = 3,
                d = h) : o === "auto" ? v = 2 : (v = 1,
                    d = h / 100)
        } else
            o !== void 0 && typeof o != "string" && (d = ft.getNumber(o));
        if (f.heightType !== 0 && typeof s == "string") {
            let h = parseFloat(s);
            s.endsWith("fr") ? (g = 3,
                p = h) : s === "auto" ? g = 2 : (g = 1,
                    p = parseFloat(s) / 100)
        } else
            s !== void 0 && typeof s != "string" && (p = ft.getNumber(s));
        let b = .5
            , m = .5;
        return a && (b = parseFloat(a) / 100),
            l && (m = parseFloat(l) / 100),
        {
            left: f.left ? ft.getNumber(t) : null,
            right: f.right ? ft.getNumber(n) : null,
            top: f.top ? ft.getNumber(r) : null,
            bottom: f.bottom ? ft.getNumber(i) : null,
            widthType: v,
            heightType: g,
            width: d,
            height: p,
            aspectRatio: f.aspectRatio || null,
            centerAnchorX: b,
            centerAnchorY: m
        }
    }
    ,
    toSize: (e, t, n, r) => {
        let i = null
            , o = null
            , s = t?.sizing ? ft.getNumber(t?.sizing.width) : null
            , a = t?.sizing ? ft.getNumber(t?.sizing.height) : null
            , l = C1(e.left, e.right);
        if (s && re(l))
            i = s - l;
        else if (n && e.widthType === 2)
            i = n.width;
        else if (re(e.width))
            switch (e.widthType) {
                case 0:
                    i = e.width;
                    break;
                case 3:
                    i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null;
                    break;
                case 1:
                case 4:
                    s && (i = s * e.width);
                    break;
                case 2:
                    break;
                default:
                    Ce(e.widthType)
            }
        let c = C1(e.top, e.bottom);
        if (a && re(c))
            o = a - c;
        else if (n && e.heightType === 2)
            o = n.height;
        else if (re(e.height))
            switch (e.heightType) {
                case 0:
                    o = e.height;
                    break;
                case 3:
                    o = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null;
                    break;
                case 1:
                case 4:
                    a && (o = a * e.height);
                    break;
                case 2:
                    break;
                default:
                    Ce(e.heightType)
            }
        return XV(i, o, e, {
            height: a ?? 0,
            width: s ?? 0
        }, t?.viewport)
    }
    ,
    toRect: (e, t = null, n = null, r = !1, i = null) => {
        let o = e.left || 0
            , s = e.top || 0
            , { width: a, height: l } = oC.toSize(e, t, n, i)
            , c = t?.positioning ?? null
            , u = c ? ft.getNumber(c.width) : null
            , f = c ? ft.getNumber(c.height) : null;
        e.left !== null ? o = e.left : u && e.right !== null ? o = u - e.right - a : u && (o = e.centerAnchorX * u - a / 2),
            e.top !== null ? s = e.top : f && e.bottom !== null ? s = f - e.bottom - l : f && (s = e.centerAnchorY * f - l / 2);
        let d = {
            x: o,
            y: s,
            width: a,
            height: l
        };
        return r ? oe.pixelAligned(d) : d
    }
}
    , HV = 200
    , WV = 200;
function Eu(e, t, n, r) {
    if (typeof t == "string") {
        if (t.endsWith("%") && n)
            switch (e) {
                case "maxWidth":
                case "minWidth":
                    return parseFloat(t) / 100 * n.width;
                case "maxHeight":
                case "minHeight":
                    return parseFloat(t) / 100 * n.height;
                default:
                    break
            }
        if (t.endsWith("vh")) {
            if (!r)
                return UV(e);
            switch (e) {
                case "maxWidth":
                case "minWidth":
                    return parseFloat(t) / 100 * r.width;
                case "maxHeight":
                case "minHeight":
                    return parseFloat(t) / 100 * r.height;
                default:
                    break
            }
        }
        return parseFloat(t)
    }
    return t
}
function UV(e) {
    switch (e) {
        case "minWidth":
        case "minHeight":
            return Number.NEGATIVE_INFINITY;
        case "maxWidth":
        case "maxHeight":
            return Number.POSITIVE_INFINITY;
        default:
            Ce(e, "unknown constraint key")
    }
}
function GV(e, t, n, r) {
    return t.minHeight && (e = Math.max(Eu("minHeight", t.minHeight, n, r), e)),
        t.maxHeight && (e = Math.min(Eu("maxHeight", t.maxHeight, n, r), e)),
        e
}
function qV(e, t, n, r) {
    return t.minWidth && (e = Math.max(Eu("minWidth", t.minWidth, n, r), e)),
        t.maxWidth && (e = Math.min(Eu("maxWidth", t.maxWidth, n, r), e)),
        e
}
function XV(e, t, n, r, i) {
    let o = qV(re(e) ? e : HV, n, r, i)
        , s = GV(re(t) ? t : WV, n, r, i);
    return re(n.aspectRatio) && n.aspectRatio > 0 && (re(n.left) && re(n.right) ? s = o / n.aspectRatio : re(n.top) && re(n.bottom) ? o = s * n.aspectRatio : n.widthType !== 0 ? s = o / n.aspectRatio : o = s * n.aspectRatio),
    {
        width: o,
        height: s
    }
}
function C1(e, t) {
    return !re(e) || !re(t) ? null : e + t
}
function YV(e) {
    return typeof e.right == "string" || typeof e.bottom == "string" || typeof e.left == "string" && (!e.center || e.center === "y") || typeof e.top == "string" && (!e.center || e.center === "x")
}
function us(e) {
    return !e._constraints || YV(e) ? !1 : e._constraints.enabled
}
function KV(e) {
    let { size: t } = e
        , { width: n, height: r } = e;
    return re(t) && (n === void 0 && (n = t),
        r === void 0 && (r = t)),
        re(n) && re(r) ? {
            width: n,
            height: r
        } : null
}
function QV(e) {
    let t = KV(e);
    if (t === null)
        return null;
    let { left: n, top: r } = e;
    return re(n) && re(r) ? {
        x: n,
        y: r,
        ...t
    } : null
}
function Ha(e, t, n = !0) {
    if (e.positionFixed || e.positionAbsolute)
        return null;
    let r = t === 1 || t === 2;
    if (!us(e) || r)
        return QV(e);
    let i = ZV(e)
        , o = JV(t)
        , s = o ? {
            sizing: o,
            positioning: o,
            viewport: null
        } : null;
    return oC.toRect(i, s, null, n, null)
}
function ZV(e) {
    let { left: t, right: n, top: r, bottom: i, center: o, _constraints: s, size: a } = e
        , { width: l, height: c } = e;
    l === void 0 && (l = a),
        c === void 0 && (c = a);
    let { aspectRatio: u, autoSize: f } = s
        , d = iC.quickfix({
            left: re(t),
            right: re(n),
            top: re(r),
            bottom: re(i),
            widthType: Ru(l),
            heightType: Ru(c),
            aspectRatio: u || null,
            fixedSize: f === !0
        })
        , p = null
        , v = null
        , g = 0
        , b = 0;
    if (d.widthType !== 0 && typeof l == "string") {
        let y = parseFloat(l);
        l.endsWith("fr") ? (g = 3,
            p = y) : l === "auto" ? g = 2 : (g = 1,
                p = y / 100)
    } else
        l !== void 0 && typeof l != "string" && (p = l);
    if (d.heightType !== 0 && typeof c == "string") {
        let y = parseFloat(c);
        c.endsWith("fr") ? (b = 3,
            v = y) : c === "auto" ? b = 2 : (b = 1,
                v = parseFloat(c) / 100)
    } else
        c !== void 0 && typeof c != "string" && (v = c);
    let m = .5
        , h = .5;
    return (o === !0 || o === "x") && (d.left = !1,
        typeof t == "string" && (m = parseFloat(t) / 100)),
        (o === !0 || o === "y") && (d.top = !1,
            typeof r == "string" && (h = parseFloat(r) / 100)),
    {
        left: d.left ? t : null,
        right: d.right ? n : null,
        top: d.top ? r : null,
        bottom: d.bottom ? i : null,
        widthType: g,
        heightType: b,
        width: p,
        height: v,
        aspectRatio: d.aspectRatio || null,
        centerAnchorX: m,
        centerAnchorY: h,
        minHeight: e.minHeight,
        maxHeight: e.maxHeight,
        minWidth: e.minWidth,
        maxWidth: e.maxWidth
    }
}
var sC = x.createContext({
    parentSize: 0
});
function JV(e) {
    return e === 0 || e === 1 || e === 2 ? null : e
}
function qa() {
    return x.useContext(sC).parentSize
}
function aC(e) {
    return typeof e == "object"
}
var eA = e => {
    let t = qa()
        , { parentSize: n, children: r } = e
        , i = x.useMemo(() => ({
            parentSize: n
        }), [tA(n), nA(n)]);
    return t === 1 ? r ? k(lt, {
        children: r
    }) : null : k(sC.Provider, {
        value: i,
        children: r
    })
}
    ;
function tA(e) {
    return aC(e) ? e.width : e
}
function nA(e) {
    return aC(e) ? e.height : e
}
function lC(e, t) {
    return k(eA, {
        parentSize: t,
        children: e
    })
}
function rA(e) {
    let t = qa();
    return Ha(e, t, !0)
}
function cC({ width: e, height: t }) {
    return e === "auto" || e === "min-content" || t === "auto" || t === "min-content"
}
var iA = (e => (e.Boolean = "boolean",
    e.Number = "number",
    e.String = "string",
    e.RichText = "richtext",
    e.FusedNumber = "fusednumber",
    e.Enum = "enum",
    e.SegmentedEnum = "segmentedenum",
    e.Color = "color",
    e.Image = "image",
    e.ResponsiveImage = "responsiveimage",
    e.File = "file",
    e.ComponentInstance = "componentinstance",
    e.Array = "array",
    e.EventHandler = "eventhandler",
    e.Transition = "transition",
    e.BoxShadow = "boxshadow",
    e.Link = "link",
    e.Date = "date",
    e.Object = "object",
    e.Font = "font",
    e.PageScope = "pagescope",
    e.ScrollSectionRef = "scrollsectionref",
    e.CustomCursor = "customcursor",
    e.Border = "border",
    e.Cursor = "cursor",
    e.Padding = "padding",
    e.BorderRadius = "borderradius",
    e.CollectionReference = "collectionreference",
    e.MultiCollectionReference = "multicollectionreference",
    e))(iA || {}), fm;
function oA() {
    if (fm !== void 0)
        return fm;
    let e = document.createElement("div");
    Object.assign(e.style, {
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        rowGap: "1px"
    }),
        e.appendChild(document.createElement("div")),
        e.appendChild(document.createElement("div")),
        document.body.appendChild(e);
    let t = e.scrollHeight === 1;
    return e.parentNode && e.parentNode.removeChild(e),
        fm = t,
        t
}
var Ji = "flexbox-gap-not-supported"
    , T1 = !1;
function h8() {
    T1 || (T1 = !0,
        !oA() && document.body.classList.add(Ji))
}
var sA = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, aA = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, lA = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, cA = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, uA = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, fA = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current],
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current] span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, dA = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover,
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, hA = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, pA = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, mA = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, gA = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, vA = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
    --font-variation-settings: normal;
}
`, yA = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, bA = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, xA = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, wA = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`, SA = ['[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }', vA, gA, sA, aA, lA, cA, uA, fA, dA, hA, pA, mA, yA, bA, xA, wA], kA = [`
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, none));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            font-variation-settings: var(--framer-font-variation-axes, normal);
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold, var(--framer-font-variation-axes-bold));
        }
    `, `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-italic, var(--framer-font-variation-axes-italic));
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold-italic, var(--framer-font-variation-axes-bold-italic));
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `, `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link],
        span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `, `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link],
        code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link]:hover,
        span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link]:hover,
        code.framer-text span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current]:hover,
        code.framer-text span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `, `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `, `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `], CA = new Set, dm;
function uC(e, t, n = CA) {
    if (!(!e || n.has(e) || typeof document > "u")) {
        if (n.add(e),
            !t) {
            if (!dm) {
                let r = document.createElement("style");
                if (r.setAttribute("type", "text/css"),
                    r.setAttribute("data-framer-css", "true"),
                    !document.head) {
                    console.warn("not injecting CSS: the document is missing a <head> element");
                    return
                }
                if (document.head.appendChild(r),
                    r.sheet)
                    dm = r.sheet;
                else {
                    console.warn("not injecting CSS: injected <style> element does not have a sheet", r);
                    return
                }
            }
            t = dm
        }
        try {
            t.insertRule(e, t.cssRules.length)
        } catch { }
    }
}
var TA = ["[data-framer-component-type] { position: absolute; }"]
    , RA = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`
    , EA = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`
    , FA = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`
    , PA = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`
    , _A = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`
    , IA = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`
    , OA = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`
    , MA = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`
    , LA = ['[data-framer-component-type="Text"] { cursor: inherit; }', "[data-framer-component-text-autosized] * { white-space: pre; }", RA, EA, FA, PA, _A, IA, OA, MA]
    , VA = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`
    , AA = (() => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${Ji} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])()
    , DA = (() => `
.${Ji} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)()
    , zA = (() => `
.${Ji}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${Ji}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)()
    , BA = (() => `
.${Ji}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${Ji}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)()
    , $A = (() => [VA, DA, ...AA, zA, BA])()
    , NA = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`]
    , jA = ['[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }', '[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }']
    , HA = ['[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }', '[data-framer-component-type="NativeScroll"] > * { position: relative; }', '[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }', '[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }', '[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }', '[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }']
    , WA = ['[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }']
    , UA = ['[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }']
    , GA = ['[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }']
    , qA = ['[data-framer-cursor="pointer"] { cursor: pointer; }', '[data-framer-cursor="grab"] { cursor: grab; }', '[data-framer-cursor="grab"]:active { cursor: grabbing; }']
    , XA = ['[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }', "[data-framer-generated] * { pointer-events: unset }"]
    , YA = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`]
    , KA = ['[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }', '[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }']
    , hm = "--framer-will-change-override"
    , QA = "(background: -webkit-named-image(i))"
    , ZA = "(grid-template-rows: subgrid)"
    , JA = e => e ? [`body { ${hm}: none; }`, `@supports ${QA} and (not ${ZA}) { body { ${hm}: transform; } }`] : [`body { ${hm}: none; }`]
    , eD = e => e ? XA : []
    , tD = [".svgContainer svg { display: block; }"]
    , fC = e => [...JA(e), ...TA, ...LA, ...kA, ...SA, ...$A, ...NA, ...jA, ...HA, ...UA, ...WA, ...GA, ...qA, ...eD(e), ...tD, ...YA, ...KA]
    , nD = fC(!1)
    , rD = fC(!0)
    , R1 = !1;
function Xa() {
    if (R1)
        return;
    R1 = !0;
    let e = fe.current() === fe.preview ? rD : nD;
    for (let t of e)
        uC(t, void 0, void 0)
}
function Un(e) {
    return typeof e == "function"
}
function ig(e) {
    return typeof e == "boolean"
}
function ye(e) {
    return typeof e == "string"
}
function De(e) {
    return Number.isFinite(e)
}
function Ku(e) {
    return Array.isArray(e)
}
function Se(e) {
    return e !== null && typeof e == "object" && !Ku(e)
}
function Qe(e) {
    return typeof e > "u"
}
function dr(e) {
    return e === null
}
function iD(e) {
    return e == null
}
function dC(e) {
    return e instanceof Date && !Number.isNaN(e.getTime())
}
function hC(e) {
    return Se(e) && Un(e.return)
}
function oD(e) {
    return Se(e) || Un(e)
}
var E1 = "optional";
function sD(e) {
    return !!e && E1 in e && e[E1] === !0
}
function aD(e) {
    try {
        switch (e.type) {
            case "string":
            case "collectionreference":
            case "multicollectionreference":
            case "color":
            case "date":
            case "link":
            case "boxshadow":
            case "padding":
            case "borderradius":
                return ye(e.defaultValue) ? e.defaultValue : void 0;
            case "boolean":
                return ig(e.defaultValue) ? e.defaultValue : void 0;
            case "enum":
                return Qe(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0;
            case "fusednumber":
            case "number":
                return De(e.defaultValue) ? e.defaultValue : void 0;
            case "transition":
                return Se(e.defaultValue) ? e.defaultValue : void 0;
            case "border":
                return Se(e.defaultValue) ? e.defaultValue : void 0;
            case "font":
                return Se(e.defaultValue) ? e.defaultValue : void 0;
            case "object":
                {
                    let t = Se(e.defaultValue) ? e.defaultValue : {};
                    return Se(e.controls) && pC(t, e.controls),
                        t
                }
            case "array":
                return Ku(e.defaultValue) ? e.defaultValue : void 0;
            case "file":
            case "image":
            case "richtext":
            case "pagescope":
            case "eventhandler":
            case "segmentedenum":
            case "responsiveimage":
            case "componentinstance":
            case "scrollsectionref":
            case "customcursor":
            case "cursor":
                return;
            default:
                return
        }
    } catch {
        return
    }
}
function pC(e, t) {
    for (let n in t) {
        let r = t[n];
        if (!r)
            continue;
        let i = e[n];
        if (!Qe(i) || sD(r))
            continue;
        let o = aD(r);
        Qe(o) || (e[n] = o)
    }
}
function lD(e) {
    if (Se(e.defaultProps))
        return e.defaultProps;
    let t = {};
    return e.defaultProps = t,
        t
}
function cD(e, t) {
    if (!oD(e))
        return;
    let n = lD(e);
    pC(n, t)
}
function uD(e, t) {
    Object.assign(e, {
        propertyControls: t
    }),
        cD(e, t)
}
function fD(e) {
    return e.propertyControls
}
var Ne = e => e;
function dD(e) {
    let t = Object.create(Object.prototype);
    return n => (t[n] === void 0 && (t[n] = e(n)),
        t[n])
}
var hD = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/u
    , pD = dD(e => hD.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
    , F1 = e => () => {
        ja(e)
    }
    , mD = () => () => { }
    , gD = {
        useImageSource(e) {
            return e.src ?? ""
        },
        useImageElement(e, t, n) {
            let r = new Image;
            return r.src = vt.useImageSource(e, t, n),
                e.srcSet && (r.srcset = e.srcSet),
                r
        },
        canRenderOptimizedCanvasImage() {
            return !1
        }
    }
    , vD = !1
    , yD = {
        get(e, t, n) {
            return Reflect.has(e, t) ? Reflect.get(e, t, n) : ["getLogger"].includes(String(t)) ? mD() : F1(vD ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`)
        }
    }
    , vt = new Proxy(gD, yD);
var P1 = {
    position: "absolute",
    borderRadius: "inherit",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
}
    , bD = {
        backgroundRepeat: "repeat",
        backgroundPosition: "left top",
        backgroundSize: "126px auto",
        backgroundImage: "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTI2IiBoZWlnaHQ9IjEyNiI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0xMjYgMHYyMS41ODRMMjEuNTg0IDEyNkgwdi0xNy41ODVMMTA4LjQxNSAwSDEyNlptMCAxMDguNDE0VjEyNmgtMTcuNTg2TDEyNiAxMDguNDE0Wm0wLTg0djM5LjE3MUw2My41ODUgMTI2SDI0LjQxNEwxMjYgMjQuNDE0Wm0wIDQydjM5LjE3TDEwNS41ODQgMTI2aC0zOS4xN0wxMjYgNjYuNDE0Wk0xMDUuNTg2IDAgMCAxMDUuNTg2VjY2LjQxNUw2Ni40MTUgMGgzOS4xNzFabS00MiAwTDAgNjMuNTg2VjI0LjQxNUwyNC40MTUgMGgzOS4xNzFabS00MiAwTDAgMjEuNTg2VjBoMjEuNTg2WiIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODg4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)",
        opacity: .2
    };
function xD(e) {
    switch (e) {
        case "fit":
            return "contain";
        case "stretch":
            return "fill";
        default:
            return "cover"
    }
}
function mC(e, t) {
    let n = e ?? "center"
        , r = t ?? "center";
    return n === "center" && r === "center" ? "center" : n + " " + r
}
function og(e) {
    return {
        display: "block",
        width: "100%",
        height: "100%",
        borderRadius: "inherit",
        objectPosition: mC(e.positionX, e.positionY),
        objectFit: xD(e.fit)
    }
}
function wD({ image: e, containerSize: t, nodeId: n, alt: r, draggable: i }) {
    let o = vt.useImageSource(e, t, n)
        , s = og(e)
        , a = x.useRef(null);
    return k("img", {
        ref: a,
        decoding: "async",
        fetchpriority: e.fetchPriority,
        loading: e.loading,
        sizes: e.sizes,
        srcSet: e.srcSet,
        src: o,
        alt: r ?? e.alt ?? "",
        style: s,
        draggable: i
    })
}
function SD({ image: e, containerSize: t, nodeId: n }) {
    let r = x.useRef(null)
        , i = vt.useImageElement(e, t, n)
        , o = og(e);
    return x.useLayoutEffect(() => {
        let s = r.current;
        if (s !== null)
            return s.appendChild(i),
                () => {
                    s.removeChild(i)
                }
    }
        , [i]),
        Object.assign(i.style, o),
        k("div", {
            ref: r,
            style: {
                display: "contents",
                borderRadius: "inherit"
            }
        })
}
function kD({ nodeId: e, image: t, containerSize: n }) {
    let r = x.useRef(null)
        , i = vt.useImageSource(t, n, e);
    return x.useLayoutEffect(() => {
        let o = r.current;
        if (o === null)
            return;
        let s = og(t);
        vt.renderOptimizedCanvasImage(o, i, s, e)
    }
        , [e, t, i, n]),
        k("div", {
            ref: r,
            style: {
                display: "contents",
                borderRadius: "inherit"
            }
        })
}
function gC({ layoutId: e, image: t, ...n }) {
    e && (e = e + "-background");
    let r = {
        ...P1,
        ...bD
    }
        , i = null;
    if (ye(t.src))
        if (t.fit === "tile" && t.pixelWidth && t.pixelHeight) {
            let o = De(t.backgroundSize) ? t.backgroundSize : 1
                , s = {
                    width: Math.round(o * t.pixelWidth),
                    height: Math.round(o * t.pixelHeight)
                }
                , a = vt.useImageSource(t, s);
            r.backgroundImage = `url(${a})`,
                r.backgroundRepeat = "repeat",
                r.backgroundPosition = mC(t.positionX, t.positionY),
                r.opacity = void 0,
                r.border = 0,
                r.backgroundSize = `${(o * (t.pixelWidth / 2)).toFixed(2)}px auto`,
                i = null
        } else
            fe.current() !== fe.canvas ? i = k(wD, {
                image: t,
                ...n
            }) : vt.canRenderOptimizedCanvasImage(vt.useImageSource(t)) ? i = k(kD, {
                image: t,
                ...n
            }) : i = k(SD, {
                image: t,
                ...n
            });
    return k(Ye.div, {
        layoutId: e,
        style: i ? P1 : r,
        "data-framer-background-image-wrapper": !0,
        children: i
    })
}
var CD = "src"
    , Xi = {
        isImageObject: function (e) {
            return !e || typeof e == "string" ? !1 : CD in e
        }
    };
function TD(e, t) {
    let { _forwardedOverrideId: n, _forwardedOverrides: r, id: i } = t
        , o = n ?? i
        , s = r && o ? r[o] : void 0;
    return s && typeof s == "string" && (e = {
        ...e,
        src: s
    }),
        e
}
function RD(e) {
    let { background: t, image: n } = e;
    if (n !== void 0 && t && !Xi.isImageObject(t))
        return;
    let r = null;
    if (ye(n) ? r = {
        alt: "",
        src: n
    } : r = ft.get(t, null),
        !!Xi.isImageObject(r))
        return TD(r, e)
}
function ED(e, t, n = !0) {
    let { borderWidth: r, borderStyle: i, borderColor: o } = e;
    if (!r)
        return;
    let s, a, l, c;
    if (typeof r == "number" ? s = a = l = c = r : (s = r.top || 0,
        a = r.bottom || 0,
        l = r.left || 0,
        c = r.right || 0),
        !(s === 0 && a === 0 && l === 0 && c === 0)) {
        if (n && s === a && s === l && s === c) {
            t.border = `${s}px ${i} ${o}`;
            return
        }
        t.borderStyle = e.borderStyle,
            t.borderColor = e.borderColor,
            t.borderTopWidth = `${s}px`,
            t.borderBottomWidth = `${a}px`,
            t.borderLeftWidth = `${l}px`,
            t.borderRightWidth = `${c}px`
    }
}
function FD(e) {
    let t = e.layoutId ? `${e.layoutId}-border` : void 0;
    if (!e.borderWidth)
        return null;
    let n = {
        position: "absolute",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        borderRadius: "inherit",
        pointerEvents: "none"
    };
    return e.border ? (n.border = e.border,
        k(Ye.div, {
            style: n
        })) : (ED(e, n, !1),
            k(Ye.div, {
                "data-frame-border": !0,
                style: n,
                layoutId: t
            }))
}
function Ya(e) {
    return e && e !== "search" && e !== "slot" && e !== "template" ? Ye[e] : Ye.div
}
var PD = yr(Km(), 1)
    , Zt = typeof _e < "u" ? _e : void 0
    , Gn = () => typeof document == "object";
var _D = () => {
    let e = -1
        , n = Zt && /Version\/([\d.]+)/u.exec(Zt.userAgent);
    return n && n[1] && (e = parseFloat(n[1])),
        e
}
    , ID = () => Zt && /Chrome/u.test(Zt.userAgent) && /Google Inc/u.test(Zt.vendor) && !LD()
    , vC = () => Zt && /Safari/u.test(Zt.userAgent) && /Apple Computer/u.test(Zt.vendor)
    , OD = () => Zt && /Firefox\/\d+\.\d+$/u.test(Zt.userAgent)
    , MD = () => Zt && /FramerX/u.test(Zt.userAgent)
    , LD = () => Zt && /Edg\//u.test(Zt.userAgent);
var VD = () => PD.default.env.NODE_ENV === "test";
var AD = ID();
function yC(e) {
    let t = {};
    return !AD || fe.current() !== fe.canvas || ((e === !0 || e === "x") && (t["data-framer-layout-hint-center-x"] = !0),
        (e === !0 || e === "y") && (t["data-framer-layout-hint-center-y"] = !0)),
        t
}
function sg(e) {
    return e.replace(/^id_/u, "").replace(/\\/gu, "")
}
function bC(e, t) {
    if (!t && (t = e.children,
        !t))
        return {
            props: e,
            children: t
        };
    let n = e._forwardedOverrides;
    return n ? (t = x.Children.map(t, r => x.isValidElement(r) ? x.cloneElement(r, {
        _forwardedOverrides: n
    }) : r),
    {
        props: e,
        children: t
    }) : {
        props: e,
        children: t
    }
}
function Qu(e) {
    return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === "x" ? `translateX(-50%) ${n}` : e === "y" ? `translateY(-50%) ${n}` : n || "none"
}
function fs(e, { specificLayoutId: t, postfix: n } = {}) {
    let { name: r, layoutIdKey: i, duplicatedFrom: o, __fromCodeComponentNode: s = !1, drag: a } = e
        , { getLayoutId: l, enabled: c } = D(ss);
    return ue(() => {
        if (!c)
            return e.layoutId;
        let u = t || e.layoutId;
        if (!u && (a || !i || s))
            return;
        let f = u || l({
            id: i,
            name: r,
            duplicatedFrom: o
        });
        if (f)
            return n ? `${f}-${n}` : f
    }
        , [c])
}
var xC = typeof document < "u" ? ze : H
    , ds = x.createContext(!1);
function Zu() {
    let [e, t] = x.useState(0);
    return x.useCallback(() => t(n => n + 1), [])
}
var DD = (() => qM().ResizeObserver)();
var zD = class {
    constructor() {
        E(this, "sharedResizeObserver"),
            E(this, "callbacks", new WeakMap);
        let e = it.ResizeObserver ?? DD;
        this.sharedResizeObserver = new e(this.updateResizedElements.bind(this))
    }
    updateResizedElements(e) {
        for (let t of e) {
            let n = this.callbacks.get(t.target);
            n && n(t.contentRect)
        }
    }
    observeElementWithCallback(e, t) {
        this.sharedResizeObserver.observe(e),
            this.callbacks.set(e, t)
    }
    unobserve(e) {
        this.sharedResizeObserver.unobserve(e),
            this.callbacks.delete(e)
    }
}
    , du = (() => Gn() ? new zD : void 0)();
function BD(e) {
    let t = Zu();
    H(() => {
        let n = e?.current;
        if (n)
            return du?.observeElementWithCallback(e.current, t),
                () => {
                    du?.unobserve(n)
                }
    }
        , [e, t])
}
var $D = "data-framer-size-compatibility-wrapper";
function ND(e) {
    return [...e.firstElementChild && e.firstElementChild.hasAttribute($D) ? e.firstElementChild.children : e.children].filter(wC).map(SC)
}
function wC(e) {
    return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement
}
function SC(e) {
    if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== "contents")
        return e;
    let t = [...e.children].find(wC);
    return t ? SC(t) : e
}
function Ju(e, t, n = () => [], r = {}) {
    let { id: i, visible: o, _needsMeasure: s } = e
        , { skipHook: a = !1 } = r
        , l = !!D(ds)
        , c = fe.current() === fe.canvas;
    xC(() => {
        !c || l || a || t.current && i && o && s && vt.queueMeasureRequest(sg(i), t.current, n(t.current))
    }
    )
}
function jD(e) {
    let t = e.closest("[data-framer-component-container]");
    t && vt.queueMeasureRequest(sg(t.id), t, ND(t))
}
var eo = Object.keys;
function Fu(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
var HD = "equals";
function _1(e) {
    return e === null || !(HD in e) ? !1 : typeof e.equals == "function"
}
function ag(e, t) {
    return e === t ? !0 : e !== e && t !== t
}
function WD(e, t) {
    let n = e.length;
    if (n !== t.length)
        return !1;
    for (let r = n; r-- !== 0;)
        if (!ag(e[r], t[r]))
            return !1;
    return !0
}
function UD(e, t) {
    let n = e.length;
    if (n !== t.length)
        return !1;
    for (let r = n; r-- !== 0;)
        if (!ef(e[r], t[r], !0))
            return !1;
    return !0
}
function GD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let [n, r] of e.entries())
        if (!ag(r, t.get(n)))
            return !1;
    return !0
}
function qD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let [n, r] of e.entries())
        if (!ef(r, t.get(n), !0))
            return !1;
    return !0
}
function XD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let n of e.keys())
        if (!t.has(n))
            return !1;
    return !0
}
function YD(e, t) {
    let n = eo(e);
    if (n.length !== eo(t).length)
        return !1;
    for (let r of n) {
        if (!Fu(t, r))
            return !1;
        if (!(r === "_owner" && Fu(e, "$$typeof") && e.$$typeof) && !ag(e[r], t[r]))
            return !1
    }
    return !0
}
function KD(e, t) {
    let n = eo(e);
    if (n.length !== eo(t).length)
        return !1;
    for (let r of n) {
        if (!Fu(t, r))
            return !1;
        if (!(r === "_owner" && Fu(e, "$$typeof") && e.$$typeof) && !ef(e[r], t[r], !0))
            return !1
    }
    return !0
}
function ef(e, t, n) {
    if (e === t)
        return !0;
    if (!e || !t)
        return e !== e && t !== t;
    let r = typeof e;
    if (r !== typeof t || r !== "object")
        return !1;
    let o = Array.isArray(e)
        , s = Array.isArray(t);
    if (o && s)
        return n ? UD(e, t) : WD(e, t);
    if (o !== s)
        return !1;
    let a = e instanceof Map
        , l = t instanceof Map;
    if (a && l)
        return n ? qD(e, t) : GD(e, t);
    if (a !== l)
        return !1;
    let c = e instanceof Set
        , u = t instanceof Set;
    if (c && u)
        return XD(e, t);
    if (c !== u)
        return !1;
    let f = e instanceof Date
        , d = t instanceof Date;
    if (f && d)
        return e.getTime() === t.getTime();
    if (f !== d)
        return !1;
    let p = e instanceof RegExp
        , v = t instanceof RegExp;
    return p && v ? e.toString() === t.toString() : p !== v ? !1 : _1(e) && _1(t) ? e.equals(t) : n ? KD(e, t) : YD(e, t)
}
function lg(e, t, n = !0) {
    try {
        return ef(e, t, n)
    } catch (r) {
        if (r instanceof Error && /stack|recursion/iu.exec(r.message))
            return console.warn("Warning: isEqual does not handle circular references.", r.name, r.message),
                !1;
        throw r
    }
}
var kC = "0.000001px"
    , pm = (() => ` translateZ(${kC})`)()
    , CC = (() => MD() || vC() || VD())();
function QD(e) {
    e.willChange = "transform";
    let t = fe.current() === fe.canvas;
    CC && t && (e.translateZ = kC)
}
function cg(e) {
    e.willChange = "transform",
        ZD(e, !0)
}
function ZD(e, t) {
    let n = fe.current() === fe.canvas;
    if (!CC || !n)
        return;
    let r = ye(e.transform) && e.transform || "";
    t ? r.includes(pm) || (e.transform = r + pm) : e.transform = r.replace(pm, "")
}
function TC(e, t, n, r = !0) {
    if (!e)
        return;
    let i = Ne(e.style)
        , o = n || i[t]
        , s = () => {
            i[t] = o
        }
        ;
    i[t] = null,
        r ? Promise.resolve().then(s) : setTimeout(s, 0)
}
var za = (() => {
    class e extends ke {
        constructor() {
            super(...arguments),
                E(this, "layerElement", null),
                E(this, "setLayerElement", n => {
                    this.layerElement = n
                }
                )
        }
        static applyWillChange(n, r, i) {
            n.willChangeTransform && (i ? QD(r) : cg(r))
        }
        shouldComponentUpdate(n, r) {
            return n._needsMeasure || this.state !== r || !lg(this.props, n)
        }
        componentDidUpdate(n) {
            Ne(this.props).clip && Ne(this.props).radius === 0 && Ne(n).radius !== 0 && TC(this.layerElement, "overflow", "hidden", !1)
        }
    }
    return E(e, "defaultProps", {}),
        e
}
)();
function JD(e, t) {
    if (e.size < t)
        return;
    let r = Math.round(Math.random());
    for (let i of e.keys())
        (++r & 1) !== 1 && e.delete(i)
}
function e3(e, t, n, r) {
    let i = t.get(n);
    if (i)
        return i;
    JD(t, e);
    let o = r(n);
    return t.set(n, o),
        o
}
var RC = e => {
    let t = 0, n, r;
    if (e.length === 0)
        return t;
    for (n = 0; n < e.length; n++)
        r = e.charCodeAt(n),
            t = (t << 5) - t + r,
            t |= 0;
    return t
}
    , ug = {
        hueRotate: (e, t) => Z.toHslString(Z.hueRotate(Z(e), t)),
        setAlpha: (e, t) => Z.toRgbString(Z.alpha(Z(e), t)),
        getAlpha: e => {
            let t = rg(e);
            return t ? t.a : 1
        }
        ,
        multiplyAlpha: (e, t) => Z.toRgbString(Z.multiplyAlpha(Z(e), t)),
        toHex: e => Z.toHexString(Z(e)).toUpperCase(),
        toRgb: e => Z.toRgb(Z(e)),
        toRgbString: e => Z.toRgbString(Z(e)),
        toHSV: e => Z.toHsv(Z(e)),
        toHSL: e => Z.toHsl(Z(e)),
        toHslString: e => Z.toHslString(Z(e)),
        toHsvString: e => Z.toHsvString(Z(e)),
        hsvToHSLString: e => Z.toHslString(Z(uu(e.h, e.s, e.v, e.a))),
        hsvToHex: e => Z.toHexString(Z(uu(e.h, e.s, e.v, e.a))).toUpperCase(),
        hsvToRgbString: e => Z.toRgbString(Z(uu(e.h, e.s, e.v, e.a))),
        hsvToString: e => uu(e.h, e.s, e.v),
        rgbaToString: e => Z.toRgbString(Z(e)),
        rgbToHexString: e => Z.toHexString(Z(e)),
        hslToString: e => Z.toHslString(Z(e)),
        hslToRgbString: e => Z.toRgbString(Z(e)),
        toColorPickerSquare: e => Z.toRgbString(Z({
            h: e,
            s: 1,
            l: .5,
            a: 1
        })),
        isValid: e => Z(e).isValid !== !1,
        equals: (e, t) => (typeof e == "string" && (e = Z(e)),
            typeof t == "string" && (t = Z(t)),
            Z.equal(e, t)),
        toHexOrRgbaString: e => {
            let t = Z(e);
            return t.a !== 1 ? Z.toRgbString(t) : Z.toHexString(t)
        }
    }
    , t3 = /var\(.+\)/u
    , n3 = new Map;
function r3(e, t) {
    let n = [e, t];
    return t3.test(e) ? e : e3(1e3, n3, n, () => ug.multiplyAlpha(e, t))
}
function Ka(e, t = 1) {
    let n;
    return "stops" in e ? n = e.stops : n = [{
        value: e.start,
        position: 0
    }, {
        value: e.end,
        position: 1
    }],
        t === 1 ? n : n.map(r => ({
            ...r,
            value: r3(r.value, t)
        }))
}
function EC(e, t) {
    let n = 0;
    return Ka(e, t).forEach(r => {
        n ^= RC(r.value) ^ r.position
    }
    ),
        n
}
var i3 = ["stops"];
function FC(e) {
    return e && i3.every(t => t in e)
}
var o3 = ["start", "end"];
function PC(e) {
    return e && o3.every(t => t in e)
}
var s3 = ["angle", "alpha"]
    , Wa = {
        isLinearGradient: e => e && s3.every(t => t in e) && (PC(e) || FC(e)),
        hash: e => e.angle ^ EC(e, e.alpha),
        toCSS: (e, t) => {
            let n = Ka(e, e.alpha)
                , r = t !== void 0 ? t : e.angle
                , i = n.map(o => `${o.value} ${o.position * 100}%`);
            return `linear-gradient(${r}deg, ${i.join(", ")})`
        }
    }
    , a3 = ["widthFactor", "heightFactor", "centerAnchorX", "centerAnchorY", "alpha"]
    , Ua = {
        isRadialGradient: e => e && a3.every(t => t in e) && (PC(e) || FC(e)),
        hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ EC(e, e.alpha),
        toCSS: e => {
            let { alpha: t, widthFactor: n, heightFactor: r, centerAnchorX: i, centerAnchorY: o } = e
                , s = Ka(e, t)
                , a = s.map((l, c) => {
                    let u = s[c + 1]
                        , f = l.position === 1 && u?.position === 1 ? l.position - 1e-4 : l.position;
                    return `${l.value} ${f * 100}%`
                }
                );
            return `radial-gradient(${n * 100}% ${r * 100}% at ${i * 100}% ${o * 100}%, ${a.join(", ")})`
        }
    };
function l3({ background: e, backgroundColor: t }, n) {
    t ? typeof t == "string" || S1(t) ? n.backgroundColor = t : Z.isColorObject(e) && (n.backgroundColor = e.initialValue || Z.toRgbString(e)) : e && (e = ft.get(e, null),
        typeof e == "string" || S1(e) ? n.background = e : Wa.isLinearGradient(e) ? n.background = Wa.toCSS(e) : Ua.isRadialGradient(e) ? n.background = Ua.toCSS(e) : Z.isColorObject(e) && (n.backgroundColor = e.initialValue || Z.toRgbString(e)))
}
function we(e, t, n, r) {
    if (r === void 0 && (r = t),
        e[t] !== void 0) {
        n[r] = e[t];
        return
    }
}
function c3(e) {
    return e ? e.left !== void 0 && e.right !== void 0 : !1
}
function u3(e) {
    return e ? e.top !== void 0 && e.bottom !== void 0 : !1
}
function f3(e) {
    if (!e)
        return {};
    let t = {};
    return e.preserve3d === !0 ? t.transformStyle = "preserve-3d" : e.preserve3d === !1 && (t.transformStyle = "flat"),
        e.backfaceVisible === !0 ? t.backfaceVisibility = "visible" : e.backfaceVisible === !1 && (t.backfaceVisibility = "hidden"),
        t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility),
        e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective),
        e.__fromCanvasComponent || (e.center === !0 ? (t.left = "50%",
            t.top = "50%") : e.center === "x" ? t.left = "50%" : e.center === "y" && (t.top = "50%")),
        we(e, "size", t),
        we(e, "width", t),
        we(e, "height", t),
        we(e, "minWidth", t),
        we(e, "minHeight", t),
        we(e, "top", t),
        we(e, "right", t),
        we(e, "bottom", t),
        we(e, "left", t),
        we(e, "position", t),
        we(e, "overflow", t),
        we(e, "opacity", t),
        (!e._border || !e._border.borderWidth) && we(e, "border", t),
        we(e, "borderRadius", t),
        we(e, "radius", t, "borderRadius"),
        we(e, "color", t),
        we(e, "shadow", t, "boxShadow"),
        we(e, "x", t),
        we(e, "y", t),
        we(e, "z", t),
        we(e, "rotate", t),
        we(e, "rotateX", t),
        we(e, "rotateY", t),
        we(e, "rotateZ", t),
        we(e, "scale", t),
        we(e, "scaleX", t),
        we(e, "scaleY", t),
        we(e, "skew", t),
        we(e, "skewX", t),
        we(e, "skewY", t),
        we(e, "originX", t),
        we(e, "originY", t),
        we(e, "originZ", t),
        l3(e, t),
        t
}
function d3(e) {
    for (let t in e)
        if (t === "drag" || t.startsWith("while") || typeof Ne(e)[t] == "function" && t.startsWith("on") && !t.includes("Animation"))
            return !0;
    return !1
}
var I1 = ["onClick", "onDoubleClick", "onMouse", "onMouseDown", "onMouseUp", "onTapDown", "onTap", "onTapUp", "onPointer", "onPointerDown", "onPointerUp", "onTouch", "onTouchDown", "onTouchUp"]
    , h3 = (() => new Set([...I1, ...I1.map(e => `${e}Capture`)]))();
function p3(e) {
    if (e.drag)
        return "grab";
    for (let t in e)
        if (h3.has(t))
            return "pointer"
}
var mm = "overflow";
function m3(e) {
    return O1(e) ? !0 : e.style ? !!O1(e.style) : !1
}
function O1(e) {
    return mm in e && (e[mm] === "scroll" || e[mm] === "auto")
}
function fg(e) {
    let { left: t, top: n, bottom: r, right: i, width: o, height: s, center: a, _constraints: l, size: c, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p } = e
        , v = Et(e.minWidth)
        , g = Et(e.minHeight)
        , b = Et(e.maxWidth)
        , m = Et(e.maxHeight);
    return {
        top: Et(n),
        left: Et(t),
        bottom: Et(r),
        right: Et(i),
        width: Et(o),
        height: Et(s),
        size: Et(c),
        center: a,
        _constraints: l,
        widthType: u,
        heightType: f,
        positionFixed: d,
        positionAbsolute: p,
        minWidth: v,
        minHeight: g,
        maxWidth: b,
        maxHeight: m
    }
}
var M1 = {
    x: 0,
    y: 0,
    width: 200,
    height: 200
};
function g3(e) {
    x.useInsertionEffect(() => {
        Xa()
    }
        , []);
    let t = !!D(ds)
        , { style: n, _initialStyle: r, __fromCanvasComponent: i, size: o } = e
        , s = fg(e)
        , a = rA(s)
        , l = {
            display: "block",
            flex: n?.flex ?? "0 0 auto",
            userSelect: fe.current() !== fe.preview ? "none" : void 0
        };
    e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0);
    let c = !d3(e) && !e.__fromCanvasComponent && !m3(e)
        , u = e.style ? !("pointerEvents" in e.style) : !0;
    c && u && (l.pointerEvents = "none");
    let d = x.Children.count(e.children) > 0 && x.Children.toArray(e.children).every(m => typeof m == "string" || typeof m == "number") && {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        textAlign: "center"
    }
        , p = f3(e);
    o === void 0 && !i && (c3(p) || (l.width = M1.width),
        u3(p) || (l.height = M1.height)),
        s.minWidth !== void 0 && (l.minWidth = s.minWidth),
        s.minHeight !== void 0 && (l.minHeight = s.minHeight);
    let v = {};
    us(s) && a && !cC(e) && (v = {
        left: a.x,
        top: a.y,
        width: a.width,
        height: a.height,
        right: void 0,
        bottom: void 0
    }),
        Object.assign(l, d, r, p, v, n),
        Object.assign(l, {
            overflowX: l.overflowX ?? l.overflow,
            overflowY: l.overflowY ?? l.overflow,
            overflow: void 0
        }),
        za.applyWillChange(e, l, !0);
    let g = l;
    l.transform || (g = {
        x: 0,
        y: 0,
        ...l
    });
    let b = fe.current() === fe.canvas;
    return e.positionSticky ? (!b || t) && (g.position = "sticky",
        g.willChange = "transform",
        g.zIndex = 1,
        g.top = e.positionStickyTop,
        g.right = e.positionStickyRight,
        g.bottom = e.positionStickyBottom,
        g.left = e.positionStickyLeft) : b && (e.positionFixed || e.positionAbsolute) && (g.position = "absolute"),
        "rotate" in g && g.rotate === void 0 && delete g.rotate,
        [g, a]
}
var v3 = new Set(["width", "height", "opacity", "overflow", "radius", "background", "color", "x", "y", "z", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "originX", "originY", "originZ"]);
function y3(e) {
    let t = {};
    for (let n in e)
        (mo(n) || pD(n)) && !v3.has(n) ? t[n] = Ne(e)[n] : (n === "positionTransition" || n === "layoutTransition") && (t.layout = !0,
            typeof Ne(e)[n] != "boolean" && !e.transition && (t.transition = Ne(e)[n]));
    return t
}
function b3(e) {
    return "data-framer-name" in e
}
var x3 = Ie(function (t, n) {
    let { name: r, center: i, border: o, _border: s, __portal: a } = t
        , { props: l, children: c } = bC(t)
        , u = y3(l)
        , f = fs(t)
        , d = p3(t)
        , p = V(null)
        , v = n ?? p
        , g = {
            "data-framer-component-type": t.componentType ?? "Frame",
            "data-framer-cursor": d,
            "data-framer-highlight": d === "pointer" ? !0 : void 0,
            "data-layoutid": f,
            "data-framer-offset-parent-id": Ne(t)["data-framer-offset-parent-id"]
        };
    !b3(t) && r && (Ne(g)["data-framer-name"] = r);
    let [b, m] = g3(l)
        , h = fg(l)
        , y = cC(h);
    i && !(m && !y && us(h)) ? (u.transformTemplate || (u.transformTemplate = Qu(i)),
        Object.assign(g, yC(i))) : u.transformTemplate || (u.transformTemplate = void 0),
        Ju(t, v);
    let w = RD(t)
        , C = !!D(ds)
        , S = w3(l, h, m, C)
        , T = lC(ge(lt, {
            children: [w ? k(gC, {
                alt: t.alt ?? "",
                image: w,
                containerSize: m ?? void 0,
                nodeId: t.id && sg(t.id),
                layoutId: f
            }) : null, c, k(FD, {
                ...s,
                border: o,
                layoutId: f
            })]
        }), S)
        , R = Ya(t.as)
        , { size: F, radius: P, shadow: B } = b;
    return F !== void 0 && (delete b.size,
        b.height === void 0 && (b.height = F),
        b.width === void 0 && (b.width = F)),
        P !== void 0 && (delete b.radius,
            b.borderRadius = P),
        B !== void 0 && (delete b.shadow,
            b.boxShadow = B),
        ge(R, {
            ...g,
            ...u,
            layoutId: f,
            style: b,
            ref: v,
            children: [T, a]
        })
})
    , Ba = Ie(function (t, n) {
        let { visible: r = !0 } = t;
        return r ? k(x3, {
            ...t,
            ref: n
        }) : null
    });
function w3(e, t, n, r) {
    if (r)
        return n ? {
            width: n.width,
            height: n.height
        } : 1;
    let { _usesDOMRect: i } = e
        , { widthType: o = 0, heightType: s = 0, width: a, height: l } = t;
    return n && !i ? n : o === 0 && s === 0 && typeof a == "number" && typeof l == "number" ? {
        width: a,
        height: l
    } : i || e.positionFixed || e.positionAbsolute ? 2 : 0
}
var dg = "__LAYOUT_TREE_ROOT"
    , _C = x.createContext({
        schedulePromoteTree: () => { }
        ,
        scheduleProjectionDidUpdate: () => { }
        ,
        initLead: () => { }
    })
    , S3 = class extends ke {
        constructor() {
            super(...arguments),
                E(this, "shouldAnimate", !1),
                E(this, "transition"),
                E(this, "lead"),
                E(this, "follow"),
                E(this, "scheduledPromotion", !1),
                E(this, "scheduledDidUpdate", !1),
                E(this, "scheduleProjectionDidUpdate", () => {
                    this.scheduledDidUpdate = !0
                }
                ),
                E(this, "schedulePromoteTree", (e, t, n) => {
                    this.follow = this.lead,
                        this.shouldAnimate = n,
                        this.lead = e,
                        this.transition = t,
                        this.scheduledPromotion = !0
                }
                ),
                E(this, "initLead", (e, t) => {
                    this.follow = this.lead,
                        this.lead = e,
                        this.follow && t && (this.follow.layoutMaybeMutated = !0)
                }
                ),
                E(this, "sharedLayoutContext", {
                    schedulePromoteTree: this.schedulePromoteTree,
                    scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate,
                    initLead: this.initLead
                })
        }
        getSnapshotBeforeUpdate() {
            var e;
            if (!this.scheduledPromotion || !this.lead || !this.follow)
                return null;
            let t = !!((e = this.lead) != null && e.layoutMaybeMutated) && !this.shouldAnimate;
            return this.lead.projectionNodes.forEach(n => {
                var r;
                n?.promote({
                    needsReset: t,
                    transition: this.shouldAnimate ? this.transition : void 0,
                    preserveFollowOpacity: n.options.layoutId === dg && !((r = this.follow) != null && r.isExiting)
                })
            }
            ),
                this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(),
                this.lead.layoutMaybeMutated = !1,
                this.transition = void 0,
                this.scheduledPromotion = !1,
                null
        }
        componentDidUpdate() {
            var e, t;
            if (!this.lead)
                return null;
            this.scheduledDidUpdate && ((t = (e = this.lead.rootProjectionNode) == null ? void 0 : e.root) == null || t.didUpdate(),
                this.scheduledDidUpdate = !1)
        }
        render() {
            return k(_C.Provider, {
                value: this.sharedLayoutContext,
                children: this.props.children
            })
        }
    }
    , k3 = {
        width: "100%",
        height: "100%",
        backgroundColor: "none"
    };
function C3(e) {
    return k(Ye.div, {
        layoutId: dg,
        style: k3,
        children: e.children
    })
}
function L1(e, t) {
    Un(e) ? e(t) : IC(e) && (e.current = t)
}
function IC(e) {
    return Se(e) && "current" in e
}
function T3() {
    let e = yt(() => new Set)
        , t = yt(() => new Map);
    return yt(() => (n, r) => ({
        get current() {
            return n.current
        },
        set current(i) {
            r && r(i),
                n.current = i;
            let o = i === null;
            e.forEach(s => {
                if (o && t.has(s))
                    return;
                let a = s(i);
                a && t.set(s, a)
            }
            ),
                o && (t.forEach(s => s()),
                    t.clear())
        },
        observe(i, o = !1) {
            e.has(i) || (e.add(i),
                !o && n.current && i(n.current))
        },
        unobserve(i) {
            i && e.delete(i)
        },
        cleanup(i) {
            var o;
            return !i || !t.has(i) ? !1 : ((o = t.get(i)) == null || o(),
                !0)
        }
    }))
}
function hg(e) {
    let t = V(null)
        , n = T3();
    return yt(() => IC(e) ? n(e) : Un(e) ? n(t, e) : n(t))
}
function to(e, t, n) {
    var r;
    let i = V()
        , o = V();
    if (ue(() => {
        o.current !== void 0 && (o.current = !0)
    }
        , [n]),
        !e)
        return;
    let s = o.current;
    if (s) {
        o.current = !1,
            e.cleanup(i.current) || (r = i.current) == null || r.call(i, null);
        let a = e.current;
        a && t?.(a)
    }
    i.current !== t && (e.unobserve(i.current),
        i.current = t,
        e.observe(t, s),
        o.current === void 0 && (o.current = !1))
}
var R3 = class {
    constructor(e) {
        E(this, "sharedIntersectionObserver"),
            E(this, "callbacks", new WeakMap),
            document && (this.sharedIntersectionObserver = new IntersectionObserver(this.resizeObserverCallback.bind(this), e))
    }
    resizeObserverCallback(e, t) {
        for (let n of e) {
            let r = this.callbacks.get(n.target);
            r && r([n], t)
        }
    }
    observeElementWithCallback(e, t) {
        this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e),
            this.callbacks.set(e, t))
    }
    unobserve(e) {
        this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e),
            this.callbacks.delete(e))
    }
    get root() {
        var e;
        return (e = this.sharedIntersectionObserver) == null ? void 0 : e.root
    }
}
    , E3 = be(new Map);
function F3(e, t, n) {
    if (typeof IntersectionObserver > "u")
        return;
    let r = yt(() => `${n.rootMargin}`)
        , i = D(E3)
        , { enabled: o } = n;
    to(e, s => {
        var a;
        if (!o || s === null)
            return;
        let l = i.get(r);
        if (!l || l.root !== ((a = n.root) == null ? void 0 : a.current)) {
            let { root: c, ...u } = n;
            l = new R3({
                ...u,
                root: c?.current
            }),
                i.set(r, l)
        }
        return l.observeElementWithCallback(s, t),
            () => {
                l?.unobserve(s)
            }
    }
        , [o])
}
var P3 = new Array(100).fill(void 0).map((e, t) => t * .01)
    , _3 = x.createContext(null);
function OC(e, t, n) {
    let r = x.useRef({
        isInView: !1,
        hasAnimatedOnce: !1
    })
        , { enabled: i, animateOnce: o, threshold: s, rootMargin: a = "0px 0px 0px 0px" } = n
        , l = x.useCallback(([c]) => {
            if (!c)
                return;
            let { isInView: u, hasAnimatedOnce: f } = r.current
                , d = O3(c, s?.y ?? 0);
            if (d && !u) {
                if (o && f)
                    return;
                r.current.hasAnimatedOnce = !0,
                    r.current.isInView = !0,
                    t(!0);
                return
            }
            if (!d && u) {
                if (r.current.isInView = !1,
                    o)
                    return;
                t(!1);
                return
            }
        }
            , [o, s?.y, t]);
    F3(e, l, {
        threshold: P3,
        rootMargin: a,
        enabled: i ?? !0
    })
}
function I3(e, t) {
    return t.height === 0 ? 0 : e.height / Math.min(t.height, it.innerHeight)
}
function O3({ boundingClientRect: e, intersectionRect: t, isIntersecting: n }, r) {
    return e.height === 0 ? n : n && I3(t, e) >= r
}
var W8 = yr(Gu(), 1);
var G8 = yr(Gu(), 1);
var V1 = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
    , zr = Symbol("private")
    , gm = (() => {
        function e(t = {}, n = !1, r = !0) {
            let i = {
                [zr]: {
                    makeAnimatables: n,
                    observeAnimatables: r,
                    observers: new Jk,
                    reset() {
                        for (let s in o)
                            if (V1(o, s)) {
                                let a = V1(t, s) ? Ne(t)[s] : void 0;
                                a !== void 0 ? o[s] = a : delete o[s]
                            }
                    },
                    transactions: new Set
                }
            }
                , o = new Proxy(i, L3);
            return Object.assign(o, t),
                o
        }
        return e.resetObject = t => t[zr].reset(),
            e.addObserver = (t, n) => t[zr].observers.add(n),
            e
    }
    )()
    , M3 = class {
        constructor() {
            E(this, "set", (e, t, n, r) => {
                if (t === zr)
                    return !1;
                let i = e[zr], o, s;
                if (Wn(n) ? (o = n,
                    s = o.get()) : s = n,
                    i.makeAnimatables && typeof n != "function" && typeof n != "object" && !o && (o = ft(n)),
                    i.observeAnimatables && o) {
                    let u = i.transactions;
                    o.onUpdate({
                        update: (f, d) => {
                            d && u.add(d),
                                i.observers.notify({
                                    value: r
                                }, d)
                        }
                        ,
                        finish: f => {
                            u.delete(f) && i.observers.finishTransaction(f)
                        }
                    })
                }
                let a = !1
                    , l = !0
                    , c = Ne(e)[t];
                if (c !== void 0) {
                    Wn(c) ? (l = c.get() !== s,
                        c.set(s)) : (l = c !== s,
                            Ne(e)[t] = s);
                    let u = s !== null && typeof s == "object";
                    (Array.isArray(s) || u) && (l = !0),
                        a = !0
                } else
                    o && (n = o),
                        a = Reflect.set(e, t, n);
                return l && i.observers.notify({
                    value: r
                }),
                    a
            }
            ),
                E(this, "get", (e, t, n) => {
                    if (t === zr)
                        return Ne(e)[t];
                    let r = Reflect.get(e, t, n);
                    return typeof r == "function" ? r.bind(n) : r
                }
                )
        }
        deleteProperty(e, t) {
            let n = Reflect.deleteProperty(e, t);
            return e[zr].observers.notify({
                value: e
            }),
                n
        }
        ownKeys(e) {
            let t = Reflect.ownKeys(e)
                , n = t.indexOf(zr);
            return n !== -1 && t.splice(n, 1),
                t
        }
        getOwnPropertyDescriptor(e, t) {
            if (t !== zr)
                return Reflect.getOwnPropertyDescriptor(e, t)
        }
    }
    , L3 = new M3;
var V3 = "opacity";
function A3(e) {
    return V3 in e
}
function D3(e, t) {
    if (!A3(e))
        return;
    let n = ft.getNumber(e.opacity);
    n !== 1 && (t.opacity = n)
}
function z3(e) {
    let t = [];
    if (e && e.length) {
        let n = e.map(r => `drop-shadow(${r.x}px ${r.y}px ${r.blur}px ${r.color})`);
        t.push(...n)
    }
    return t
}
function MC(e, t) {
    if (!e.shadows || e.shadows.length === 0)
        return;
    let n = e.shadows.map(r => `${r.x}px ${r.y}px ${r.blur}px ${r.color}`).join(", ");
    n && (t.textShadow = n)
}
function B3(e, t) {
    let n = [];
    re(e.brightness) && n.push(`brightness(${e.brightness / 100})`),
        re(e.contrast) && n.push(`contrast(${e.contrast / 100})`),
        re(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`),
        re(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`),
        re(e.invert) && n.push(`invert(${e.invert / 100})`),
        re(e.saturate) && n.push(`saturate(${e.saturate / 100})`),
        re(e.sepia) && n.push(`sepia(${e.sepia / 100})`),
        re(e.blur) && n.push(`blur(${e.blur}px)`),
        e.dropShadows && n.push(...z3(e.dropShadows)),
        n.length !== 0 && (t.filter = t.WebkitFilter = n.join(" "))
}
function $3(e, t) {
    re(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`)
}
function pg(e, t) {
    $3(e, t),
        B3(e, t)
}
var N3 = class extends ke {
    constructor() {
        super(...arguments),
            E(this, "layoutMaybeMutated"),
            E(this, "projectionNodes", new Map),
            E(this, "rootProjectionNode"),
            E(this, "isExiting"),
            E(this, "shouldPreserveFollowOpacity", e => e.options.layoutId === dg && !this.props.isExiting),
            E(this, "switchLayoutGroupContext", {
                register: e => this.addChild(e),
                deregister: e => this.removeChild(e),
                transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0,
                shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity
            })
    }
    componentDidMount() {
        this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout)
    }
    shouldComponentUpdate(e) {
        let { isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: o, sharedLayoutContext: s } = e;
        if (this.isExiting = n,
            t === void 0)
            return !0;
        let a = !this.props.isLead && !!t
            , l = this.props.isExiting && !n
            , c = a || l
            , u = !!this.props.isLead && !t
            , f = this.props.isOverlayed !== r;
        return (c || u) && this.projectionNodes.forEach(d => d?.willUpdate()),
            c ? s.schedulePromoteTree(this, o, !!i) : f && s.scheduleProjectionDidUpdate(),
            !!c && !!i
    }
    addChild(e) {
        let t = e.options.layoutId;
        t && (this.projectionNodes.set(t, e),
            this.setRootChild(e))
    }
    setRootChild(e) {
        if (!this.rootProjectionNode)
            return this.rootProjectionNode = e;
        this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e
    }
    removeChild(e) {
        let t = e.options.layoutId;
        t && this.projectionNodes.delete(t)
    }
    render() {
        return k(Ll.Provider, {
            value: this.switchLayoutGroupContext,
            children: this.props.children
        })
    }
}
    , j3 = e => {
        let t = x.useContext(_C);
        return k(N3, {
            ...e,
            sharedLayoutContext: t
        })
    }
    , H3 = x.createContext(!0);
function W3() {
    return new Map
}
function U3() {
    return yt(W3)
}
var LC = be({
    register: () => { }
    ,
    deregister: () => { }
})
    , G3 = ({ isCurrent: e, isOverlayed: t, children: n }) => {
        let r = U3()
            , i = Q(a => {
                if (r.has(a)) {
                    console.warn("NavigationTargetWrapper: already registered");
                    return
                }
                r.set(a, void 0)
            }
                , [r])
            , o = Q(a => {
                let l = r.get(a);
                l?.(),
                    r.delete(a)
            }
                , [r])
            , s = V({
                register: i,
                deregister: o
            }).current;
        return H(() => (r.forEach((a, l) => {
            let c = l(e, t);
            r.set(l, Un(c) ? c : void 0)
        }
        ),
            () => {
                r.forEach((a, l) => {
                    a && (a(),
                        r.set(l, void 0))
                }
                )
            }
        ), [e, t, r]),
            k(LC.Provider, {
                value: s,
                children: n
            })
    }
    ;
function VC(e, t = []) {
    let { register: n, deregister: r } = D(LC);
    H(() => {
        if (e)
            return n(e),
                () => r(e)
    }
        , [n, r, ...t])
}
var vm = x.memo(function ({ isLayeredContainer: t, isCurrent: n, isPrevious: r, isOverlayed: i = !1, visible: o, transitionProps: s, children: a, backdropColor: l, onTapBackdrop: c, backfaceVisible: u, exitBackfaceVisible: f, animation: d, exitAnimation: p, instant: v, initialProps: g, exitProps: b, position: m = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
}, withMagicMotion: h, index: y, areMagicMotionLayersPresent: w, id: C, isInitial: S }) {
    let T = wb()
        , R = D(xo)
        , { persistLayoutIdCache: F } = D(ss)
        , P = V({
            wasCurrent: void 0,
            wasPrevious: !1,
            wasBeingRemoved: !1,
            wasReset: !0,
            origins: A1({}, g, s)
        })
        , B = V(null)
        , $ = R !== null && !R.isPresent;
    n && P.current.wasCurrent === void 0 && F(),
        H(() => {
            if (t || !T)
                return;
            if ($) {
                P.current = {
                    ...P.current,
                    wasBeingRemoved: $
                };
                return
            }
            let { wasPrevious: le, wasCurrent: q } = P.current
                , Je = n && !q || !$ && P.current.wasBeingRemoved && n
                , Re = r && !le
                , et = A1(P.current.origins, g, s)
                , Pe = P.current.wasReset;
            Je || Re ? (T.stop(),
                T.start({
                    zIndex: y,
                    ...et,
                    ...s
                }),
                Pe = !1) : Pe === !1 && (T.stop(),
                    T.set({
                        zIndex: y,
                        ...Yi,
                        opacity: 0
                    }),
                    Pe = !0),
                P.current = {
                    wasCurrent: !!n,
                    wasPrevious: !!r,
                    wasBeingRemoved: !1,
                    wasReset: Pe,
                    origins: et
                }
        }
            , [n, r, $]);
    let N = v ? {
        type: !1
    } : "velocity" in d ? {
        ...d,
        velocity: 0
    } : d
        , U = v ? {
            type: !1
        } : p || d
        , j = {
            ...m
        };
    (j.left === void 0 || j.right === void 0) && (j.width = "auto"),
        (j.top === void 0 || j.bottom === void 0) && (j.height = "auto");
    let te = (D1(s) || D1(g)) && (t || n || r) ? 1200 : void 0
        , Y = {
            ...Yi,
            ...P.current.origins
        }
        , ne = t ? {
            initial: {
                ...Y,
                ...g
            },
            animate: {
                ...Y,
                ...s,
                transition: N
            },
            exit: {
                ...Y,
                ...b,
                transition: d
            }
        } : {
            animate: T,
            exit: {
                ...Y,
                ...b,
                transition: U
            }
        }
        , G = !($ || w === !1)
        , he = !!n && G;
    return ge(Ba, {
        "data-framer-component-type": "NavigationContainerWrapper",
        width: "100%",
        height: "100%",
        style: {
            position: "absolute",
            transformStyle: "flat",
            backgroundColor: "transparent",
            overflow: "hidden",
            zIndex: t || $ || n && h ? y : void 0,
            pointerEvents: void 0,
            visibility: o ? "visible" : "hidden",
            perspective: te
        },
        children: [t && k(Ba, {
            width: "100%",
            height: "100%",
            "data-framer-component-type": "NavigationContainerBackdrop",
            transition: d,
            initial: {
                opacity: v && o ? 1 : 0
            },
            animate: {
                opacity: 1
            },
            exit: {
                opacity: 0
            },
            backgroundColor: l || "transparent",
            onTap: $ ? void 0 : c
        }), k(Ba, {
            ...j,
            ...ne,
            transition: {
                default: N,
                originX: {
                    type: !1
                },
                originY: {
                    type: !1
                },
                originZ: {
                    type: !1
                }
            },
            backgroundColor: "transparent",
            backfaceVisible: $ ? f : u,
            "data-framer-component-type": "NavigationContainer",
            "data-framer-is-current-navigation-target": !!n,
            style: {
                pointerEvents: void 0,
                opacity: n && S || t || n && h ? 1 : 0
            },
            "data-is-present": G ? void 0 : !1,
            ref: B,
            children: k(_3.Provider, {
                value: B,
                children: k(H3.Provider, {
                    value: he,
                    children: k(G3, {
                        isCurrent: he,
                        isOverlayed: i,
                        children: k(j3, {
                            isLead: n,
                            animatesLayout: !!h,
                            transition: N,
                            isExiting: !G,
                            isOverlayed: i,
                            id: C,
                            children: a
                        })
                    })
                })
            })
        })]
    })
}, q3);
function q3(e, t) {
    return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed)
}
function A1(e, t, n) {
    let r = {
        ...e
    };
    return t && (re(t.originX) && (r.originX = t.originX),
        re(t.originY) && (r.originY = t.originY),
        re(t.originZ) && (r.originZ = t.originZ)),
        n && (re(n.originX) && (r.originX = n.originX),
            re(n.originY) && (r.originY = n.originY),
            re(n.originZ) && (r.originZ = n.originZ)),
        r
}
function D1(e) {
    var t, n, r;
    if (!e || !("rotateX" in e || "rotateY" in e || "z" in e))
        return !1;
    let o = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0
        , s = ((t = e?.transition) == null ? void 0 : t.rotateX.from) !== 0 || ((n = e?.transition) == null ? void 0 : n.rotateY.from) !== 0 || ((r = e?.transition) == null ? void 0 : r.z.from) !== 0;
    return o || s
}
var Yi = {
    x: 0,
    y: 0,
    z: 0,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    skew: 0,
    skewX: 0,
    skewY: 0,
    originX: .5,
    originY: .5,
    originZ: 0,
    opacity: 1
}
    , X3 = class {
        constructor() {
            E(this, "warning", () => {
                ja("The Navigator API is only available inside of Framer: https://www.framer.com/")
            }
            ),
                E(this, "goBack", () => this.warning()),
                E(this, "instant", () => this.warning()),
                E(this, "fade", () => this.warning()),
                E(this, "push", () => this.warning()),
                E(this, "modal", () => this.warning()),
                E(this, "overlay", () => this.warning()),
                E(this, "flip", () => this.warning()),
                E(this, "customTransition", () => this.warning()),
                E(this, "magicMotion", () => this.warning())
        }
    }
    , Y3 = new X3
    , K3 = be(Y3)
    , gt = {
        Fade: {
            exit: {
                opacity: 0
            },
            enter: {
                opacity: 0
            }
        },
        PushLeft: {
            exit: {
                x: "-30%"
            },
            enter: {
                x: "100%"
            }
        },
        PushRight: {
            exit: {
                x: "30%"
            },
            enter: {
                x: "-100%"
            }
        },
        PushUp: {
            exit: {
                y: "-30%"
            },
            enter: {
                y: "100%"
            }
        },
        PushDown: {
            exit: {
                y: "30%"
            },
            enter: {
                y: "-100%"
            }
        },
        Instant: {
            animation: {
                type: !1
            },
            enter: {
                opacity: 0
            }
        },
        Modal: {
            overCurrentContext: !0,
            goBackOnTapOutside: !0,
            position: {
                center: !0
            },
            enter: {
                opacity: 0,
                scale: 1.2
            }
        },
        OverlayLeft: {
            overCurrentContext: !0,
            goBackOnTapOutside: !0,
            position: {
                right: 0,
                top: 0,
                bottom: 0
            },
            enter: {
                x: "100%"
            }
        },
        OverlayRight: {
            overCurrentContext: !0,
            goBackOnTapOutside: !0,
            position: {
                left: 0,
                top: 0,
                bottom: 0
            },
            enter: {
                x: "-100%"
            }
        },
        OverlayUp: {
            overCurrentContext: !0,
            goBackOnTapOutside: !0,
            position: {
                bottom: 0,
                left: 0,
                right: 0
            },
            enter: {
                y: "100%"
            }
        },
        OverlayDown: {
            overCurrentContext: !0,
            goBackOnTapOutside: !0,
            position: {
                top: 0,
                left: 0,
                right: 0
            },
            enter: {
                y: "-100%"
            }
        },
        FlipLeft: {
            backfaceVisible: !1,
            exit: {
                rotateY: -180
            },
            enter: {
                rotateY: 180
            }
        },
        FlipRight: {
            backfaceVisible: !1,
            exit: {
                rotateY: 180
            },
            enter: {
                rotateY: -180
            }
        },
        FlipUp: {
            backfaceVisible: !1,
            exit: {
                rotateX: 180
            },
            enter: {
                rotateX: -180
            }
        },
        FlipDown: {
            backfaceVisible: !1,
            exit: {
                rotateX: -180
            },
            enter: {
                rotateX: 180
            }
        },
        MagicMotion: {
            withMagicMotion: !0
        }
    };
function Q3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "right") {
        case "right":
            return gt.PushLeft;
        case "left":
            return gt.PushRight;
        case "bottom":
            return gt.PushUp;
        case "top":
            return gt.PushDown
    }
}
function Z3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "bottom") {
        case "right":
            return gt.OverlayLeft;
        case "left":
            return gt.OverlayRight;
        case "bottom":
            return gt.OverlayUp;
        case "top":
            return gt.OverlayDown
    }
}
function J3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "bottom") {
        case "right":
            return gt.FlipLeft;
        case "left":
            return gt.FlipRight;
        case "bottom":
            return gt.FlipUp;
        case "top":
            return gt.FlipDown
    }
}
var ez = () => ({
    current: -1,
    previous: -1,
    currentOverlay: -1,
    previousOverlay: -1,
    visualIndex: 0,
    overlayItemId: 0,
    historyItemId: 0,
    history: [],
    overlayStack: [],
    containers: {},
    containerIndex: {},
    containerVisualIndex: {},
    containerIsRemoved: {},
    transitionForContainer: {},
    previousTransition: null
});
function z1(e, t) {
    switch (t.type) {
        case "addOverlay":
            return nz(e, t.transition, t.component);
        case "removeOverlay":
            return rz(e);
        case "add":
            return AC(e, t.key, t.transition, t.component);
        case "remove":
            return DC(e);
        case "update":
            return tz(e, t.key, t.component);
        case "back":
            return iz(e);
        case "forward":
            return oz(e);
        default:
            return
    }
}
function tz(e, t, n) {
    return {
        ...e,
        containers: {
            ...e.containers,
            [t]: n
        }
    }
}
function nz(e, t, n) {
    let r = e.overlayStack[e.currentOverlay];
    if (r && r.component === n)
        return;
    let i = e.overlayItemId + 1
        , o = [...e.overlayStack, {
            key: `stack-${i}`,
            component: n,
            transition: t
        }];
    return {
        ...e,
        overlayStack: o,
        overlayItemId: i,
        currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, o.length - 1)),
        previousOverlay: e.currentOverlay
    }
}
function rz(e) {
    return {
        ...e,
        overlayStack: [],
        currentOverlay: -1,
        previousOverlay: e.currentOverlay
    }
}
function AC(e, t, n, r) {
    e.containers[t] || (e.containers[t] = r),
        e.history = e.history.slice(0, e.current + 1),
        e.visualIndex = Math.max(e.history.length, 0);
    let i = e.history[e.history.length - 1]
        , o = i && i.key === t;
    if (e.overlayStack = [],
        o && e.currentOverlay > -1)
        return {
            ...e,
            currentOverlay: -1,
            previousOverlay: e.currentOverlay
        };
    if (o)
        return;
    let s = e.containerVisualIndex[t]
        , a = e.containerIsRemoved[t]
        , l = i?.key && n.withMagicMotion ? cz(t, s, a, e.history) : !0;
    e.history.push({
        key: t,
        transition: n,
        visualIndex: l ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t]
    });
    let c = e.current + 1
        , u = e.current;
    for (let v in e.containerIndex)
        e.containerIndex[v] === c && (e.containerIndex[v] = lz(v, e.history));
    e.containerIndex[t] = c;
    let { containerVisualIndex: f, containerIsRemoved: d } = sz(e, t, l)
        , p = zC(c, u, e.history, e.containerIndex, e.transitionForContainer);
    return {
        ...e,
        current: c,
        previous: u,
        containerVisualIndex: f,
        containerIsRemoved: d,
        transitionForContainer: p,
        previousTransition: null,
        currentOverlay: -1,
        historyItemId: e.historyItemId + 1,
        previousOverlay: e.currentOverlay
    }
}
function iz(e) {
    let t = {
        ...e.containers
    }
        , n = DC(e);
    if (n)
        return n.containers = t,
            n
}
function oz(e) {
    let t = e.history[e.current + 1];
    if (!t)
        return;
    let { key: n, transition: r, component: i } = t
        , o = [...e.history]
        , s = AC(e, n, r, i);
    if (s)
        return s.history = o,
            s
}
function DC(e) {
    let t = [...e.history.slice(0, e.current + 1)];
    if (t.length === 1)
        return;
    let n = t.pop();
    if (!n)
        return;
    let r = t[t.length - 1];
    A(r, "The navigation history must have at least one component"),
        e.containerIndex[r.key] = t.length - 1,
        t.every(d => d.key !== n.key) && delete e.containers[n.key];
    let o = e.current - 1
        , s = e.current
        , { containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u } = az(e, r, n)
        , f = zC(o, s, e.history, e.containerIndex, e.transitionForContainer);
    return {
        ...e,
        current: o,
        previous: s,
        containerIsRemoved: a,
        containerVisualIndex: l,
        previousTransition: c,
        visualIndex: u,
        transitionForContainer: f
    }
}
function sz(e, t, n) {
    let r = {
        containerVisualIndex: {
            ...e.containerVisualIndex
        },
        containerIsRemoved: {
            ...e.containerIsRemoved
        }
    };
    if (n)
        r.containerVisualIndex[t] = e.history.length - 1,
            r.containerIsRemoved[t] = !1;
    else {
        let i = e.containerVisualIndex[t];
        for (let [o, s] of Object.entries(e.containerVisualIndex))
            i !== void 0 && s > i && (r.containerIsRemoved[o] = !0)
    }
    return r
}
function az(e, t, n) {
    let r = [t.key, n.key]
        , i = e.history[e.history.length - 2]
        , o = e.previousTransition === null ? null : {
            ...e.previousTransition
        }
        , s = {
            containerIsRemoved: {
                ...e.containerIsRemoved
            },
            containerVisualIndex: {
                ...e.containerVisualIndex
            },
            previousTransition: o,
            visualIndex: e.visualIndex
        };
    i && r.push(i.key);
    let a = e.containerVisualIndex[t.key]
        , l = e.containerVisualIndex[n.key]
        , c = a !== void 0 && l !== void 0 && a <= l || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1
        , u = t.visualIndex;
    return c ? (s.containerIsRemoved[n.key] = !0,
        s.containerVisualIndex[t.key] = u !== void 0 ? u : e.history.length - 1) : (s.visualIndex = e.visualIndex + 1,
            s.containerVisualIndex[t.key] = e.visualIndex + 1),
        n.transition.withMagicMotion && (s.previousTransition = n.transition || null),
        e.containerIsRemoved[t.key] = !1,
        s
}
function lz(e, t) {
    var n;
    for (let r = t.length; r > t.length; r--)
        if (((n = t[r]) == null ? void 0 : n.key) === e)
            return r;
    return -1
}
function zC(e, t, n, r, i) {
    let o = {
        ...i
    };
    for (let [s, a] of Object.entries(r)) {
        let l = uz(a, {
            current: e,
            previous: t,
            history: n
        });
        l && (o[s] = l)
    }
    return o
}
function cz(e, t, n, r) {
    return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(s => s.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(s => s.key === e) > -1)
}
function uz(e, t) {
    let { current: n, previous: r, history: i } = t;
    if (!(e !== n && e !== r)) {
        if (e === n && n > r) {
            let o = i[e];
            return hu("enter", o?.transition.enter, o?.transition.animation)
        }
        if (e === r && n > r) {
            let o = i[e + 1];
            return hu("exit", o?.transition.exit, o?.transition.animation)
        }
        if (e === n && n < r) {
            let o = i[e + 1];
            return hu("enter", o?.transition.exit, o?.transition.animation)
        }
        if (e === r && n < r) {
            let o = i[e];
            return hu("exit", o?.transition.enter, o?.transition.animation)
        }
    }
}
var fz = eo(Yi);
function hu(e, t, n) {
    let r = {}
        , i = {};
    return fz.forEach(o => {
        r[o] = Yi[o],
            i[o] = {
                ...n,
                from: Yi[o]
            }
    }
    ),
        t && Object.keys(t).forEach(o => {
            if (t[o] === void 0)
                return;
            let s = t[o]
                , a = typeof t[o] == "string" ? `${Ne(Yi)[o]}%` : Ne(Yi)[o];
            Ne(r)[o] = e === "enter" ? a : s,
                i[o] = {
                    ...n,
                    from: e === "enter" ? s : a,
                    velocity: 0
                }
        }
        ),
    {
        ...r,
        transition: {
            ...i
        }
    }
}
var dz = x.createContext(void 0);
var BC = x.createContext(void 0)
    , hz = (() => {
        var e, t, n, r, i, o, s, a, l;
        return t = class extends ke {
            constructor(c) {
                var u;
                super(c),
                    tn(this, n),
                    tn(this, i),
                    tn(this, a),
                    tn(this, e, null),
                    E(this, "state", ez()),
                    tn(this, s, b => {
                        if (!this.props.enabled && this.state.history.length > 0)
                            return;
                        let m = z1(this.state, b);
                        if (!m)
                            return;
                        let { skipLayoutAnimation: h } = this.props
                            , y = m.history[m.current]
                            , w = b.type === "add" && b.transition.withMagicMotion || b.type === "forward" && y?.transition.withMagicMotion || b.type === "remove" && !!m.previousTransition
                            , C = () => {
                                var S;
                                this.setState(m),
                                    y?.key && ((S = this.context) == null || S.call(this, y.key))
                            }
                            ;
                        h && !w ? h(C) : C()
                    }
                    ),
                    E(this, "goBack", () => {
                        var b;
                        if (!Wt(this, i, o).call(this))
                            return cf(this, e, ((b = globalThis.event) == null ? void 0 : b.timeStamp) || null),
                                this.state.currentOverlay !== -1 ? me(this, s).call(this, {
                                    type: "removeOverlay"
                                }) : me(this, s).call(this, {
                                    type: "remove"
                                })
                    }
                    );
                let f = this.props.children;
                if (!f || !Da(f) || !Aa(f))
                    return;
                let d = {
                    ...gt.Instant
                }
                    , v = {
                        type: "add",
                        key: ((u = f.key) == null ? void 0 : u.toString()) || `stack-${this.state.historyItemId + 1}`,
                        transition: d,
                        component: f
                    }
                    , g = z1(this.state, v);
                g && (this.state = g)
            }
            componentDidMount() {
                var c;
                let u = this.state.history[this.state.current];
                u && ((c = this.context) == null || c.call(this, u.key))
            }
            UNSAFE_componentWillReceiveProps(c) {
                var u;
                let f = c.children;
                if (!Da(f) || !Aa(f))
                    return;
                let d = (u = f.key) == null ? void 0 : u.toString();
                d && (this.state.history.length === 0 ? Wt(this, a, l).call(this, f, gt.Instant) : me(this, s).call(this, {
                    type: "update",
                    key: d,
                    component: f
                }))
            }
            componentWillUnmount() {
                var c, u;
                (u = (c = this.props).resetProjection) == null || u.call(c)
            }
            instant(c) {
                Wt(this, a, l).call(this, c, gt.Instant, void 0)
            }
            fade(c, u) {
                Wt(this, a, l).call(this, c, gt.Fade, u)
            }
            push(c, u) {
                Wt(this, a, l).call(this, c, Q3(u), u)
            }
            modal(c, u) {
                Wt(this, a, l).call(this, c, gt.Modal, u)
            }
            overlay(c, u) {
                Wt(this, a, l).call(this, c, Z3(u), u)
            }
            flip(c, u) {
                Wt(this, a, l).call(this, c, J3(u), u)
            }
            magicMotion(c, u) {
                Wt(this, a, l).call(this, c, gt.MagicMotion, u)
            }
            customTransition(c, u) {
                Wt(this, a, l).call(this, c, u)
            }
            render() {
                var c, u, f, d, p;
                let v = Wt(this, n, r).call(this, {
                    overCurrentContext: !1
                })
                    , g = Wt(this, n, r).call(this, {
                        overCurrentContext: !0
                    })
                    , b = pz(g)
                    , m = g.current > -1
                    , h = this.state.history.length === 1
                    , y = [];
                for (let [C, S] of Object.entries(this.state.containers)) {
                    let T = this.state.containerIndex[C];
                    A(T !== void 0, "Container's index must be registered");
                    let R = this.state.containerVisualIndex[C];
                    A(R !== void 0, "Container's visual index must be registered");
                    let F = this.state.containerIsRemoved[C]
                        , P = this.state.history[T]
                        , B = this.state.transitionForContainer[C]
                        , $ = T === this.state.current
                        , N = T === this.state.previous
                        , U = $ ? !1 : F
                        , j = ((c = P?.transition) == null ? void 0 : c.withMagicMotion) || $ && !!this.state.previousTransition;
                    y.push(k(vm, {
                        id: C,
                        index: R,
                        isInitial: h,
                        isCurrent: $,
                        isPrevious: N,
                        isOverlayed: m,
                        visible: $ || N,
                        position: (u = P?.transition) == null ? void 0 : u.position,
                        instant: $1(T, v),
                        transitionProps: B,
                        animation: B1(T, v),
                        backfaceVisible: wz(T, v),
                        exitAnimation: (f = P?.transition) == null ? void 0 : f.animation,
                        exitBackfaceVisible: (d = P?.transition) == null ? void 0 : d.backfaceVisible,
                        exitProps: (p = P?.transition) == null ? void 0 : p.enter,
                        withMagicMotion: j,
                        areMagicMotionLayersPresent: U ? !1 : void 0,
                        children: k(C3, {
                            children: N1({
                                component: S,
                                transition: P?.transition
                            })
                        })
                    }, C))
                }
                let w = this.state.overlayStack.map((C, S) => k(vm, {
                    isLayeredContainer: !0,
                    isCurrent: S === this.state.currentOverlay,
                    position: C.transition.position,
                    initialProps: xz(S, g),
                    transitionProps: Sz(S, g),
                    instant: $1(S, g, !0),
                    animation: B1(S, g),
                    exitProps: C.transition.enter,
                    visible: kz(S, g),
                    backdropColor: yz(C.transition),
                    backfaceVisible: bz(S, g),
                    onTapBackdrop: Cz(C.transition, this.goBack),
                    index: this.state.current + 1 + S,
                    children: N1({
                        component: C.component,
                        transition: C.transition
                    })
                }, C.key));
                return k(Ba, {
                    "data-framer-component-type": "NavigationRoot",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    position: "relative",
                    style: {
                        overflow: "hidden",
                        backgroundColor: "unset",
                        pointerEvents: void 0,
                        ...this.props.style
                    },
                    children: k(K3.Provider, {
                        value: this,
                        children: ge(BC.Provider, {
                            value: h,
                            children: [k(vm, {
                                isLayeredContainer: !0,
                                position: void 0,
                                initialProps: {},
                                instant: !1,
                                transitionProps: mz(b),
                                animation: gz(b),
                                backfaceVisible: vz(b),
                                visible: !0,
                                backdropColor: void 0,
                                onTapBackdrop: void 0,
                                index: 0,
                                children: k(MV, {
                                    children: k(S3, {
                                        children: k($d, {
                                            presenceAffectsLayout: !1,
                                            children: y
                                        })
                                    })
                                })
                            }), k($d, {
                                children: w
                            })]
                        })
                    })
                })
            }
        }
            ,
            e = new WeakMap,
            n = new WeakSet,
            r = function (c) {
                let { current: u, previous: f, currentOverlay: d, previousOverlay: p } = this.state;
                return c.overCurrentContext ? {
                    current: d,
                    previous: p,
                    history: this.state.overlayStack
                } : {
                    current: u,
                    previous: f,
                    history: this.state.history
                }
            }
            ,
            i = new WeakSet,
            o = function () {
                return globalThis.event ? me(this, e) === globalThis.event.timeStamp : !1
            }
            ,
            s = new WeakMap,
            a = new WeakSet,
            l = function (c, u, f) {
                var d, p;
                if (Wt(this, i, o).call(this) || (cf(this, e, ((d = globalThis.event) == null ? void 0 : d.timeStamp) || null),
                    !c || !Da(c) || !Aa(c)))
                    return;
                let v = {
                    ...u,
                    ...f
                };
                if (!!v.overCurrentContext)
                    return me(this, s).call(this, {
                        type: "addOverlay",
                        transition: v,
                        component: c
                    });
                let b = ((p = c.key) == null ? void 0 : p.toString()) || `stack-${this.state.historyItemId + 1}`;
                me(this, s).call(this, {
                    type: "add",
                    key: b,
                    transition: v,
                    component: c
                })
            }
            ,
            E(t, "defaultProps", {
                enabled: !0
            }),
            E(t, "contextType", dz),
            t
    }
    )()
    , $C = {
        stiffness: 500,
        damping: 50,
        restDelta: 1,
        type: "spring"
    };
function pz(e) {
    let t, n;
    return e.current !== -1 ? t = e.history[e.current] : n = e.history[e.previous],
    {
        currentOverlayItem: t,
        previousOverlayItem: n
    }
}
function mz({ currentOverlayItem: e }) {
    return e && e.transition.exit
}
function gz({ currentOverlayItem: e, previousOverlayItem: t }) {
    return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : $C
}
function vz({ currentOverlayItem: e, previousOverlayItem: t }) {
    return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible
}
function yz(e) {
    if (e.backdropColor)
        return e.backdropColor;
    if (e.overCurrentContext)
        return "rgba(4,4,15,.4)"
}
function bz(e, t) {
    let { current: n, history: r } = t;
    if (e === n) {
        let i = r[e];
        return i && i.transition ? i.transition.backfaceVisible : !0
    } else if (e < n) {
        let i = r[e + 1];
        return i && i.transition ? i.transition.backfaceVisible : !0
    } else {
        let i = r[e];
        return i && i.transition ? i.transition.backfaceVisible : !0
    }
}
function xz(e, t) {
    let n = t.history[e];
    if (n)
        return n.transition.enter
}
function wz(e, t) {
    var n, r, i, o;
    let { current: s, previous: a, history: l } = t;
    return e === a && s > a || e === s && s < a ? (r = (n = l[e + 1]) == null ? void 0 : n.transition) == null ? void 0 : r.backfaceVisible : (o = (i = l[e]) == null ? void 0 : i.transition) == null ? void 0 : o.backfaceVisible
}
function Sz(e, t) {
    let { current: n, history: r } = t;
    if (e !== n)
        if (e < n) {
            let i = r[e + 1];
            if (i && i.transition)
                return i.transition.exit
        } else {
            let i = r[e];
            if (i && i.transition)
                return i.transition.enter
        }
}
function B1(e, t) {
    let { current: n, previous: r, history: i } = t
        , o = r > n ? r : n;
    if (e < o) {
        let s = i[e + 1];
        if (s && s.transition.animation)
            return s.transition.animation
    } else if (e !== o) {
        let s = i[e];
        if (s && s.transition.animation)
            return s.transition.animation
    } else {
        let s = i[e];
        if (s?.transition.animation)
            return s.transition.animation
    }
    return $C
}
function $1(e, t, n) {
    let { current: r, previous: i, history: o } = t;
    return !!(n && o.length > 1 || e !== i && e !== r || r === i)
}
function kz(e, t) {
    let { current: n, previous: r } = t;
    return e > n && e > r ? !1 : e === n
}
function N1(e) {
    return x.Children.map(e.component, n => {
        var r;
        if (!Da(n) || !Aa(n) || !n.props)
            return n;
        let i = {
            style: n.props.style ?? {}
        }
            , o = (r = e?.transition) == null ? void 0 : r.position
            , s = !o || o.left !== void 0 && o.right !== void 0
            , a = !o || o.top !== void 0 && o.bottom !== void 0
            , l = "style" in n.props ? Se(n.props.style) : !0;
        return s && ("width" in n.props && (i.width = "100%"),
            l && (i.style.width = "100%")),
            a && ("height" in n.props && (i.height = "100%"),
                l && (i.style.height = "100%")),
            x.cloneElement(n, i)
    }
    )
}
function Cz(e, t) {
    if (e.goBackOnTapOutside !== !1)
        return t
}
function Tz(e) {
    let t = kb()
        , n = Gd();
    return x.useInsertionEffect(() => {
        Xa()
    }
        , []),
        k(hz, {
            ...e,
            resetProjection: t,
            skipLayoutAnimation: n,
            children: e.children
        })
}
var lW = yr(Gu(), 1);
var hW = yr(Km(), 1);
function Rz(e, t) {
    let n, r = (...o) => {
        it.clearTimeout(n),
            n = it.setTimeout(e, t, ...o)
    }
        , i = () => {
            it.clearTimeout(n)
        }
        ;
    return r.cancel = i,
        r
}
function NC(e) {
    let { paddingPerSide: t, paddingTop: n, paddingBottom: r, paddingLeft: i, paddingRight: o } = e;
    return t !== !1 && (n !== void 0 || r !== void 0 || i !== void 0 || o !== void 0)
}
function Ez(e) {
    let { padding: t = 0, paddingTop: n, paddingBottom: r, paddingLeft: i, paddingRight: o } = e;
    return NC(e) ? {
        top: n !== void 0 ? n : t,
        bottom: r !== void 0 ? r : t,
        left: i !== void 0 ? i : t,
        right: o !== void 0 ? o : t
    } : {
        top: t,
        bottom: t,
        left: t,
        right: t
    }
}
function Fz({ top: e, left: t, bottom: n, right: r }) {
    return e === r && r === n && n === t ? `${e}px` : `${e}px ${r}px ${n}px ${t}px`
}
function j1(e, t) {
    e && (e.style.display = "none",
        e.offsetHeight,
        e.style.display = t)
}
var Pz = (() => !!(vC() && _D() < 15.4))();
function _z(e, t, n) {
    if (!Pz)
        return;
    let r = x.useRef(!0)
        , i = x.useRef(!1)
        , o = x.useRef(e);
    return i.current = !1,
        x.useLayoutEffect(() => {
            if (o.current = e,
                r.current) {
                r.current = !1;
                return
            }
            i.current || (j1(t.current, n),
                i.current = !0)
        }
            , [e, t, o, n]),
        x.useCallback(() => {
            o.current !== e && (i.current || j1(t.current, n),
                i.current = !0)
        }
            , [e, t])
}
var bW = (() => {
    let e = x.forwardRef(function (n, r) {
        let { as: i = "div", direction: o = "vertical", distribution: s = "start", alignment: a = "center", gap: l = 10, wrap: c = !1, useFlexboxGap: u = !0, children: f, style: d, className: p, willChangeTransform: v, __fromCodeComponentNode: g, parentSize: b, __contentWrapperStyle: m, ...h } = n
            , y = !!(u || c)
            , w = x.useRef(null)
            , C = _z(l, w, "flex")
            , S = Mz(o)
            , T = Vz(S)
            , R = W1(s)
            , F = NC(h) || h.padding ? Fz(Ez(h)) : void 0
            , P = {
                ...d
            };
        za.applyWillChange({
            willChangeTransform: v
        }, P, !0),
            g && !us(fg(h)) && (h.width = "100%",
                h.height = "100%",
                h._constraints = {
                    enabled: !0
                });
        let B = fs(n)
            , { children: $, props: N } = bC(h, f)
            , U = h.widthType ?? (h.width === "auto" ? 2 : 0)
            , j = h.heightType ?? (h.height === "auto" ? 2 : 0)
            , ae = Iz($, o, U, j)
            , te = Oz(ae, l, S, R, y, c)
            , Y = lC(te, b ?? 1)
            , ne = {
                "data-framer-component-type": "Stack"
            }
            , G = h.__fromCanvasComponent;
        G && (ne["data-framer-generated"] = !0);
        let he = W1(a)
            , se = {
                display: "flex",
                flexDirection: S,
                flexWrap: c ? "wrap" : "nowrap",
                justifyContent: R,
                alignItems: he,
                alignContent: he,
                padding: F,
                ...m
            }
            , le = HC(l, R, c);
        if (y && le) {
            let q = jC(R);
            (q || o !== "horizontal") && (Ne(se)["--stack-native-column-gap"] = `${l}px`),
                (q || o !== "vertical") && (Ne(se)["--stack-native-row-gap"] = `${l}px`)
        }
        return se.width === void 0 && (se.width = U === 2 ? "min-content" : "100%"),
            se.height === void 0 && (se.height = j === 2 ? "min-content" : "100%"),
            G && (d?.width && (se.width = d?.width),
                d?.height && (se.height = d?.height)),
            k(Ba, {
                as: i,
                background: G ? void 0 : "none",
                ...N,
                layoutId: B,
                ref: Az(r, w),
                ...ne,
                style: P,
                className: p,
                layoutScroll: !0,
                children: k(Ye.div, {
                    "data-framer-stack-content-wrapper": !0,
                    "data-framer-stack-direction-reverse": T,
                    "data-framer-stack-gap-enabled": le,
                    style: se,
                    onBeforeLayoutMeasure: C,
                    children: Y
                })
            })
    });
    return e.defaultProps = {
        distribution: "start"
    },
        e.displayName = "Stack",
        uD(e, {
            direction: {
                type: "segmentedenum",
                options: ["horizontal", "vertical"],
                title: "Direction",
                defaultValue: "vertical"
            },
            distribution: {
                type: "enum",
                options: ["start", "center", "end", "space-between", "space-around", "space-evenly"],
                optionTitles: ["Start", "Center", "End", "Space Between", "Space Around", "Space Evenly"],
                title: "Distribute",
                defaultValue: "space-around"
            },
            alignment: {
                type: "segmentedenum",
                options: ["start", "center", "end"],
                title: "Align",
                defaultValue: "center"
            },
            gap: {
                type: "number",
                min: 0,
                title: "Gap",
                hidden: t => t.distribution !== void 0 && ["space-between", "space-around", "space-evenly"].includes(t.distribution),
                defaultValue: 10
            },
            padding: {
                type: "fusednumber",
                toggleKey: "paddingPerSide",
                toggleTitles: ["Padding", "Padding per side"],
                valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
                valueLabels: ["t", "r", "b", "l"],
                min: 0,
                title: "Padding",
                defaultValue: 0
            }
        }),
        e
}
)();
function H1(e) {
    return typeof e == "string" && e.endsWith("fr")
}
function pu(e) {
    let t = parseFloat(e);
    return re(t) ? t : 0
}
function Iz(e, t, n, r) {
    return x.Children.map(e, i => {
        if (!Da(i) || !Aa(i))
            return;
        let o = t === "vertical"
            , s = {}
            , a = !1
            , { style: l, size: c } = i.props
            , { width: u, height: f } = i.props;
        c !== void 0 && (u === void 0 && (u = c),
            f === void 0 && (f = c));
        let d = u
            , p = f;
        if (H1(u) && (a = !0,
            a = !0,
            o ? n === 2 ? (s.alignSelf = "stretch",
                d = "auto") : d = `${pu(u) * 100}%` : (d = 1,
                    s.flexGrow = pu(u),
                    s.flexBasis = 0),
            s.width = d),
            H1(f) && (a = !0,
                o ? (p = 1,
                    s.flexGrow = pu(f),
                    s.flexBasis = 0) : r === 2 ? (s.alignSelf = "stretch",
                        p = "auto") : p = `${pu(f) * 100}%`,
                s.height = p),
            !a)
            return i;
        let v = {
            ...l,
            ...s
        };
        return x.cloneElement(i, {
            width: d,
            height: p,
            style: v
        })
    }
    )
}
function jC(e) {
    return e ? !["space-between", "space-around", "space-evenly", "stretch"].includes(e) : !1
}
function HC(e, t, n) {
    return !(!e || !n && !jC(t))
}
function Oz(e, t, n, r, i, o) {
    let s = {
        display: "contents"
    }
        , a = HC(t, r, o);
    if (a) {
        let l = Lz(n);
        Ne(s)["--stack-gap-x"] = `${l ? 0 : t}px`,
            Ne(s)["--stack-gap-y"] = `${l ? t : 0}px`
    }
    return k("div", {
        "data-framer-legacy-stack-gap-enabled": a,
        "data-framer-stack-flexbox-gap": i,
        style: s,
        children: e
    })
}
function Mz(e) {
    switch (e) {
        case "vertical":
            return "column";
        case "horizontal":
            return "row";
        default:
            return e
    }
}
function Lz(e) {
    return e === "column" || e === "column-reverse"
}
function Vz(e) {
    switch (e) {
        case "column-reverse":
        case "row-reverse":
            return !0;
        default:
            return !1
    }
}
function W1(e) {
    switch (e) {
        case "start":
            return "flex-start";
        case "end":
            return "flex-end";
        default:
            return e
    }
}
function Az(e, t) {
    return n => {
        t.current = n,
            typeof e == "function" ? e(n) : e && (e.current = n)
    }
}
function no(...e) {
    return e.filter(Boolean).join(" ")
}
var Dz = (() => {
    function e(t = {}) {
        let n = gm(t, !1, !1);
        return e.addData(n),
            n
    }
    return e._stores = [],
        e.addData = t => {
            e._stores.push(t)
        }
        ,
        e.reset = () => {
            e._stores.forEach(t => gm.resetObject(t))
        }
        ,
        e.addObserver = (t, n) => gm.addObserver(t, n),
        e
}
)()
    , ym = Dz;
var zz = {
    update: 0
}
    , Bz = x.createContext({
        update: NaN
    });
var $z = class extends ke {
    constructor() {
        super(...arguments),
            E(this, "observers", []),
            E(this, "state", zz),
            E(this, "taskAdded", !1),
            E(this, "frameTask", () => {
                this.setState({
                    update: this.state.update + 1
                }),
                    this.taskAdded = !1
            }
            ),
            E(this, "observer", () => {
                this.taskAdded || (this.taskAdded = !0,
                    nC.addFrameTask(this.frameTask))
            }
            )
    }
    componentWillUnmount() {
        this.observers.map(e => e()),
            ym.reset()
    }
    render() {
        let { children: e } = this.props;
        return this.observers.map(t => t()),
            this.observers = [],
            ym._stores.forEach(t => {
                let n = ym.addObserver(t, this.observer);
                this.observers.push(n)
            }
            ),
            k(Bz.Provider, {
                value: {
                    ...this.state
                },
                children: e
            })
    }
}
    , $W = yr(Gu(), 1);
var WC = "__framer__"
    , Nz = (() => WC.length)();
function jz(e, t) {
    let n = {}
        , r = {};
    for (let i in e) {
        let o = UC(i);
        if (o && t.has(o)) {
            n[o] = e[i];
            continue
        }
        r[i] = e[i]
    }
    return [n, r]
}
function UC(e) {
    if (e.startsWith(WC))
        return e.substr(Nz)
}
var mr = ["opacity", "x", "y", "scale", "rotate", "rotateX", "rotateY", "skewX", "skewY", "transformPerspective"]
    , Pu = e => ({
        x: Xe(e?.x ?? 0),
        y: Xe(e?.y ?? 0),
        opacity: Xe(e?.opacity ?? 1),
        scale: Xe(e?.scale ?? 1),
        rotate: Xe(e?.rotate ?? 0),
        rotateX: Xe(e?.rotateX ?? 0),
        rotateY: Xe(e?.rotateY ?? 0),
        skewX: Xe(e?.skewX ?? 0),
        skewY: Xe(e?.skewY ?? 0),
        transformPerspective: Xe(e?.transformPerspective ?? 0)
    })
    , rt = {
        x: 0,
        y: 0,
        scale: 1,
        opacity: 1,
        rotate: 0,
        rotateX: 0,
        rotateY: 0,
        skewX: 0,
        skewY: 0,
        transformPerspective: 0
    };
function GC(e) {
    return e in rt
}
function qC(e, t) {
    let n = yt(() => ({
        values: Pu(t ? e : void 0)
    }));
    return x.useEffect(() => {
        if (!t)
            for (let r of mr) {
                let i = rt[r];
                Qe(i) || n.values[r].set(i)
            }
    }
        , [n, t]),
        n
}
var Hz = new Set(["loopEffectEnabled", "loopTransition", "loop", "loopRepeatType", "loopRepeatDelay"])
    , Wz = () => {
        let e = V();
        return H(() => () => {
            clearTimeout(e.current)
        }
            , []),
            async t => new Promise(n => {
                e.current = setTimeout(() => {
                    n(!0)
                }
                    , t * 1e3)
            }
            )
    }
    ;
function Uz({ loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: i }) {
    let o = Fi()
        , s = yt(Pu)
        , a = x.useRef(!1)
        , l = Wz()
        , c = async () => {
            if (!i)
                return;
            let d = n || void 0
                , p = a.current && r === "mirror"
                , v = p ? rt : i
                , g = p ? i : rt;
            return a.current = !a.current,
                Promise.all(mr.map(b => {
                    if (!(o && b !== "opacity"))
                        return s[b].set(g[b] ?? rt[b]),
                            new Promise(m => {
                                let h = {
                                    ...d,
                                    onComplete: () => m()
                                }
                                    , y = v[b] ?? g[b];
                                typeof y == "number" && rr(s[b], y, h)
                            }
                            )
                }
                ))
        }
        , u = async () => {
            e && (await c(),
                await l(t ?? 0),
                await u())
        }
        , f = Q(() => {
            mr.forEach(d => {
                s[d].stop()
            }
            ),
                mr.forEach(d => {
                    s[d].set(rt[d])
                }
                ),
                a.current = !1
        }
            , [s]);
    return x.useEffect(() => (e && i ? u() : f(),
        () => f()), [e]),
        x.useMemo(() => ({
            values: s,
            style: e ? {
                willChange: "transform"
            } : {}
        }), [s, e])
}
function Gz(e, t, n, r, i) {
    let o = n / 100 - 1
        , s = i ? (t - r) * o : 0
        , a = -e * o;
    return s + a
}
var qz = new Set(["speed", "adjustPosition", "offset", "parallaxTransformEnabled"]);
function Xz(e, t, n) {
    let { speed: r = 100, offset: i = 0, adjustPosition: o = !1, parallaxTransformEnabled: s } = e
        , a = x.useRef(null)
        , l = Fi()
        , c = x.useCallback(v => a.current === null || r === 100 ? 0 : Gz(v, a.current, r, i, o), [a, r, i, o])
        , { scrollY: u } = hb()
        , f = Dt(u, c)
        , d = nr(o && a.current === null ? "hidden" : n)
        , p = nr(0);
    return to(t, v => {
        v !== null && (J.read(() => {
            var g;
            a.current = ((g = v.getBoundingClientRect()) == null ? void 0 : g.top) ?? 0
        }
        ),
            J.update(() => {
                f.set(c(u.get())),
                    o && d.set(n ?? "initial")
            }
            ))
    }
        , [o]),
    {
        values: {
            y: l || !s ? p : f
        },
        style: s ? {
            visibility: d,
            willChange: "transform"
        } : void 0
    }
}
function Yz(e) {
    if (!(ye(e) || !Se(e)))
        return e?.transition
}
function bm(e, t, n, r, i, o) {
    let s = Yz(e);
    return Promise.all(mr.map(a => new Promise(l => {
        if (n && a !== "opacity")
            return l();
        let c = t.values[a];
        c.stop();
        let u = Se(e) ? e?.[a] ?? rt[a] : rt[a];
        if (Be(u) && (u = u.get()),
            !De(u))
            return l();
        let f = er.get(r.current);
        f && f.setBaseTarget(a, u);
        let d;
        if (ye(i) && !c?.hasAnimated && it.MotionHandoffAnimation) {
            let p = it.MotionHandoffAnimation(i, a, J);
            p && (d = p)
        }
        o ? c.set(u) : rr(c, u, {
            ...s,
            velocity: 0,
            startTime: d,
            onComplete: () => l()
        })
    }
    )))
}
var Kz = new Set(["presenceInitial", "presenceAnimate", "presenceExit"]);
function Qz({ initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: o }, s, a, l, c) {
    let u = r ?? e
        , f = i ?? t
        , d = o ?? n
        , [p, v] = Ed()
        , g = V({
            lastPresence: !1,
            lastAnimate: f,
            hasMounted: !1,
            running: !1
        })
        , b = yt(() => {
            let h = u ?? l;
            if (!Se(h))
                return {
                    values: Pu()
                };
            let y = {};
            for (let w in h) {
                let C = Se(h) ? h[w] : void 0;
                De(C) && (y[w] = C)
            }
            return {
                values: Pu(y)
            }
        }
        );
    to(s, h => {
        let { hasMounted: y } = g.current;
        if (y && f)
            return;
        let w = er.get(h);
        if (w) {
            Object.assign(g.current, {
                hasMounted: !0
            });
            for (let C in b.values) {
                if (!GC(C))
                    continue;
                let S = l?.[C];
                w.setBaseTarget(C, De(S) ? S : rt[C])
            }
        }
    }
        , [f]);
    let m = Fi();
    return to(s, h => {
        if (!a) {
            v?.();
            return
        }
        if (h === null)
            return;
        if (p !== g.current.lastPresence) {
            Object.assign(g.current, {
                lastPresence: p
            }),
                p ? u && f && (Object.assign(g.current, {
                    running: !0
                }),
                    bm(f, b, m, s, c).then(() => Object.assign(g.current, {
                        running: !1
                    }))) : d ? (Object.assign(g.current, {
                        running: !0
                    }),
                        bm(d, b, m, s, c).then(() => Object.assign(g.current, {
                            running: !1
                        })).then(() => v())) : v();
            return
        }
        let { lastAnimate: y, running: w } = g.current;
        lg(f, y) || !f || (Object.assign(g.current, {
            lastAnimate: f
        }),
            bm(f, b, m, s, c, !w).then(() => Object.assign(g.current, {
                running: !1
            })))
    }
    ),
        b
}
function Zz(e, t) {
    let n = 0
        , r = e;
    for (; r && r !== t && r instanceof HTMLElement;)
        n += r.offsetTop,
            r = r.offsetParent;
    return n
}
var Jz = 1;
function mg(e, t = 0, n) {
    var r;
    let i = []
        , o = [];
    for (let s = e.length; s >= 0; s--) {
        let { ref: a, offset: l } = e[s] ?? {};
        if (!a || !a.current)
            continue;
        let u = Zz(a.current, document.documentElement) - Jz - (l ?? 0) - t
            , f = ((r = a.current) == null ? void 0 : r.clientHeight) ?? 0
            , d = i[i.length - 1]
            , p = Math.max(u + f, 0);
        i.push(u),
            o.unshift(Math.max(u, 0), d === void 0 ? p : Math.min(p, Math.max(d - 1, 0))),
            n?.(s)
    }
    return o
}
function e5(e, t = 0) {
    return e < t ? "up" : "down"
}
var t5 = 4;
function XC(e, t, n = {}) {
    let { direction: r, target: i } = e ?? {}
        , { repeat: o = !0, enabled: s = !0 } = n;
    x.useEffect(() => {
        if (!r || !s)
            return;
        let a, l = 0, c, u;
        return Tr(({ y: f }) => {
            if (!o && u === i || f.current > f.scrollLength || f.current < 0)
                return;
            let d = e5(f.current, a);
            a = f.current;
            let p = d !== c;
            if (c = d,
                p)
                l = f.current;
            else {
                if (Math.abs(f.current - l) < t5)
                    return;
                let g = d === r ? i : void 0;
                g !== u && t(g),
                    u = g
            }
        }
        )
    }
        , [r, o, i, s, t])
}
var n5 = new Set(["threshold", "animateOnce", "opacity", "targetOpacity", "x", "y", "scale", "transition", "rotate", "rotateX", "rotateY", "perspective", "enter", "exit", "animate", "styleAppearEffectEnabled", "targets", "scrollDirection"])
    , r5 = ["animate", "animate"]
    , U1 = {
        inputRange: [],
        outputRange: []
    };
function i5(e, t, n) {
    let r = mg(e, t)
        , i = [...r5]
        , o = r[0];
    if (!De(o))
        return U1;
    if (o > 1 && (r.unshift(0, o - 1),
        i.unshift("initial", "initial")),
        n) {
        let s = r.length - 1
            , a = r[s];
        if (!De(a))
            return U1;
        r.push(a + 1),
            i.push("exit")
    }
    return {
        inputRange: r,
        outputRange: i
    }
}
function xm(e) {
    return {
        x: e?.x ?? rt.x,
        y: e?.y ?? rt.y,
        scale: e?.scale ?? rt.scale,
        opacity: e?.opacity ?? rt.opacity,
        transformPerspective: e?.transformPerspective ?? rt.transformPerspective,
        rotate: e?.rotate ?? rt.rotate,
        rotateX: e?.rotateX ?? rt.rotateX,
        rotateY: e?.rotateY ?? rt.rotateY,
        skewX: e?.skewX ?? rt.skewX,
        skewY: e?.skewY ?? rt.skewY,
        transition: e?.transition ?? void 0
    }
}
function o5({ opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: o, ...s }) {
    return x.useMemo(() => ({
        initial: r ?? xm({
            ...s,
            opacity: e ?? t ?? 1,
            transformPerspective: n
        }),
        animate: o ?? xm({
            opacity: t
        }),
        exit: i ?? xm()
    }), [o, s, r, i, e, t, n])
}
function s5(e, t) {
    let n = Fi()
        , r = o5(e)
        , i = e.styleAppearEffectEnabled
        , o = qC(i ? r.initial : r.animate, i)
        , s = x.useRef({
            isPlaying: !1,
            scheduledAppearState: void 0,
            lastAppearState: !e.styleAppearEffectEnabled
        })
        , a = x.useRef()
        , l = x.useCallback(async ({ transition: d, ...p }, v) => {
            let g = d ?? r.animate.transition ?? e.transition;
            await a.current,
                a.current = Promise.all(mr.map(b => {
                    v && o.values[b].set(r.initial[b] ?? rt[b]);
                    let m = p[b] ?? rt[b]
                        , h = er.get(t.current);
                    return h && typeof m != "object" && h.setBaseTarget(b, m),
                        new Promise(y => {
                            if (n && b !== "opacity")
                                De(m) && o.values[b].set(m),
                                    y();
                            else {
                                let w = {
                                    restDelta: b === "scale" ? .001 : void 0,
                                    ...g,
                                    onComplete: () => y()
                                };
                                typeof m == "number" && rr(o.values[b], m, w)
                            }
                        }
                        )
                }
                ))
        }
            , [])
        , c = e.animateOnce && s.current.lastAppearState === !0
        , u = !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !c;
    OC(t, d => {
        let { isPlaying: p, lastAppearState: v } = s.current;
        if (p) {
            s.current.scheduledAppearState = d;
            return
        }
        s.current.scheduledAppearState = void 0,
            s.current.lastAppearState = d,
            v !== d && l(d ? r.animate : r.exit, d)
    }
        , {
            enabled: u,
            animateOnce: !!e.animateOnce,
            threshold: {
                y: e.threshold
            }
        });
    let f = e.targets && i && !e.scrollDirection;
    return x.useEffect(() => {
        if (!f)
            return;
        let d = {
            initial: !0
        }
            , p = "initial";
        return Tr(({ y: v }) => {
            let { targets: g } = e;
            if (!g || !g[0] || g[0].ref && !g[0].ref.current)
                return;
            let { inputRange: b, outputRange: m } = i5(g, (e.threshold ?? 0) * v.containerLength, !!e.exit);
            if (b.length === 0 || b.length !== m.length)
                return;
            let h = wo(v.current, b, m);
            if (e.animateOnce && d[h] || (d[h] = !0,
                p === h))
                return;
            p = h;
            let y = Ne(r)[h];
            y && l(y)
        }
        )
    }
        , [f]),
        XC(e.scrollDirection, d => l(d ?? r.animate), {
            enabled: i,
            repeat: !e.animateOnce
        }),
        o
}
var a5 = new Set(["transformViewportThreshold", "styleTransformEffectEnabled", "transformTargets", "spring", "transformTrigger"])
    , l5 = (e, t) => {
        var n;
        let r = (n = e?.[0]) == null ? void 0 : n.target;
        return t ? {
            opacity: r?.opacity ?? 1
        } : r
    }
    , YC = () => ({
        opacity: [],
        x: [],
        y: [],
        scale: [],
        rotate: [],
        rotateX: [],
        rotateY: [],
        skewX: [],
        skewY: [],
        transformPerspective: []
    });
function c5(e, t) {
    let n = x.useRef({});
    x.useEffect(() => {
        if (t !== void 0)
            for (let r of eo(e)) {
                let i = e[r];
                i.attach((o, s) => {
                    let a = n.current[r];
                    if (a && a.stop(),
                        n.current[r] = dd({
                            keyframes: [i.get(), o],
                            velocity: i.getVelocity(),
                            ...t,
                            restDelta: .001,
                            onUpdate: s
                        }),
                        !qe.isProcessing) {
                        let l = performance.now() - qe.timestamp;
                        l < 40 && (n.current[r].time = l / 1e3)
                    }
                    return i.get()
                }
                )
            }
    }
        , [JSON.stringify(t)])
}
function u5(e, t) {
    let n = YC();
    return {
        inputRange: mg(e, t, i => {
            var o, s, a;
            let l = (o = e[i - 1]) == null ? void 0 : o.target
                , c = (s = e[i]) == null ? void 0 : s.target;
            for (let u of mr)
                (a = n[u]) == null || a.unshift(l?.[u] ?? 0, c?.[u] ?? 0)
        }
        ),
        effectKeyOutputRange: n
    }
}
function f5(e) {
    var t;
    let n = YC();
    for (let { target: r } of e)
        for (let i of mr)
            (t = n[i]) == null || t.push(r[i]);
    return n
}
var G1 = [0, 1];
function d5({ transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i = 0 }, o) {
    let s = Fi()
        , a = qC(l5(n, s), t)
        , l = !t || !n
        , c = e === "onScrollTarget";
    return ze(() => {
        if (!(l || !c))
            return Tr(({ y: u }) => {
                if (!n[0] || n[0].ref && !n[0].ref.current)
                    return;
                let { inputRange: f, effectKeyOutputRange: d } = u5(n, i * u.containerLength);
                if (f.length !== 0)
                    for (let p of mr)
                        s && p !== "opacity" || f.length === d[p].length && d[p][0] !== void 0 && a.values[p].set(wo(u.current, f, d[p]))
            }
            )
    }
        , [s, c, i, a, n, l]),
        to(o, u => {
            if (l || c || u === null)
                return;
            let f = f5(n);
            return Tr(({ y: d }) => {
                for (let p of mr)
                    s && p !== "opacity" || G1.length === f[p].length && f[p][0] !== void 0 && a.values[p].set(wo(d.progress, G1, f[p]))
            }
                , e === "onInView" ? {
                    target: u ?? void 0,
                    offset: ["start end", "end end"]
                } : void 0)
        }
            , [s, e, c, a, n, l]),
        c5(a.values, r),
        x.useMemo(() => ({
            values: a.values,
            style: t ? {
                willChange: "transform"
            } : {}
        }), [a, t])
}
var KC = {
    parallax: qz,
    styleAppear: n5,
    styleTransform: a5,
    loop: Hz,
    presence: Kz
}
    , h5 = eo(KC);
function q1(e, t, n) {
    return !(e in n) && t in n || n[e] === !0
}
function p5(e) {
    let t = {
        parallax: {},
        styleAppear: {},
        styleTransform: {},
        presence: {
            animate: e.animate,
            initial: e.initial,
            exit: e.exit
        },
        loop: {},
        forwardedProps: {}
    };
    for (let n in e) {
        let r = UC(n);
        if (r)
            for (let i of h5) {
                let o = KC[i];
                if (o?.has(r)) {
                    t[i][r] = Ne(e)[n];
                    break
                }
            }
        else
            t.forwardedProps[n] = Ne(e)[n]
    }
    return t.parallax.parallaxTransformEnabled = q1("parallaxTransformEnabled", "speed", t.parallax),
        t.styleAppear.styleAppearEffectEnabled = q1("styleAppearEffectEnabled", "animateOnce", t.styleAppear),
        t
}
var gi = e => e.reduce((t, n) => t += n, 0)
    , X1 = e => e.reduce((t, n) => t = t * n, 1)
    , m5 = "current";
function g5(e) {
    return Se(e) && m5 in e
}
function v5(e, t) {
    if (!e || !Se(e))
        return t;
    for (let n in e) {
        let r = e[n];
        !Be(r) || !GC(n) || De(r.get()) && t[n].push(r)
    }
}
function Pa(e) {
    return ye(e) || Array.isArray(e)
}
var y5 = e => x.forwardRef((t, n) => {
    var r;
    if (t.__withFX)
        return k(e, {
            ...t,
            animate: void 0,
            initial: void 0,
            exit: void 0,
            ref: n
        });
    if (fe.current() === fe.canvas) {
        let Je = Pa(t.animate) ? t.animate : void 0
            , Re = Pa(t.initial) ? t.initial : void 0;
        return k(e, {
            ...t,
            animate: Je,
            initial: Re,
            exit: void 0,
            ref: n
        })
    }
    let { parallax: i = {}, styleAppear: o = {}, styleTransform: s = {}, presence: a = {}, loop: l = {}, forwardedProps: c } = p5(t)
        , { __targetOpacity: u, __perspectiveFX: f, __smartComponentFX: d = !1 } = t
        , p = nr(u ?? 1)
        , v = hg(n)
        , { values: g } = Qz(a, v, d, t.style, t[_l])
        , { values: b, style: m } = Xz(i, v, (r = t.style) == null ? void 0 : r.visibility)
        , { values: h, style: y } = d5(s, v)
        , { values: w } = s5(o, v)
        , { values: C, style: S } = Uz(l)
        , T = x.useMemo(() => ({
            scale: [w.scale, C.scale, g.scale, h.scale],
            opacity: [w.opacity, C.opacity, g.opacity, p, h.opacity],
            x: [w.x, C.x, g.x, h.x],
            y: [w.y, C.y, b.y, g.y, h.y],
            rotate: [w.rotate, C.rotate, g.rotate, h.rotate],
            rotateX: [w.rotateX, C.rotateX, g.rotateX, h.rotateX],
            rotateY: [w.rotateY, C.rotateY, g.rotateY, h.rotateY],
            skewX: [w.skewX, C.skewX, g.skewX, h.skewX],
            skewY: [w.skewY, C.skewY, g.skewY, h.skewY],
            transformPerspective: [h.transformPerspective, w.transformPerspective]
        }), [p, h, b, w, C, g]);
    v5(t.style, T);
    let R = Dt(T.scale, X1)
        , F = Dt(T.opacity, X1)
        , P = Dt(T.x, gi)
        , B = Dt(T.y, gi)
        , $ = Dt(T.rotate, gi)
        , N = Dt(T.rotateX, gi)
        , U = Dt(T.rotateY, gi)
        , j = Dt(T.skewX, gi)
        , ae = Dt(T.skewY, gi)
        , te = Dt(T.transformPerspective, gi)
        , { drag: Y, dragConstraints: ne } = c;
    BD(Y && g5(ne) ? ne : void 0);
    let G = {
        opacity: F,
        scale: R,
        x: P,
        y: B,
        rotate: $,
        rotateX: N,
        rotateY: U,
        skewX: j,
        skewY: ae
    };
    Qe(f) && (G.transformPerspective = te);
    let he = Pa(t.animate) ? t.animate : void 0
        , se = Pa(t.initial) ? t.initial : void 0
        , le = Pa(t.exit) ? t.exit : void 0
        , q = d && !a.presenceInitial ? {
            initial: se,
            animate: he,
            exit: le
        } : {};
    return k(e, {
        ...c,
        ...q,
        __withFX: !0,
        style: {
            ...t.style,
            ...m,
            ...y,
            ...S,
            ...G
        },
        values: g,
        ref: v
    })
}
);
var ZW = y5;
function tf(e) {
    let t = yt(() => b5(e));
    return t.useSetup(e),
        t.cloneAsElement
}
function b5(e) {
    let t = {
        forwardedRef: e,
        childRef: null,
        ref: null
    };
    t.ref = Y1(t);
    let n = (s, a) => {
        if (!t.forwardedRef && t.forwardedRef === s) {
            t.ref = a;
            return
        }
        let l = !1;
        t.childRef !== a && (t.childRef = a,
            l = !0),
            t.forwardedRef !== s && (t.forwardedRef = s,
                l = !0),
            l && (t.ref = Y1(t))
    }
        , r = !1;
    function i(s, a) {
        if (r)
            throw new ReferenceError("useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle.");
        return r = !0,
            yn.count(s) > 1 && e && (t.forwardedRef = void 0,
                t.ref = t.childRef),
            yn.map(s, l => {
                if (At(l)) {
                    let c = "ref" in l ? l.ref : void 0;
                    n(t.forwardedRef, c);
                    let u = t.ref !== c ? {
                        ...a,
                        ref: t.ref
                    } : a;
                    return xr(l, u)
                }
                return l
            }
            )
    }
    let o = function (a, l) {
        return k(lt, {
            children: i(a, l)
        })
    };
    return o.cloneAsArray = i,
    {
        useSetup: s => {
            r = !1,
                n(s, t.childRef)
        }
        ,
        cloneAsElement: o
    }
}
function Y1(e) {
    if (!e.forwardedRef)
        return e.childRef;
    let { forwardedRef: t, childRef: n } = e;
    return r => {
        L1(n, r),
            L1(t, r)
    }
}
var QC = x.createContext({});
function iU() {
    return x.useContext(QC)
}
var oU = x.forwardRef(function ({ width: t, height: n, y: r, children: i, ...o }, s) {
    let a = x.useMemo(() => ({
        width: t,
        height: n,
        y: r
    }), [t, n, r])
        , l = tf(s);
    return k(QC.Provider, {
        value: a,
        children: l(i, o)
    })
})
    , x5 = e => x.forwardRef((t, n) => {
        let r = fs(t);
        return k(e, {
            layoutId: r,
            ...t,
            layoutIdKey: void 0,
            duplicatedFrom: void 0,
            ref: n
        })
    }
    );
function ZC(e, t) {
    var n;
    if (typeof I > "u" || Math.random() > .01)
        return;
    let r = e instanceof Error && typeof e.stack == "string" ? e.stack : null
        , i = t?.componentStack;
    (n = it.__framer_events) == null || n.push(["published_site_load_recoverable_error", {
        message: String(e),
        stack: r,
        componentStack: r ? void 0 : i
    }])
}
function w5(...e) {
    console.error(...e)
}
function S5() {
    return fe.current() !== fe.canvas
}
function k5({ errorMessage: e, fallback: t, children: n }) {
    return S5() ? k(C5, {
        fallback: t,
        errorMessage: e,
        children: k(T5, {
            fallback: t,
            children: n
        })
    }) : n
}
var C5 = class extends ke {
    constructor() {
        super(...arguments),
            E(this, "state", {
                hasError: !1
            })
    }
    static getDerivedStateFromError() {
        return {
            hasError: !0
        }
    }
    componentDidCatch(e, t) {
        w5(this.props.errorMessage, t?.componentStack),
            ZC(e, t)
    }
    render() {
        let { children: e, fallback: t = null } = this.props
            , { hasError: n } = this.state;
        return n ? t : e
    }
}
    ;
function T5({ children: e, fallback: t = null }) {
    return typeof I > "u" ? k(br, {
        fallback: t,
        children: e
    }) : k(eg, {
        children: e
    })
}
var R5 = class extends ke {
    constructor() {
        super(...arguments),
            E(this, "state", {
                hasError: !1
            })
    }
    componentDidCatch(e, t) {
        let n = t?.componentStack;
        console.error("Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.", n),
            this.setState({
                hasError: !0
            }),
            ZC(e, t)
    }
    render() {
        let { children: e } = this.props
            , { hasError: t } = this.state;
        return t ? null : e
    }
}
    , E5 = "code-crash:";
function F5(e, t) {
    return `${E5}${e}:${t}`
}
function P5(e, t) {
    return _5("component", e, t)
}
function _5(e, t, n) {
    return `A code ${e} crashed while rendering due to the error above. To find and fix it, open the project in the editor \u2192 open Quick Actions (press Cmd+K or Ctrl+K) \u2192 paste this: ${F5(t, n)} \u2192 click \u201CShow Layer\u201D.`
}
var Bm = (() => x.createContext(0))();
function I5() {
    return x.useContext(Bm)
}
function O5({ children: e }) {
    let t = x.useContext(Bm);
    return k(Bm.Provider, {
        value: t + 1,
        children: e
    })
}
function M5(e, t, n, r) {
    return (t || n) && (e === 0 || e === 1 && r)
}
var L5 = x.forwardRef(({ children: e, layoutId: t, as: n, scopeId: r, nodeId: i, isAuthoredByUser: o, isModuleExternal: s, inComponentSlot: a, ...l }, c) => {
    let u = yt(() => t ? `${t}-container` : void 0)
        , f = Ya(n)
        , d = x.Children.map(e, v => x.isValidElement(v) ? x.cloneElement(v, {
            layoutId: t
        }) : v)
        , p = V5(d, r, i, o, s, a);
    return k(f, {
        layoutId: u,
        ...l,
        ref: c,
        children: k(ds.Provider, {
            value: !0,
            children: k(VV, {
                enabled: !1,
                children: k(sb, {
                    id: t ?? "",
                    inherit: "id",
                    children: p
                })
            })
        })
    })
}
)
    , mU = x5(L5);
function V5(e, t, n, r, i, o) {
    let s = I5();
    return Qe(t) || Qe(n) ? k(R5, {
        children: e
    }) : (M5(s, r ?? !1, i ?? !1, o ?? !1) && (e = k(k5, {
        errorMessage: P5(t, n),
        fallback: null,
        children: e
    })),
        i && (e = k(O5, {
            children: e
        })),
        e)
}
var A5 = x.createContext(void 0)
    , D5 = "style[data-framer-css-ssr-minified]"
    , z5 = (() => {
        var e;
        if (!Gn())
            return new Set;
        let t = (e = document.querySelector(D5)) == null ? void 0 : e.getAttribute("data-framer-components");
        return t ? new Set(t.split(" ")) : new Set
    }
    )()
    , B5 = "data-framer-css-ssr"
    , nf = (e, t, n) => x.forwardRef((r, i) => {
        let { sheet: o, cache: s } = x.useContext(A5) ?? {};
        if (!Gn()) {
            Un(t) && (t = t(fe.current()));
            let a = Array.isArray(t) ? t.join(`
`) : t;
            return ge(lt, {
                children: [k("style", {
                    [B5]: !0,
                    "data-framer-component": n,
                    dangerouslySetInnerHTML: {
                        __html: a
                    }
                }), k(e, {
                    ...r,
                    ref: i
                })]
            })
        }
        return x.useInsertionEffect(() => {
            if (n && z5.has(n))
                return;
            (Un(t) ? t(fe.current()) : Array.isArray(t) ? t : t.split(`
`)).forEach(l => l && uC(l, o, s))
        }
            , []),
            k(e, {
                ...r,
                ref: i
            })
    }
    )
    , gg = be({
        onRegisterCursors: () => () => { }
        ,
        registerCursors: () => { }
    })
    , _u = "framer-cursor-none"
    , $m = "framer-pointer-events-none"
    , $5 = ol(function ({ children: t }) {
        let n = yt(() => {
            let i = new Set
                , o = {};
            return {
                onRegisterCursors: s => (s(o),
                    i.add(s),
                    () => i.delete(s)),
                registerCursors: s => {
                    let a = {};
                    for (let l in s) {
                        let c = o[l] ?? s[l];
                        c && (a[l] = c)
                    }
                    o = a;
                    for (let l of i)
                        l(o)
                }
            }
        }
        )
            , r = Fi();
        return ge(gg.Provider, {
            value: n,
            children: [t, !r && k(U5, {})]
        })
    })
    , N5 = (() => nf($5, [`.${_u}, .${_u} * { cursor: none !important; }`, `.${$m}, .${$m} * { pointer-events: none !important; }`]))()
    , j5 = (() => ({
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: 12 + 1,
        pointerEvents: "none"
    }))();
function H5(e) {
    return !(!e || e.placement || e.alignment)
}
function mu(e) {
    switch (e) {
        case "start":
            return "0%";
        case "center":
            return "-50%";
        case "end":
            return "-100%";
        default:
            Ce(e)
    }
}
function W5(e, t = "center") {
    switch (e) {
        case "top":
            return `${mu(t)}, -100%`;
        case "right":
            return `0%, ${mu(t)}`;
        case "bottom":
            return `${mu(t)}, 0%`;
        case "left":
            return `-100%, ${mu(t)}`;
        default:
            return "-50%, -50%"
    }
}
var K1 = "data-framer-portal-id";
function Q1(e, t) {
    let n = document.elementFromPoint(e, t);
    for (; n;) {
        if (n === document.body)
            return;
        let r = n.getAttribute("data-framer-cursor");
        if (r)
            return r;
        if (n.hasAttribute(K1)) {
            let i = n.getAttribute(K1);
            n = n.parentElement,
                i && (n = document.getElementById(i) ?? n)
        } else
            n = n.parentElement
    }
}
function Z1(e) {
    for (let t in e)
        return !1;
    return !0
}
var U5 = ol(function () {
    let { onRegisterCursors: t } = D(gg)
        , [n, r] = Ee(!1)
        , i = nr(0)
        , o = nr(0)
        , s = nr(0)
        , a = V(null)
        , l = V({
            cursors: {},
            cursorHash: void 0
        })
        , c = Zu();
    ze(() => {
        let T = it.matchMedia("(any-hover: none)");
        function R(F) {
            F.matches ? at(() => r(!1)) : r(!0)
        }
        return T.addEventListener("change", R),
            T.matches || r(!0),
            () => {
                T.removeEventListener("change", R)
            }
    }
        , []),
        H(() => {
            if (!n)
                return;
            let T = 0
                , R = 0;
            function F() {
                i.set(T),
                    o.set(R),
                    rr(s, 1, {
                        type: "tween",
                        duration: .2
                    })
            }
            let P = () => {
                if (Z1(l.current.cursors))
                    return;
                let N = Q1(T, R);
                N !== l.current.cursorHash && (l.current.cursorHash = N,
                    J.update(() => c()))
            }
                ;
            function B(N) {
                if (N.pointerType === "touch") {
                    Ft(P);
                    return
                }
                J.read(P, !0),
                    T = N.clientX,
                    R = N.clientY,
                    J.update(F)
            }
            function $(N) {
                if (N.target === a.current || !a.current)
                    return;
                let U = new PointerEvent(N.type, {
                    bubbles: !0,
                    cancelable: N.cancelable,
                    pointerType: N.pointerType,
                    pointerId: N.pointerId,
                    composed: N.composed,
                    isPrimary: N.isPrimary,
                    buttons: N.buttons,
                    button: N.button
                });
                J.update(() => {
                    var j;
                    (j = a.current) == null || j.dispatchEvent(U)
                }
                )
            }
            return it.addEventListener("pointermove", B),
                document.addEventListener("pointerdown", $),
                document.addEventListener("pointerup", $),
                J.read(P, !0),
                () => {
                    it.removeEventListener("pointermove", B),
                        document.removeEventListener("pointerdown", $),
                        document.removeEventListener("pointerup", $),
                        Ft(P)
                }
        }
            , [s, i, o, c, n]),
        H(() => {
            if (!n)
                return;
            function T() {
                rr(s, 0, {
                    type: "tween",
                    duration: .2
                })
            }
            return document.addEventListener("mouseleave", T),
                it.addEventListener("blur", T),
                () => {
                    document.removeEventListener("mouseleave", T),
                        it.removeEventListener("blur", T)
                }
        }
            , [s, n]),
        ze(() => {
            function T(F) {
                l.current.cursors = F,
                    l.current.cursorHash = Z1(F) ? null : Q1(i.get(), o.get()),
                    c()
            }
            let R = t(T);
            return () => {
                R(),
                    document.body.classList.toggle(_u, !1)
            }
        }
            , [i, o, t, c]);
    let { cursors: u, cursorHash: f } = l.current
        , d = f ? u[f] : null
        , p = H5(d);
    ze(() => {
        n && document.body.classList.toggle(_u, p)
    }
        , [p, n]);
    let v = d?.component
        , g = d?.transition ?? {
            duration: 0
        }
        , b = jd(i, g)
        , m = jd(o, g)
        , h = Dt(() => {
            var T;
            return b.get() + (((T = d?.offset) == null ? void 0 : T.x) ?? 0)
        }
        )
        , y = Dt(() => {
            var T;
            return m.get() + (((T = d?.offset) == null ? void 0 : T.y) ?? 0)
        }
        )
        , w = d?.alignment
        , C = d?.placement
        , S = Q((T, R) => `translate(${W5(C, w)}) ${R}`, [w, C]);
    return !n || !d || !v ? null : k(v, {
        transformTemplate: S,
        style: {
            ...j5,
            x: h,
            y,
            opacity: s
        },
        globalTapTarget: !0,
        variant: d?.variant,
        ref: a,
        className: $m
    })
});
function wU(e) {
    let { registerCursors: t } = D(gg)
        , n = yt(() => e);
    ze(() => {
        t(n)
    }
        , [n, t])
}
var JC = x.createContext(void 0)
    , rf = class {
        constructor(e) {
            this.resolver = e,
                E(this, "status")
        }
        static is(e) {
            return e instanceof rf
        }
        preload() {
            if (this.status) {
                let t = this.status;
                return t.type !== "pending" ? void 0 : t.promise
            }
            let e = this.resolver().then(t => {
                this.status = {
                    type: "fulfilled",
                    value: t
                }
            }
                , t => {
                    this.status = {
                        type: "rejected",
                        error: t
                    }
                }
            );
            return this.status = {
                type: "pending",
                promise: e
            },
                e
        }
        waitFor() {
            return this.resolver()
        }
        read() {
            let e = this.status;
            if (!e)
                throw new Error("Need to call preload() before read()");
            switch (e.type) {
                case "pending":
                    throw new Error("Need to wait for preload() to resolve");
                case "fulfilled":
                    return e.value;
                case "rejected":
                    throw e.error;
                default:
                    Ce(e)
            }
        }
    }
    , eT = x.createContext(void 0)
    , EU = (() => eT.Provider)()
    , Qa = () => x.useContext(eT) ?? {};
function vg(e, t) {
    return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : vg(e.parentElement, t) : null
}
function G5({ children: e }) {
    let { useGranularSuspense: t } = Qa();
    return t ? k(eg, {
        children: e
    }) : e
}
function tT(e) {
    return Ie(function (n, r) {
        return k(G5, {
            children: k(e, {
                ...n,
                ref: r
            })
        })
    })
}
var J1 = "element"
    , q5 = "collection"
    , X5 = "collectionItemId"
    , Y5 = "pathVariables"
    , nT = "framer/page-link,";
function rT(e) {
    return ye(e) && e.startsWith(`data:${nT}`)
}
function yg(e) {
    if (rT(e))
        try {
            let t = new URL(e), n = t.pathname.substring(nT.length), r = t.searchParams, i = r.has(J1) ? r.get(J1) : void 0, o, s = r.get(q5), a = r.get(X5), l = r.get(Y5);
            if (s && a && l) {
                let c = Object.fromEntries(new URLSearchParams(l).entries());
                o = {
                    collection: s,
                    collectionItemId: a,
                    pathVariables: c
                }
            }
            return {
                target: n === "none" ? null : n,
                element: i === "none" ? void 0 : i,
                collectionItem: o
            }
        } catch {
            return
        }
}
function K5(e, t, n) {
    var r;
    let i = t.getAttribute("data-framer-page-link-target"), o, s;
    if (i) {
        o = t.getAttribute("data-framer-page-link-element") ?? void 0;
        let l = t.getAttribute("data-framer-page-link-path-variables");
        l && (s = Object.fromEntries(new URLSearchParams(l).entries()))
    } else {
        let l = t.getAttribute("href");
        if (!l)
            return !1;
        let c = yg(l);
        if (!c || !c.target)
            return !1;
        i = c.target,
            o = c.element ?? void 0,
            s = (r = c.collectionItem) == null ? void 0 : r.pathVariables
    }
    let a = o ? t.dataset.framerSmoothScroll !== void 0 : void 0;
    return e(i, o, Object.assign({}, n, s), a),
        !0
}
var Q5 = class {
    constructor() {
        E(this, "links", new Map)
    }
    clear() {
        this.links.clear()
    }
    getLinks() {
        return this.links
    }
    addLink(e, t) {
        if (typeof I < "u" || !e || !t)
            return;
        this.links.has(e) || this.links.set(e, new Set),
            this.links.get(e).add(t)
    }
}
    , Z5 = new Q5
    , J5 = 500
    , e4 = .9
    , t4 = 1.7
    , n4 = 4
    , r4 = 1 / 0
    , Qo = new WeakMap
    , gu = new Set
    , Zo = new Map;
function i4() {
    var e;
    let t = _e.connection || _e.mozConnection || _e.webkitConnection || {}, n = _e.deviceMemory && _e.deviceMemory > t4, r, i, o;
    function s() {
        r = t.effectiveType || "",
            i = t.saveData || r.includes("2g"),
            o = r === "3g" || n ? n4 : r4
    }
    (e = t.addEventListener) == null || e.call(t, "change", s),
        s();
    let a = new IntersectionObserver(u, {
        threshold: e4
    })
        , l = 0;
    async function c(f, d) {
        if (i)
            return;
        let p = Zo.get(f);
        if (!p?.size || gu.has(f))
            return;
        ++l,
            gu.add(f);
        let v = Zk(f).catch(() => { }
        );
        a.unobserve(d),
            Qo.delete(d);
        for (let g of p)
            a.unobserve(g),
                Qo.delete(g);
        p.clear(),
            Zo.delete(f),
            await v,
            --l
    }
    function u(f) {
        var d;
        for (let p of f) {
            let v = p.target
                , g = Qo.get(v);
            if (!g || gu.has(g)) {
                a.unobserve(v),
                    Qo.delete(v);
                continue
            }
            let b = Zo.get(g)
                , m = ((d = Zo.get(g)) == null ? void 0 : d.size) ?? 0;
            if (p.isIntersecting) {
                if (l >= o)
                    continue;
                b ? b.add(v) : Zo.set(g, new Set([v])),
                    setTimeout(c.bind(void 0, g, v), J5)
            } else
                b && b.delete(v),
                    m <= 1 && Zo.delete(g)
        }
    }
    return (f, d) => {
        if (!gu.has(f))
            return Qo.set(d, f),
                a.observe(d),
                () => {
                    Qo.delete(d),
                        a.unobserve(d)
                }
    }
}
var o4 = !tg || typeof IntersectionObserver > "u" ? null : i4()
    , wm = Symbol("noLocale")
    , vu = new Map;
function bg(e, t, n) {
    var r, i;
    let o = (i = (r = vu?.get(n?.id ?? wm)) == null ? void 0 : r.get(e.collectionId)) == null ? void 0 : i.get(e.collectionItemId);
    if (o)
        return o;
    let s = vu.get(n?.id ?? wm) ?? new Map;
    vu.set(n?.id ?? wm, s);
    let a = s.get(e.collectionId) ?? new Map;
    s.set(e.collectionId, a);
    let l = new rf(async () => {
        try {
            let c = t[e.collectionId];
            if (!c)
                throw new Error(`Key not found in collection utils for collection id: "${e.collectionId}`);
            let u = await c();
            if (!u)
                throw new Error("Collection does not contain utility functions");
            return await u.getSlugByRecordId(e.collectionItemId, n ?? void 0)
        } catch (c) {
            console.warn(`Failed to resolve slug: ${cinstanceof Error ? c.message : "Unknown error"} `);
            return
        }
    }
    );
    return a.set(e.collectionItemId, l),
    l
}
function hs() {
    return fe.current() === fe.canvas
}
var s4 = "webPageId";
function as(e) {
    return !!(e && typeof e == "object" && s4 in e)
}
function a4(e) {
    if (!e)
        return;
    let t = {};
    for (let n in e.pathVariables) {
        let r = e.pathVariables[n];
        r && (t[n] = r)
    }
    return t
}
function Ga(e) {
    if (!rT(e))
        return e;
    let t = yg(e);
    if (!t)
        return;
    let {target: n, element: r, collectionItem: i} = t;
    if (n)
        return {
            webPageId: n,
            hash: r ?? void 0,
            pathVariables: a4(i)
        }
}
var iT = /:([a-z]\w*)/gi
  , l4 = be(void 0);
function xg() {
    var e;
    let t = D(l4)
      , n = (e = ro()) == null ? void 0 : e.pathVariables;
    return t || n
}
function oT(e, {webPageId: t, hash: n, pathVariables: r}, i) {
    if (t !== e.id || n)
        return !1;
    if (e.path && e.pathVariables) {
        let o = Object.assign({}, i, r);
        for (let[,s] of e.path.matchAll(iT))
            if (!s || e.pathVariables[s] !== o[s])
                return !1
    }
    return !0
}
function wg(e) {
    return e === void 0 ? !1 : !!(e.startsWith("#") || e.startsWith("/") || e.startsWith("."))
}
function sT(e, t) {
    try {
        return !!new URL(e).protocol
    } catch {}
    return t
}
function Sg(e, t) {
    return e !== void 0 ? e ? "_blank" : void 0 : t ? void 0 : "_blank"
}
function xu(e, t=void 0) {
    let n = wg(e)
      , r = Sg(t, n);
    return {
        href: e === "" || sT(e, n) ? e : `https://${e}`,
        target: r,
            rel: n ? void 0 : "noopener"
    }
}
function kg(e, t, n, r, i) {
    var o, s;
    let a = (o = e.getRoute) == null ? void 0 : o.call(e, t);
    a && Dk(a?.page) && a.page.preload(),
        (s = e.navigate) == null || s.call(e, t, n, r, i)
}
function aT(e, t, n, r, i) {
    return async o => {
        if (o.metaKey)
            return;
        let s = vg(o.target);
        !s || s.getAttribute("target") === "_blank" || (o.preventDefault(),
            kg(e, t, n, r, i))
    }
}
function yu(e, t, n) {
    let r = document.createElement("a");
    r.href = e,
        t && (r.rel = t),
        n && (r.target = n),
        document.body.appendChild(r),
        r.click(),
        r.remove()
}
async function c4(e, t, n, r) {
    async function i(a) {
        if (!a || !n)
            return {};
        let l = {};
        for (let c in a) {
            let u = a[c];
            A(u, "unresolvedSlug should be defined");
            let f = bg(u, n, r);
            await f.preload();
            let d = f.read();
            d && (l[c] = d)
        }
        return l
    }
    let [o, s] = await Promise.allSettled([i(e), i(t)]);
    return {
        path: o.status === "fulfilled" ? o.value : void 0,
        hash: s.status === "fulfilled" ? s.value : void 0
    }
}
function u4(e, t, n, r) {
    let i = [];
    function o(a) {
        if (!a || !n)
            return;
        let l = {};
        for (let c in a) {
            let u = a[c];
            A(u, "unresolvedSlug should be defined");
            let f = bg(u, n, r)
                , d = f.preload();
            if (d)
                i.push(d);
            else {
                let p = f.read();
                p && (l[c] = p)
            }
        }
        return l
    }
    let s = {
        path: o(e),
        hash: o(t)
    };
    if (i.length)
        throw Promise.allSettled(i);
    return s
}
function lT(e, t, n, r, i, o, s, a) {
    var l;
    let c = {
        ...i,
        ...o,
        ...a?.path
    }
        , u = {
            ...i,
            ...s,
            ...a?.hash
        }
        , f = (l = e.getRoute) == null ? void 0 : l.call(e, n)
        , d = Xu(f, {
            currentRoutePath: t?.path,
            currentPathVariables: t?.pathVariables,
            hash: r,
            pathVariables: c,
            hashVariables: u,
            preserveQueryParams: e.preserveQueryParams
        })
        , p = d.split("#", 2)[1];
    return {
        routeId: n,
        route: f,
        href: d,
        elementId: p,
        pathVariables: c
    }
}
function cT(e, t, n) {
    if (!(!e.routes || !e.getRoute || !wg(t)))
        try {
            let [i, o] = t.split("#", 2);
            A(i !== void 0, "A href must have a defined pathname.");
            let [s] = i.split("?", 2);
            A(s !== void 0, "A href must have a defined pathname.");
            let { routeId: a, pathVariables: l } = Qk(e.routes, s)
                , c = e.getRoute(a);
            if (c) {
                let u = Object.assign({}, n, l);
                return {
                    routeId: a,
                    route: c,
                    href: t,
                    elementId: o,
                    pathVariables: u
                }
            }
        } catch { }
}
async function f4(e, t, n, r, i) {
    let { webPageId: o, hash: s, pathVariables: a, hashVariables: l, unresolvedHashSlugs: c, unresolvedPathSlugs: u } = n
        , f = await c4(u, c, e.collectionUtils, r);
    return lT(e, t, o, s, i, a, l, f)
}
function d4(e, t, n, r, i) {
    let { webPageId: o, hash: s, pathVariables: a, hashVariables: l, unresolvedHashSlugs: c, unresolvedPathSlugs: u } = n
        , f = u4(u, c, e.collectionUtils, r);
    return lT(e, t, o, s, i, a, l, f)
}
function h4(e, t, n, r, i, o) {
    if (!r)
        return xu(e, t);
    let s = cT(n, e, i);
    if (!s)
        return xu(e, t);
    let { routeId: a, route: l, elementId: c, pathVariables: u } = s;
    if (!l)
        return xu(e, t);
    let f = Xu(l, {
        currentRoutePath: r.path,
        currentPathVariables: r.pathVariables,
        hash: c,
        pathVariables: u,
        preserveQueryParams: n.preserveQueryParams
    })
        , d = Sg(t, !0);
    return {
        href: f,
        target: d,
        onClick: aT(n, a, c, u, o),
        navigate: () => kg(n, a, c, u, o),
        "data-framer-page-link-current": !c && r.id === a || void 0
    }
}
function uT(e, t, n) {
    var r;
    if (ye(e)) {
        let o = wg(e);
        if (!t.routes || !t.getRoute || !n || !o)
            return;
        let [s] = e.split("#", 2);
        if (s === void 0)
            return;
        let [a] = s.split("?", 2);
        if (a === void 0)
            return;
        let { routeId: l } = Qk(t.routes, a);
        return t.getRoute(l)
    }
    let { webPageId: i } = e;
    return (r = t.getRoute) == null ? void 0 : r.call(t, i)
}
var OU = tT(Ie(function ({ children: t, href: n, openInNewTab: r, smoothScroll: i, nodeId: o, ...s }, a) {
    let l = bi()
        , c = ro()
        , u = xg()
        , { activeLocale: f } = Yu()
        , d = tf(a)
        , p = ue(() => {
            if (!n)
                return {};
            let S = as(n) ? n : Ga(n);
            if (!S)
                return {};
            if (ye(S))
                return h4(S, r, l, c, u, i);
            let { routeId: T, href: R, elementId: F, pathVariables: P } = d4(l, c, S, f, u)
                , B = Sg(r, !0);
            return {
                href: R,
                target: B,
                onClick: aT(l, T, F, P, i),
                navigate: () => kg(l, T, F, P, i),
                "data-framer-page-link-current": c && oT(c, S, u) || void 0
            }
        }
            , [n, l, f, u, r, c, i])
        , [v, g] = p4(o, n, p)
        , b = Q(S => {
            var T;
            let R = as(n) ? n : Ga(n);
            if (!R)
                return;
            let F = uT(R, l, c);
            if (F)
                return (T = o4) == null ? void 0 : T(F, S)
        }
            , [c, n, l])
        , m = At(t) && "ref" in t
        , h = hg(m ? t.ref : void 0);
    to(h, S => {
        S !== null && g(S)
    }
        , [g]),
        to(h, S => {
            if (S !== null)
                return b(S)
        }
            , [b]);
    let { navigate: y, ...w } = p
        , C = d.cloneAsArray(t, {
            ...s,
            ...w,
            ref: h
        });
    return v(C)
}))
    , ek = be(void 0);
function p4(e, t, n) {
    let r = D(ek)
        , i = hs()
        , o = bi()
        , s = ro()
        , { replaceNestedLinks: a } = Qa()
        , l = ue(() => {
            let b = as(t) ? t : Ga(t);
            if (b)
                return uT(b, o, s)
        }
            , [s, t, o])
        , c = Object.keys(n).length > 0
        , u = !!(a && !i && (r || !c))
        , f = Q(b => {
            var m;
            if (!n.href)
                return;
            if (b.preventDefault(),
                b.stopPropagation(),
                /Mac|iPod|iPhone|iPad/u.test(_e.userAgent) ? b.metaKey : b.ctrlKey) {
                yu(n.href, "", "_blank");
                return
            }
            l ? (m = n.navigate) == null || m.call(n) : yu(n.href, n.rel, n.target)
        }
            , [n, l])
        , d = Q(b => {
            n.href && (b.preventDefault(),
                b.stopPropagation(),
                yu(n.href, "", "_blank"))
        }
            , [n])
        , p = Q(b => {
            var m;
            n.href && b.key === "Enter" && (b.preventDefault(),
                b.stopPropagation(),
                l ? (m = n.navigate) == null || m.call(n) : yu(n.href, n.rel, n.target))
        }
            , [n, l])
        , v = Q(b => {
            let m = {
                "data-nested-link": !0,
                role: "link",
                tabIndex: 0,
                onClick: f,
                onAuxClick: d,
                onKeyDown: p
            }
                , h = u ? yn.map(b, y => {
                    if (!g4(y))
                        return y;
                    Z5.addLink(r, e);
                    let w = Iu(y.type)
                        , { children: C, ...S } = y.props
                        , T = c ? {
                            ...S,
                            ...m,
                            as: S.as && Iu(S.as)
                        } : S
                        , R = "ref" in y ? y.ref : void 0;
                    return Nr(w, {
                        ...T,
                        ref: R
                    }, C)
                }
                ) : b;
            return k(ek.Provider, {
                value: e,
                children: h
            })
        }
            , [c, e, d, f, p, u, r])
        , g = Q(b => {
            i || !u || !c || (b.dataset.hydrated = "true")
        }
            , [i, c, u]);
    return [v, g]
}
function m4(e, t, n, r) {
    let i = as(e) ? e : Ga(e);
    if (!as(i))
        return ye(e) ? xu(e).href : void 0;
    if (!t.getRoute || !t.currentRouteId)
        return;
    let o = t.getRoute(t.currentRouteId)
        , { webPageId: s, hash: a, pathVariables: l, hashVariables: c, unresolvedHashSlugs: u, unresolvedPathSlugs: f } = i
        , d = t.getRoute(s)
        , p = f || u ? r?.(f, u) : void 0
        , v = Object.assign({}, t.currentPathVariables, n, l, p?.path)
        , g = Object.assign({}, t.currentPathVariables, n, c, p?.hash);
    return Xu(d, {
        currentRoutePath: o?.path,
        currentPathVariables: t.currentPathVariables,
        hash: a,
        pathVariables: v,
        hashVariables: g,
        relative: !1,
        preserveQueryParams: t.preserveQueryParams
    })
}
function g4(e) {
    return At(e) && (Iu(e.type) !== e.type || Iu(e.props.as) !== e.props.as)
}
function Iu(e) {
    return e === "a" ? "span" : Bl(e) && Ud(e) === "a" ? Ye.span : e
}
var v4 = class extends ke {
    constructor() {
        super(...arguments),
            E(this, "state", {
                error: void 0
            })
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
    , y4 = "framer"
    , b4 = 3
    , x4 = 30
    , w4 = 1e4;
async function S4() {
    let e = "0".repeat(b4)
        , t = Date.now()
        , n = !0;
    for (; n;) {
        let r = Date.now();
        if (r - t > w4) {
            n = !1;
            return
        }
        let i = C4(x4)
            , o = `${r}:${i}`
            , s = await k4(y4 + o);
        if (s.startsWith(e))
            return {
                secret: o,
                hash: s
            }
    }
}
async function k4(e) {
    let t = new TextEncoder().encode(e)
        , n = await crypto.subtle.digest("SHA-256", t);
    return Array.from(new Uint8Array(n)).map(r => r.toString(16).padStart(2, "0")).join("")
}
function C4(e) {
    let t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        , n = ""
        , r = t.length;
    for (let i = 0; i < e; i++)
        n += t.charAt(Math.floor(Math.random() * r));
    return n
}
function T4(e) {
    return Array.from(e.keys()).map(encodeURIComponent).join(",")
}
function R4(e, t) {
    try {
        let n = t.cookie.match("(^|;) ?framerFormsUTMTags=([^;]*)(;|$)");
        if (n !== null && n[2]) {
            let r = JSON.parse(decodeURIComponent(n[2]));
            if (!r || typeof r != "object")
                return;
            ["utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content", "gclid"].forEach(i => {
                typeof r[i] == "string" && e.append(i, r[i])
            }
            )
        }
    } catch { }
}
var E4 = {
    state: "pending"
}
    , F4 = {
        state: "success"
    }
    , fT = {
        state: "incomplete"
    }
    , P4 = {
        state: "complete"
    }
    , Sm = {
        state: "error"
    };
function _4({ state: e }, { type: t }) {
    switch (t) {
        case "complete":
            return e === "error" ? Sm : P4;
        case "incomplete":
            return e === "error" ? Sm : fT;
        case "submit":
            return E4;
        case "success":
            return F4;
        case "error":
            return Sm;
        default:
            Ce(t)
    }
}
function I4({ state: e }) {
    return e === "incomplete" || e === "complete"
}
function O4(e) {
    e.preventDefault()
}
function M4(e, t) {
    let n = sT(e, !1) ? e : `https://${e}`
        , r = document.createElement("a");
    r.href = n,
        r.target = "_self",
        r.style.display = "none",
        "current" in t && t.current && (t.current.appendChild(r),
            r.click(),
            r.remove())
}
var Cg = x.createContext(void 0)
    , DU = x.forwardRef(function ({ action: t, children: n, redirectUrl: r, onSuccess: i, onError: o, onLoading: s, ...a }, l) {
        let c = x.useRef(null)
            , u = l ?? c
            , f = bi()
            , d = ro()
            , p = xg()
            , [v, g] = x.useReducer(_4, fT)
            , { activeLocale: b } = Yu()
            , m = D(Cg)
            , h = x.useRef({
                onSuccess: i,
                onError: o,
                onLoading: s
            });
        h.current = {
            onSuccess: i,
            onError: o,
            onLoading: s
        };
        async function y(T) {
            var R, F;
            if (ye(T)) {
                let U = cT(f, T, p);
                if (!U) {
                    M4(T, u);
                    return
                }
                let { routeId: j, elementId: ae, pathVariables: te } = U;
                (R = f.navigate) == null || R.call(f, j, ae, te);
                return
            }
            A(as(T), "Expected link to be either a LinkToWebPage or a string", T);
            let P = await f4(f, d, T, b, p)
                , { routeId: B, elementId: $, pathVariables: N } = P;
            (F = f.navigate) == null || F.call(f, B, $, N)
        }
        let w = async T => {
            var R, F, P, B, $, N;
            if (T.preventDefault(),
                !t || !m)
                return;
            g({
                type: "submit"
            });
            let U = new FormData(T.currentTarget);
            await Zi({
                priority: "user-blocking"
            }),
                R4(U, it.document);
            for (let [j, ae] of U)
                ae instanceof File && U.delete(j);
            try {
                (F = (R = h.current).onLoading) == null || F.call(R),
                    await L4(t, U, m),
                    at(() => g({
                        type: "success"
                    })),
                    (B = (P = h.current).onSuccess) == null || B.call(P),
                    r && await y(r)
            } catch (j) {
                at(() => g({
                    type: "error"
                })),
                    (N = ($ = h.current).onError) == null || N.call($),
                    console.error(j)
            }
        }
            , C = T => {
                let { target: R, currentTarget: F, key: P } = T;
                R instanceof HTMLTextAreaElement || P === "Enter" && F.checkValidity() && (T.preventDefault(),
                    w(T))
            }
            , S = async T => {
                let R = T.currentTarget;
                await Zi({
                    priority: "background"
                }),
                    at(() => g({
                        type: dT(R) ? "incomplete" : "complete"
                    }))
            }
            ;
        return k(Ye.form, {
            ...a,
            onSubmit: I4(v) ? w : O4,
            onKeyDown: C,
            onChange: S,
            ref: u,
            children: n(v)
        })
    });
function dT(e) {
    if (e.children.length === 0)
        return !1;
    for (let t of e.children)
        if (t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement || t instanceof HTMLSelectElement) {
            if (t.required && t.value === "")
                return !0
        } else if (dT(t))
            return !0;
    return !1
}
async function L4(e, t, n) {
    let r = await S4();
    if (!r)
        throw new Error("Failed to calculate proof of work");
    let i = await fetch(e, {
        body: t,
        method: "POST",
        headers: {
            "Framer-Site-Id": n,
            "Framer-POW": r.secret,
            "Framer-Form-Fields": T4(t)
        }
    });
    if (i.ok)
        return i;
    {
        let o = await i.json()
            , s = "Failed to submit form";
        throw V4(o) ? new Error(`${s} - ${o.error.message}`) : new Error(s)
    }
}
function V4(e) {
    return typeof e == "object" && e !== null && "error" in e && Se(e.error) && "message" in e.error && typeof e.error.message == "string"
}
function A4(e) {
    return new Promise((t, n) => {
        try {
            new URL(e);
            let r = new Image;
            r.onload = () => t(),
                r.onerror = n,
                r.src = e
        } catch (r) {
            n(r)
        }
    }
    )
}
function D4(e) {
    return typeof e == "object" && e !== null
}
function z4(e, t) {
    if (t === "")
        return e;
    let n = t.split(/[.[\]]+/u).filter(i => i.length > 0)
        , r = e;
    for (let i of n) {
        if (!D4(r))
            return;
        r = r[i]
    }
    return r
}
function _a(e) {
    return `${e.credentials}:${e.url}`
}
var B4 = {
    status: "loading",
    data: void 0
};
function $4(e) {
    return ye(e) && !Number.isNaN(Number(e))
}
function N4(e, t) {
    switch (e) {
        case "string":
            return ye(t) || De(t);
        case "color":
            return ye(t);
        case "boolean":
            return ig(t);
        case "number":
            return De(t) || $4(t);
        case "link":
        case "image":
            return ye(t) && Nm(t);
        default:
            {
                let n = e;
                return !1
            }
    }
}
function j4(e, t) {
    if (e.status === "loading")
        return t.fallbackValue;
    if (e.status === "error")
        throw e.error;
    let n = z4(e.data, t.resultKeyPath);
    if (Qe(n))
        throw new Error(`Key '${t.resultKeyPath}' not found in response`);
    if (!N4(t.resultOutputType, n))
        throw new Error(`Resolved value '${n}' is not valid for type '${t.resultOutputType}'`);
    return n
}
function Nm(e) {
    try {
        return !!new URL(e).protocol
    } catch { }
}
function km(e, t) {
    if (fe.current() === fe.canvas)
        return !1;
    let n = t === 0 ? 500 : t * 1e3
        , r = Date.now()
        , i = e + n;
    return r >= i
}
var tk = () => { }
    , Ar, wu, Wi, Ui, Ia, vi, Su = class {
        constructor() {
            E(this, "responseValues", new Map),
                tn(this, Ar, new Map),
                tn(this, wu, new Set),
                tn(this, Wi, new Map),
                tn(this, Ui, new Map),
                tn(this, Ia, new Map),
                tn(this, vi, new Map),
                E(this, "persistCache", Rz(() => {
                    let e = {};
                    for (let [t, n] of this.responseValues) {
                        if (!n || n.status !== "success")
                            continue;
                        let r = me(this, Wi).get(t);
                        if (!r || r === 0)
                            continue;
                        let i = me(this, Ui).get(t);
                        i && (i && km(i, r) || (e[t] = [i, r, n.data]))
                    }
                    try {
                        localStorage.setItem(Su.cacheKey, JSON.stringify(e))
                    } catch { }
                }
                    , 500))
        }
        unmount() {
            for (let [e, t] of me(this, vi))
                clearInterval(t),
                    me(this, vi).delete(e)
        }
        stopQueryRefetching(e) {
            let t = _a(e)
                , n = me(this, vi).get(t);
            n && (clearInterval(n),
                me(this, vi).delete(t))
        }
        startQueryRefetching(e) {
            let t = _a(e)
                , n = me(this, vi).get(t)
                , r = me(this, Wi).get(t);
            if (n || !r)
                return;
            let i = it.setInterval(() => {
                if (document.visibilityState === "hidden")
                    return;
                let o = me(this, Ui).get(t);
                !r || !o || this.fetchWithCache({
                    ...e,
                    cacheDuration: r
                })
            }
                , r);
            me(this, vi).set(t, i)
        }
        hydrateCache() {
            try {
                let e = localStorage.getItem(Su.cacheKey);
                if (!e)
                    return;
                let t = JSON.parse(e);
                if (typeof t != "object")
                    throw new Error("Invalid cache data");
                for (let n in t) {
                    let r = t[n];
                    if (!Array.isArray(r) || r.length !== 3)
                        throw new Error("Invalid cache data");
                    let [i, o, s] = r;
                    km(i, o) || (me(this, Ui).set(n, i),
                        me(this, Wi).set(n, o),
                        this.responseValues.set(n, {
                            status: "success",
                            data: s
                        }))
                }
            } catch {
                try {
                    localStorage.removeItem(Su.cacheKey)
                } catch { }
            }
        }
        setResponseValue(e, t) {
            this.responseValues.set(e, t),
                this.persistCache();
            let n = me(this, Ar).get(e);
            if (n)
                for (let r of n)
                    r()
        }
        async prefetch(e) {
            if (!Gn() || !Nm(e.url))
                return;
            let t = _a(e);
            me(this, wu).add(t),
                await this.fetchWithCache(e);
            let n = this.getValue(t);
            if (!n || n.status === "loading")
                throw new Error("Unexpected result status for prefetch");
            let r = me(this, Ar).get(t);
            for (let o of r ?? [])
                o();
            let i = j4(n, e);
            return e.resultOutputType === "image" && ye(i) && await A4(i).catch(tk),
                i
        }
        async fetchWithCache(e) {
            if (!Gn())
                return;
            let t = _a(e)
                , n = me(this, Ia).get(t);
            if (n)
                return n;
            let r = me(this, Ui).get(t)
                , i = r && km(r, e.cacheDuration);
            if (this.responseValues.has(t) && !i)
                return;
            this.responseValues.get(t) || this.setResponseValue(t, B4);
            let a = (async () => {
                try {
                    let l = await fetch(e.url, {
                        method: "GET",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        credentials: e.credentials
                    });
                    if (!l.ok) {
                        this.setResponseValue(t, {
                            status: "error",
                            error: new Error("Invalid Response Status"),
                            data: void 0
                        });
                        return
                    }
                    let c = await l.json();
                    this.setResponseValue(t, {
                        status: "success",
                        data: c
                    }),
                        me(this, Ui).set(t, Date.now())
                } catch (l) {
                    this.setResponseValue(t, {
                        status: "error",
                        error: l,
                        data: void 0
                    })
                }
            }
            )();
            return me(this, Ia).set(t, a),
                a.finally(() => {
                    me(this, Ia).delete(t)
                }
                ),
                a
        }
        getValue(e, t = !1) {
            if (!(t && !me(this, wu).has(e)))
                return this.responseValues.get(e)
        }
        subscribe(e, t, n = !1) {
            let { url: r, cacheDuration: i } = e;
            if (!Nm(r))
                return tk;
            let o = _a(e)
                , s = me(this, Wi).get(o);
            (!s || i < s) && me(this, Wi).set(o, i),
                n || (this.startQueryRefetching(e),
                    this.fetchWithCache(e));
            let a = me(this, Ar).get(o) ?? new Set;
            return a.add(t),
                me(this, Ar).set(o, a),
                () => {
                    let l = me(this, Ar).get(o);
                    l && (l.delete(t),
                        l.size === 0 && me(this, Ar).delete(o),
                        me(this, Ar).size === 0 && this.stopQueryRefetching(e))
                }
        }
    }
    , hT = Su;
Ar = new WeakMap;
wu = new WeakMap;
Wi = new WeakMap;
Ui = new WeakMap;
Ia = new WeakMap;
vi = new WeakMap;
E(hT, "cacheKey", "framer-fetch-client-cache");
var H4 = be(void 0), W4 = be(!0), U4 = ({ children: e, client: t }) => {
    let [n] = Ee(() => t ?? new hT)
        , [r, i] = Ee(!0);
    return H(() => (n.hydrateCache(),
        at(() => {
            i(!1)
        }
        ),
        () => n.unmount()), [n]),
        k(W4.Provider, {
            value: r,
            children: k(H4.Provider, {
                value: n,
                children: e
            })
        })
}
    , G4, q4, X4, Y4, K4;
G4 = new WeakMap;
q4 = new WeakMap;
X4 = new WeakMap;
Y4 = new WeakMap;
K4 = new WeakMap;
function $U({ RootComponent: e, isWebsite: t, routeId: n, framerSiteId: r, pathVariables: i, routes: o, collectionUtils: s, notFoundPage: a, isReducedMotion: l = !1, includeDataObserver: c = !1, localeId: u, locales: f, preserveQueryParams: d, EditorBar: p }) {
    let { enableAsyncURLUpdates: v } = Qa();
    if (x.useEffect(() => {
        t || nC.start()
    }
        , []),
        t)
        return k(rb, {
            reducedMotion: l ? "user" : "never",
            children: k(U4, {
                children: k(N5, {
                    children: k(Cg.Provider, {
                        value: r,
                        children: k(rV, {
                            initialRoute: n,
                            initialPathVariables: i,
                            initialLocaleId: u,
                            routes: o,
                            collectionUtils: s,
                            notFoundPage: a,
                            locales: f,
                            defaultPageStyle: {
                                minHeight: "100vh",
                                width: "auto"
                            },
                            preserveQueryParams: d,
                            enableAsyncURLUpdates: v,
                            editorBar: k(Q4, {
                                EditorBar: p
                            })
                        })
                    })
                })
            })
        });
    {
        let g = c ? $z : x.Fragment;
        return k(g, {
            children: k(XL, {
                routes: o,
                children: k(Tz, {
                    children: x.isValidElement(e) ? e : x.createElement(e, {
                        key: n
                    })
                })
            })
        })
    }
}
function Q4({ EditorBar: e }) {
    let [t, n] = Ee(!1)
        , r = D(Cg);
    return H(() => {
        at(() => {
            n(!0)
        }
        )
    }
        , []),
        !e || !r || !t ? null : k(v4, {
            children: k(br, {
                children: k(e, {
                    framerSiteId: r
                })
            })
        })
}
function Z4(e, t, n) {
    let r = yn.map(e, i => At(i) ? xr(i, t) : i);
    return n ? r : k(lt, {
        children: r
    })
}
var Tg = x.createContext(void 0)
    , pT = "ssr-variant";
function nk(e, t, n, r, i, o, s, a) {
    let l = x.Children.toArray(t)
        , c = l[0];
    if (l.length !== 1 || !x.isValidElement(c))
        return console.warn("PropertyOverrides: expected exactly one React element for a child", t),
            s(t, n);
    let u = []
        , f = [];
    for (let [g] of Object.entries(r)) {
        if (g === i)
            continue;
        let b = e[g];
        if (!b || !eB(c.props, b)) {
            f.push(g);
            continue
        }
        let m = rk([g], o);
        m.length && u.push({
            variants: m,
            propOverrides: b
        })
    }
    if (u.length === 0)
        return s(c, n);
    let d = [i, ...f]
        , p = rk(d, o);
    p.length && u.unshift({
        variants: p
    });
    let v = [];
    for (let { variants: g, propOverrides: b } of u) {
        if (a && !g.includes(a))
            continue;
        let m = g.join("+")
            , h = k(Tg.Provider, {
                value: new Set(g),
                children: s(c, b ? {
                    ...n,
                    ...b
                } : n)
            }, m)
            , y = J4(g, o, r);
        y.length ? (A(u.length > 1, "Must branch out when there are hiddenClassNames"),
            h = k("div", {
                className: `${pT} ${y.join(" ")}`,
                children: h
            }, m)) : A(u.length === 1, "Cannot branch out when hiddenClassNames is empty"),
            v.push(h)
    }
    return A(!a || v.length === 1, "Must render exactly one branch when activeVariantId is given"),
        v
}
function mT(e) {
    return e.split("-")[2]
}
function J4(e, t, n) {
    let r = [];
    for (let [i, o] of Object.entries(n)) {
        let s = t && !t.has(i);
        e.includes(i) || s || r.push(`hidden-${mT(o)}`)
    }
    return r
}
function rk(e, t) {
    return t ? e.filter(n => t.has(n)) : e
}
function eB(e, t) {
    for (let n of Object.keys(t))
        if (!lg(e[n], t[n], !0))
            return !0;
    return !1
}
function tB(e, t, n) {
    return !n || !e ? t : {
        ...t,
        ...n[e]
    }
}
var nB = x.forwardRef(function ({ breakpoint: t, overrides: n, children: r, ...i }, o) {
    let s = tf(o)
        , a = x.useContext(Tg)
        , l = UL()
        , c = yt(() => l.current ? Gn() ? 1 : 2 : 0)
        , u = x.useContext(JC);
    if (!u)
        return console.warn("PropertyOverrides is missing GeneratedComponentContext"),
            s(r, i);
    let { primaryVariantId: f, variantClassNames: d } = u;
    switch (c) {
        case 0:
            return s(r, tB(t, i, n));
        case 1:
            return nk(n, r, i, d, f, a, s, t);
        case 2:
            return nk(n, r, i, d, f, a, Z4, void 0);
        default:
            Ce(c)
    }
})
    , WU = (() => nf(nB, `.${pT} { display: contents }`, "PropertyOverrides"))()
    , GU = tT(Ie(function ({ links: t, children: n, ...r }, i) {
        let o = bi()
            , { activeLocale: s } = Yu()
            , a = tf(i)
            , l = []
            , c = t.map(f => m4(f.href, o, f.implicitPathVariables, (d, p) => {
                function v(g) {
                    let b = {};
                    for (let m in g) {
                        let h = g[m];
                        A(o.collectionUtils, "collectionUtils should be defined"),
                            A(h, "unresolvedSlug be defined");
                        let y = bg(h, o.collectionUtils, s)
                            , w = y.preload();
                        if (w)
                            l.push(w);
                        else {
                            let C = y.read();
                            C && (b[m] = C)
                        }
                    }
                    return b
                }
                return {
                    path: v(d),
                    hash: v(p)
                }
            }
            ));
        if (l.length > 0)
            throw Promise.allSettled(l);
        let u = n(c);
        return a(u, r)
    }));
function rB(e) {
    return {
        trace(...t) {
            var n;
            return (n = vt.getLogger(e)) == null ? void 0 : n.trace(...t)
        },
        debug(...t) {
            var n;
            return (n = vt.getLogger(e)) == null ? void 0 : n.debug(...t)
        },
        info(...t) {
            var n;
            return (n = vt.getLogger(e)) == null ? void 0 : n.info(...t)
        },
        warn(...t) {
            var n;
            return (n = vt.getLogger(e)) == null ? void 0 : n.warn(...t)
        },
        error(...t) {
            var n;
            return (n = vt.getLogger(e)) == null ? void 0 : n.error(...t)
        }
    }
}
function iB(e) {
    return vT(e) || sB(e)
}
function oB(e) {
    return Ku(e) && e.every(Se)
}
function gT(e) {
    return Se(e) && Un(e.read) && Un(e.preload)
}
function vT(e) {
    return oB(e) || gT(e)
}
function Rg(e) {
    return Se(e) && Se(e.schema)
}
function yT(e) {
    return Se(e) && Se(e.collectionByLocaleId)
}
function sB(e) {
    return Rg(e) || yT(e)
}
async function ik(e, t) {
    return gT(e) ? (await e.preload(t),
        e.read(t)) : e
}
var aB = class {
    constructor(e, t) {
        this.collection = e,
            this.locale = t,
            E(this, "schema"),
            E(this, "indexes", []);
        let n = fD(e);
        A(n, "Collection does not have properties");
        let r = {
            id: {
                type: "string",
                isNullable: !1
            }
        }
            , i = Object.entries(n);
        for (let [o, s] of i) {
            if (!s)
                continue;
            let a = s.type;
            A(a !== "array", "Array properties are not supported"),
                A(a !== "object", "Object properties are not supported"),
                r[o] = {
                    type: a,
                    isNullable: !0
                }
        }
        this.schema = r
    }
    getDatabaseItem(e, t) {
        let n = {};
        for (let r in this.schema) {
            let i = e[r];
            if (iD(i))
                continue;
            let o = this.schema[r];
            Qe(o) || (A(o.type !== "unknown", "Invalid definition type"),
                n[r] = {
                    type: o.type,
                    value: i
                })
        }
        return {
            pointer: t,
            data: n
        }
    }
    async resolveRichText(e) {
        if (rf.is(e)) {
            let t = e.preload();
            return t && await t,
                e.read()
        }
        return e
    }
    async scanItems() {
        return (await ik(this.collection, this.locale)).map((t, n) => {
            let r = String(n);
            return this.getDatabaseItem(t, r)
        }
        )
    }
    async resolveItems(e) {
        let t = await ik(this.collection, this.locale);
        return e.map(n => {
            let r = Number(n)
                , i = t[r];
            return A(i, "Can't find collection item"),
                this.getDatabaseItem(i, n)
        }
        )
    }
    compareItems(e, t) {
        return Number(e.pointer) - Number(t.pointer)
    }
}
    ;
function lB(e, t) {
    switch (e?.type) {
        case "array":
            return {
                type: "array",
                value: e.value.map(r => Me.cast(r, t.definition))
            }
    }
    return null
}
function bT(e) {
    switch (e?.type) {
        case "boolean":
            return e;
        case "number":
        case "string":
            return {
                type: "boolean",
                value: !!e.value
            }
    }
    return null
}
function $r(e) {
    let t = bT(e);
    return t?.value ?? !1
}
function cB(e) {
    switch (e?.type) {
        case "color":
            return e
    }
    return null
}
function uB(e) {
    switch (e?.type) {
        case "date":
            return e;
        case "number":
        case "string":
            {
                let t = new Date(e.value);
                return dC(t) ? {
                    type: "date",
                    value: t.toISOString()
                } : null
            }
    }
    return null
}
function fB(e) {
    switch (e?.type) {
        case "enum":
            return e;
        case "string":
            return {
                type: "enum",
                value: e.value
            }
    }
    return null
}
function dB(e) {
    switch (e?.type) {
        case "file":
            return e
    }
    return null
}
function hB(e) {
    switch (e?.type) {
        case "link":
            return e;
        case "string":
            try {
                let { protocol: t } = new URL(e.value);
                return t === "http:" || t === "https:" ? {
                    type: "link",
                    value: e.value
                } : null
            } catch {
                return null
            }
    }
    return null
}
function xT(e) {
    switch (e?.type) {
        case "number":
        case "string":
            {
                let t = Number(e.value);
                return Number.isFinite(t) ? {
                    type: "number",
                    value: t
                } : null
            }
    }
    return null
}
function wT(e) {
    let t = xT(e);
    return t?.value ?? null
}
function pB(e, t) {
    switch (e?.type) {
        case "object":
            {
                let n = {}
                    , r = Object.entries(t.definitions);
                for (let [i, o] of r) {
                    let s = e.value[i] ?? null;
                    n[i] = Me.cast(s, o)
                }
                return {
                    type: "object",
                    value: n
                }
            }
    }
    return null
}
function mB(e) {
    switch (e?.type) {
        case "responsiveimage":
            return e
    }
    return null
}
function gB(e) {
    switch (e?.type) {
        case "richtext":
            return e
    }
    return null
}
function ST(e) {
    switch (e?.type) {
        case "string":
            return e;
        case "number":
            return {
                type: "string",
                value: String(e.value)
            }
    }
    return null
}
function Jo(e) {
    let t = ST(e);
    return t?.value ?? null
}
var Me = {
    cast(e, t) {
        switch (t.type) {
            case "array":
                return lB(e, t);
            case "boolean":
                return bT(e);
            case "color":
                return cB(e);
            case "date":
                return uB(e);
            case "enum":
                return fB(e);
            case "file":
                return dB(e);
            case "link":
                return hB(e);
            case "number":
                return xT(e);
            case "object":
                return pB(e, t);
            case "responsiveimage":
                return mB(e);
            case "richtext":
                return gB(e);
            case "string":
                return ST(e);
            case "unknown":
                return e;
            default:
                Ce(t, "Unsupported cast")
        }
    },
    parse(e) {
        return ig(e) ? {
            type: "boolean",
            value: e
        } : dC(e) ? {
            type: "date",
            value: e.toISOString()
        } : De(e) ? {
            type: "number",
            value: e
        } : ye(e) ? {
            type: "string",
            value: e
        } : Ku(e) ? {
            type: "array",
            value: e.map(Me.parse)
        } : null
    },
    equal(e, t, n) {
        return e?.type !== t?.type ? !1 : Gi(e, t, n) === 0
    },
    lessThan(e, t, n) {
        return e?.type !== t?.type ? !1 : Gi(e, t, n) < 0
    },
    lessThanOrEqual(e, t, n) {
        return e?.type !== t?.type ? !1 : Gi(e, t, n) <= 0
    },
    greaterThan(e, t, n) {
        return e?.type !== t?.type ? !1 : Gi(e, t, n) > 0
    },
    greaterThanOrEqual(e, t, n) {
        return e?.type !== t?.type ? !1 : Gi(e, t, n) >= 0
    },
    in(e, t, n) {
        return t?.type !== "array" ? !1 : t.value.some(r => Me.equal(r, e, n))
    },
    indexOf(e, t, n) {
        return e?.type !== "array" ? -1 : e.value.findIndex(r => Me.equal(r, t, n))
    },
    contains(e, t, n) {
        let r = Jo(e)
            , i = Jo(t);
        return dr(r) || dr(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
            i = i.toLowerCase()),
            r.includes(i))
    },
    startsWith(e, t, n) {
        let r = Jo(e)
            , i = Jo(t);
        return dr(r) || dr(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
            i = i.toLowerCase()),
            r.startsWith(i))
    },
    endsWith(e, t, n) {
        let r = Jo(e)
            , i = Jo(t);
        return dr(r) || dr(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
            i = i.toLowerCase()),
            r.endsWith(i))
    },
    length(e) {
        switch (e?.type) {
            case "array":
                return e.value.length
        }
        return 0
    },
    stringify(e) {
        if (e === null)
            return "null";
        switch (e.type) {
            case "array":
                return `[${e.value.map(Me.stringify).join(", ")}]`;
            case "boolean":
            case "number":
                return String(e.value);
            case "string":
                return `'${e.value}'`;
            case "enum":
                return `'${e.value}' /* Enum */`;
            case "color":
                return `'${e.value}' /* Color */`;
            case "date":
                return `'${e.value}' /* Date */`;
            case "richtext":
                return "RichText";
            case "responsiveimage":
                return "ResponsiveImage";
            case "file":
                return "File";
            case "link":
                return ye(e.value) ? `'${e.value}' /* Link */` : "Link";
            case "object":
                return "Object";
            default:
                Ce(e)
        }
    }
};
function Gi(e, t, n) {
    if (dr(e) || dr(t))
        return A(e === t),
            0;
    switch (e.type) {
        case "array":
            {
                A(e.type === t.type);
                let r = e.value.length
                    , i = t.value.length;
                if (r < i)
                    return -1;
                if (r > i)
                    return 1;
                for (let o = 0; o < r; o++) {
                    let s = e.value[o]
                        , a = t.value[o];
                    A(!Qe(s), "Left item must exist"),
                        A(!Qe(a), "Right item must exist");
                    let l = Gi(s, a, n);
                    if (l !== 0)
                        return l
                }
                return 0
            }
        case "boolean":
            return A(e.type === t.type),
                e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
        case "color":
            return A(e.type === t.type),
                e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
        case "date":
            {
                A(e.type === t.type);
                let r = new Date(e.value)
                    , i = new Date(t.value);
                return r < i ? -1 : r > i ? 1 : 0
            }
        case "enum":
            return A(e.type === t.type),
                e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
        case "file":
            return A(e.type === t.type),
                e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
        case "link":
            {
                A(e.type === t.type);
                let r = JSON.stringify(e.value)
                    , i = JSON.stringify(t.value);
                return r < i ? -1 : r > i ? 1 : 0
            }
        case "number":
            return A(e.type === t.type),
                e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
        case "object":
            {
                A(e.type === t.type);
                let r = Object.keys(e.value).sort()
                    , i = Object.keys(t.value).sort();
                if (r.length < i.length)
                    return -1;
                if (r.length > i.length)
                    return 1;
                for (let o = 0; o < r.length; o++) {
                    let s = r[o]
                        , a = i[o];
                    if (A(!Qe(s), "Left key must exist"),
                        A(!Qe(a), "Left key must exist"),
                        s < a)
                        return -1;
                    if (s > a)
                        return 1;
                    let l = e.value[s]
                        , c = t.value[a];
                    A(!Qe(l), "Left value must exist"),
                        A(!Qe(c), "Right value must exist");
                    let u = Gi(l, c, n);
                    if (u !== 0)
                        return u
                }
                return 0
            }
        case "responsiveimage":
            {
                A(e.type === t.type);
                let r = JSON.stringify(e.value)
                    , i = JSON.stringify(t.value);
                return r < i ? -1 : r > i ? 1 : 0
            }
        case "richtext":
            {
                A(e.type === t.type);
                let r = e.value
                    , i = t.value;
                return r < i ? -1 : r > i ? 1 : 0
            }
        case "string":
            {
                A(e.type === t.type);
                let r = e.value
                    , i = t.value;
                return n.type === 0 && (r = e.value.toLowerCase(),
                    i = t.value.toLowerCase()),
                    r < i ? -1 : r > i ? 1 : 0
            }
        default:
            Ce(e)
    }
}
var ok = {
    type: "unknown",
    isNullable: !0
};
function vB() {
    return 25
}
function yB() {
    return 100 * 125
}
var Ou = 1e3
    , ce = class {
        constructor(e) {
            this.network = e
        }
        static estimate(e, t) {
            let n = vB()
                , r = yB()
                , i = e * n + t / r;
            return new ce(i)
        }
        static max(e, t) {
            let n = Math.max(e.network, t.network);
            return new ce(n)
        }
        static compare(e, t) {
            return e.network < t.network ? -1 : e.network > t.network ? 1 : 0
        }
        add(e) {
            return this.network += e.network,
                this
        }
        toString() {
            return `${this.network}ms`
        }
    }
    ;
var kT = class {
    constructor(e, t) {
        this.id = e,
            this.relational = t,
            E(this, "nodes", []),
            E(this, "winners", new Map)
    }
    addNode(e) {
        this.nodes.push(e),
            e.setGroup(this)
    }
    getWinner(e) {
        let t = e.getHash()
            , n = this.winners.get(t);
        if (n)
            return n;
        let r = new bB;
        return this.winners.set(t, r),
            r
    }
    getOptimized(e) {
        let t = this.getWinner(e);
        A(t.node, "Group not optimized");
        let n = t.node.getOptimized(e);
        return n.setGroup(this),
            n
    }
}
    , bB = class {
        constructor() {
            E(this, "node"),
                E(this, "cost", new ce(1 / 0)),
                E(this, "nodes", [])
        }
        update(e, t) {
            this.nodes.push(e),
                ce.compare(t, this.cost) < 0 && (this.node = e,
                    this.cost = t)
        }
    }
    ;
function CT(e) {
    let t = e.next();
    return A(t.done, "Generator must not yield"),
        t.value
}
async function of(e, t = e.next()) {
    for (; !t.done;) {
        let n = await t.value;
        t = e.next(n)
    }
    return t.value
}
function* Ge(e) {
    let t = {}
        , n = Object.keys(e)
        , r = [];
    for (let i of n) {
        let o = e[i];
        if (hC(o)) {
            let s = o.next();
            s.done ? t[i] = s.value : r.push(of(o, s).then(a => {
                t[i] = a
            }
            ))
        } else
            t[i] = o
    }
    return r.length > 0 && (yield Promise.all(r)),
        t
}
function* Mu(e) {
    let t = []
        , n = e.keys()
        , r = [];
    for (let i of n) {
        let o = e[i];
        if (hC(o)) {
            let s = o.next();
            s.done ? t[i] = s.value : r.push(of(o, s).then(a => {
                t[i] = a
            }
            ))
        } else
            t[i] = o
    }
    return r.length > 0 && (yield Promise.all(r)),
        t
}
var TT = class {
    constructor(e) {
        this.isSynchronous = e
    }
}
    , On = class extends TT {
        constructor() {
            super(...arguments),
                E(this, "group")
        }
        getGroup() {
            return A(this.group, "Node must be in a group"),
                this.group
        }
        setGroup(e) {
            A(!this.group, "Node is already in a group"),
                this.group = e
        }
        evaluateSync() {
            let e = this.evaluate(void 0);
            return CT(e)
        }
        evaluateAsync() {
            let e = this.evaluate(void 0);
            return of(e)
        }
    }
    ;
function xB(e) {
    return Se(e) && Un(e.getHash)
}
function de(e, ...t) {
    let n = t.map(r => {
        let i = r instanceof ET;
        A(!i, "Pass CollectionMetadata.id instead");
        let o = r instanceof Oa;
        A(!o, "Pass FieldMetadata.id instead");
        let s = r instanceof FT;
        A(!s, "Pass IndexMetadata.id instead");
        let a = r instanceof On;
        A(!a, "Pass RelationalNode.group.id instead");
        let l = r instanceof kT;
        return A(!l, "Pass Group.id instead"),
            xB(r) ? r.getHash() : JSON.stringify(r)
    }
    );
    return `${e}(${n.join(", ")})`
}
var Eg = class {
    constructor(e, t) {
        this.data = e,
            this.pointer = t,
            E(this, "cached")
    }
    resolve() {
        return this.cached ?? (this.cached = this.data.resolveRichText(this.pointer)),
            this.cached
    }
}
    , ls = "index"
    , RT = class extends Set {
        merge(e) {
            for (let t of e)
                this.add(t)
        }
        equals(e) {
            if (this === e)
                return !0;
            if (this.size !== e.size)
                return !1;
            for (let t of this)
                if (!e.has(t))
                    return !1;
            return !0
        }
        subsetOf(e) {
            if (this === e)
                return !0;
            if (this.size > e.size)
                return !1;
            for (let t of this)
                if (!e.has(t))
                    return !1;
            return !0
        }
        getHash() {
            let e = [];
            for (let t of this)
                e.push(t.id);
            return e.sort((t, n) => t - n),
                de(this.name, ...e)
        }
    }
    ;
var ET = class {
    constructor(e, t, n) {
        this.id = e,
            this.name = t,
            this.data = n,
            E(this, "indexes", new wB),
            E(this, "fields", new X)
    }
}
    ;
var FT = class {
    constructor(e, t, n, r, i, o) {
        this.id = e,
            this.data = t,
            this.collection = n,
            this.lookupNodes = r,
            this.constraint = i,
            this.ordering = o,
            E(this, "resolvedFields", new X);
        for (let s in t.schema)
            for (let a of n.fields)
                a.name === s && this.resolvedFields.add(a)
    }
}
    , wB = class extends RT {
        constructor() {
            super(...arguments),
                E(this, "name", "Indexes")
        }
    }
    ;
var Oa = class {
    constructor(e, t, n, r) {
        this.id = e,
            this.name = t,
            this.definition = n,
            this.collection = r
    }
    getValue(e) {
        A(this.name, "Can only get value of field with a name");
        let t = e.data[this.name];
        return t?.type === "richtext" ? (A(this.collection, "Rich text field must have a collection"),
        {
            type: "richtext",
            value: new Eg(this.collection.data, t.value)
        }) : t ?? null
    }
}
    , X = class extends RT {
        constructor() {
            super(...arguments),
                E(this, "name", "Fields")
        }
    }
    , pn = class {
        constructor(e, t) {
            this.ordering = e,
                this.resolvedFields = t
        }
        getHash() {
            return de("RequiredProps", this.ordering, this.resolvedFields)
        }
        get isMinimal() {
            return this.ordering.length === 0 && this.resolvedFields.size === 0
        }
        canProvide(e) {
            return this.canProvideOrdering(e) && this.canProvideResolvedFields(e)
        }
        canProvideOrdering(e) {
            return this.ordering.length === 0 ? !0 : e.canProvideOrdering(this.ordering)
        }
        canProvideResolvedFields(e) {
            return this.resolvedFields.size === 0 ? !0 : e.canProvideResolvedFields(this.resolvedFields)
        }
    }
    , gr = class {
        constructor() {
            E(this, "pointers", new Map),
                E(this, "values", new Map)
        }
        getKey() {
            let e = [];
            for (let [t, n] of this.pointers)
                e.push(`${t.id}-${n}`);
            return e.sort().join("-")
        }
        addValue(e, t) {
            this.values.set(e, t)
        }
        getValue(e) {
            return this.values.get(e) ?? null
        }
        mergeValues(e) {
            for (let [t, n] of e.values)
                this.addValue(t, n)
        }
        addPointer(e, t) {
            this.pointers.set(e, t)
        }
        getPointer(e) {
            return this.pointers.get(e)
        }
        mergePointers(e) {
            for (let [t, n] of e.pointers)
                this.addPointer(t, n)
        }
        merge(e) {
            this.mergeValues(e),
                this.mergePointers(e)
        }
    }
    , In = class {
        constructor(e, t = []) {
            this.fields = e,
                this.tuples = t
        }
        push(e) {
            this.tuples.push(e)
        }
        filter(e) {
            let t = this.tuples.filter(e);
            return new In(this.fields, t)
        }
        map(e, t) {
            let n = this.tuples.map(t);
            return new In(e, n)
        }
        sort(e) {
            let t = Array.from(this.tuples).sort(e);
            return new In(this.fields, t)
        }
        slice(e, t) {
            let n = this.tuples.slice(e, t);
            return new In(this.fields, n)
        }
        union(e) {
            let t = new X;
            for (let i of this.fields)
                e.fields.has(i) && t.add(i);
            let n = new Set
                , r = new In(t);
            for (let i of this.tuples) {
                let o = i.getKey();
                n.add(o),
                    r.push(i)
            }
            for (let i of e.tuples) {
                let o = i.getKey();
                n.has(o) || r.push(i)
            }
            return r
        }
        intersection(e) {
            let t = new X;
            for (let i of this.fields)
                e.fields.has(i) && t.add(i);
            let n = new Set
                , r = new In(t);
            for (let i of this.tuples) {
                let o = i.getKey();
                n.add(o)
            }
            for (let i of e.tuples) {
                let o = i.getKey();
                n.has(o) && r.push(i)
            }
            return r
        }
    }
    , jm = class {
        constructor(e, t) {
            this.input = e,
                this.field = t
        }
        getHash() {
            return de("ProjectionField", this.input, this.field.id)
        }
    }
    , Hm = class extends On {
        constructor(e, t, n) {
            let r = e.isSynchronous;
            for (let i of t)
                r && (r = i.input.isSynchronous);
            super(r),
                this.input = e,
                this.projections = t,
                this.passthrough = n,
                E(this, "inputGroup", this.input.getGroup())
        }
        getHash() {
            return de("RelationalProject", this.inputGroup.id, ...this.projections, this.passthrough)
        }
        getOutputFields() {
            let e = new X;
            e.merge(this.passthrough);
            for (let t of this.projections)
                e.add(t.field);
            return e
        }
        canProvideOrdering(e) {
            let t = new X;
            for (let n of this.projections)
                t.add(n.field);
            for (let { field: n } of e.fields)
                if (t.has(n))
                    return !1;
            return !0
        }
        canProvideResolvedFields() {
            return !0
        }
        getInputRequiredProps(e) {
            let t = new X(e.resolvedFields);
            for (let n of this.projections)
                t.merge(n.input.referencedFields),
                    t.delete(n.field);
            return new pn(e.ordering, t)
        }
        optimize(e, t) {
            let n = this.getInputRequiredProps(t)
                , r = e.optimizeGroup(this.inputGroup, n)
                , i = new ce(0);
            for (let o of this.projections) {
                let s = o.input.optimize(e);
                i = ce.max(i, s)
            }
            return new ce(0).add(ce.max(r, i))
        }
        getOptimized(e) {
            let t = this.getInputRequiredProps(e)
                , n = this.inputGroup.getOptimized(t)
                , r = this.projections.map(i => {
                    let o = i.input.getOptimized();
                    return new jm(o, i.field)
                }
                );
            return new Hm(n, r, this.passthrough)
        }
        *evaluate(e) {
            let t = this.getOutputFields()
                , n = yield* this.input.evaluate(e)
                , r = yield* Mu(n.tuples.map(i => Mu(this.projections.map(o => Ge({
                    field: o.field,
                    value: o.input.evaluate(e, i)
                })))));
            return n.map(t, (i, o) => {
                let s = new gr;
                s.mergePointers(i);
                for (let l of this.passthrough) {
                    let c = i.getValue(l);
                    s.addValue(l, c)
                }
                let a = r[o];
                A(a, "Projections must exist");
                for (let { field: l, value: c } of a)
                    s.addValue(l, c);
                return s
            }
            )
        }
    }
    , ps = {
        type: 0
    }
    , Ze = class extends TT {
        constructor(e, t, n) {
            super(n),
                this.referencedFields = e,
                this.referencedOuterFields = t,
                this.isSynchronous = n
        }
        evaluateSync() {
            let e = this.evaluate(void 0, void 0);
            return CT(e)
        }
        evaluateAsync() {
            let e = this.evaluate(void 0, void 0);
            return of(e)
        }
    }
    , SB = {
        type: 0
    }
    , Fg = class {
        constructor(e, t) {
            this.when = e,
                this.then = t
        }
        getHash() {
            return de("CaseCondition", this.when, this.then)
        }
    }
    , PT = class extends Ze {
        constructor(e, t, n) {
            let r = new X
                , i = new X
                , o = !0;
            e && (r.merge(e.referencedFields),
                i.merge(e.referencedOuterFields),
                o && (o = e.isSynchronous));
            for (let { when: s, then: a } of t)
                r.merge(s.referencedFields),
                    i.merge(s.referencedOuterFields),
                    o && (o = s.isSynchronous),
                    r.merge(a.referencedFields),
                    i.merge(a.referencedOuterFields),
                    o && (o = a.isSynchronous);
            n && (r.merge(n.referencedFields),
                i.merge(n.referencedOuterFields),
                o && (o = n.isSynchronous)),
                super(r, i, o),
                this.input = e,
                this.conditions = t,
                this.otherwise = n,
                E(this, "definition", {
                    type: "unknown",
                    isNullable: !0
                })
        }
        getHash() {
            return de("ScalarCase", this.input, ...this.conditions, this.otherwise)
        }
        toString() {
            let e = "CASE";
            this.input && (e = `${e} ${this.input}`);
            for (let { when: t, then: n } of this.conditions)
                e = `${e} WHEN ${t} THEN ${n}`;
            return this.otherwise && (e = `${e} ELSE ${this.otherwise}`),
                `${e} END`
        }
        optimize(e) {
            var t, n;
            (t = this.input) == null || t.optimize(e);
            for (let r of this.conditions)
                r.when.optimize(e),
                    r.then.optimize(e);
            return (n = this.otherwise) == null || n.optimize(e),
                new ce(0)
        }
        getOptimized() {
            var e, t;
            let n = (e = this.input) == null ? void 0 : e.getOptimized()
                , r = this.conditions.map(o => {
                    let s = o.when.getOptimized()
                        , a = o.then.getOptimized();
                    return new Fg(s, a)
                }
                )
                , i = (t = this.otherwise) == null ? void 0 : t.getOptimized();
            return new PT(n, r, i)
        }
        *evaluate(e, t) {
            var n, r;
            let { input: i, conditions: o, otherwise: s } = yield* Ge({
                input: ((n = this.input) == null ? void 0 : n.evaluate(e, t)) ?? null,
                conditions: Mu(this.conditions.map(a => Ge({
                    when: a.when.evaluate(e, t),
                    then: a.then.evaluate(e, t)
                }))),
                otherwise: ((r = this.otherwise) == null ? void 0 : r.evaluate(e, t)) ?? null
            });
            if (this.input) {
                for (let { when: a, then: l } of o)
                    if (Me.equal(i, a, SB))
                        return l
            } else
                for (let { when: a, then: l } of o)
                    if ($r(a))
                        return l;
            return s
        }
    }
    , Cm = class {
        constructor(e, t = "asc") {
            this.field = e,
                this.direction = t
        }
        getHash() {
            return de("OrderingField", this.field.id, this.direction)
        }
    }
    , hr = class {
        constructor(e) {
            E(this, "fields", []),
                e && this.merge(e)
        }
        get length() {
            return this.fields.length
        }
        getHash() {
            return de("Ordering", ...this.fields)
        }
        push(e) {
            this.fields.push(e)
        }
        merge(e) {
            this.fields.push(...e.fields)
        }
        equals(e) {
            return this === e ? !0 : this.length !== e.length ? !1 : this.getHash() === e.getHash()
        }
        providedByFields(e) {
            for (let { field: t } of this.fields)
                if (!e.has(t) && t.name !== ls)
                    return !1;
            return !0
        }
    }
    , Wm = class {
        constructor(e) {
            this.parent = e,
                E(this, "node"),
                E(this, "ordering"),
                E(this, "fields", [])
        }
        takeNode() {
            let e = this.node;
            return A(e, "Node is missing"),
                this.node = void 0,
                e
        }
        setNode(e) {
            A(!this.node, "Node already set"),
                this.node = e
        }
        setOrdering(e) {
            this.ordering = e
        }
        push() {
            return new Wm(this)
        }
        replace() {
            return new Wm(this.parent)
        }
        addField(e) {
            this.fields.push(e)
        }
        addFieldsFromScope(e) {
            for (let t of e.fields)
                this.addField(t)
        }
        resolveField(e, t) {
            var n;
            let r = [];
            for (let i of this.fields)
                i.name === e && (t && i.collectionName !== t || r.push(i));
            if (r.length === 1)
                return r[0];
            if (r.length > 1)
                throw new Error("Ambiguous fields");
            return (n = this.parent) == null ? void 0 : n.resolveField(e, t)
        }
        has(e) {
            var t;
            return this.fields.includes(e) ? !0 : ((t = this.parent) == null ? void 0 : t.has(e)) ?? !1
        }
        getRequiredOrdering() {
            return this.ordering ?? new hr
        }
        getRequiredResolvedFields() {
            let e = new X;
            for (let { field: t } of this.fields)
                t.collection && e.add(t);
            return e
        }
        getRequiredProps() {
            let e = this.getRequiredOrdering()
                , t = this.getRequiredResolvedFields();
            return new pn(e, t)
        }
        getNamedFields() {
            let e = {};
            for (let { name: t, field: n } of this.fields)
                e[t] = n;
            return e
        }
        getSingleField() {
            A(this.fields.length === 1, "Scope must contain exactly one field");
            let e = this.fields[0];
            return A(e, "Field must exist"),
                e.field
        }
    }
    , kB = class {
        constructor(e, t, n) {
            this.normalizer = e,
                this.query = t,
                this.locale = n,
                E(this, "collectionId", 0),
                E(this, "indexId", 0),
                E(this, "fieldId", 0),
                E(this, "subqueries", [])
        }
        build() {
            let e = new Wm;
            return this.buildQuery(e, this.query)
        }
        buildQuery(e, t) {
            let n = {
                type: "Select",
                ...t
            };
            return this.buildSelect(e, n)
        }
        buildSelect(e, t) {
            let n = this.buildFrom(e, t.from)
                , r = n.getRequiredOrdering();
            if (t.where) {
                let l = n.takeNode()
                    , c = this.buildExpression(n, t.where)
                    , u = this.normalizer.newRelationalFilter(l, c);
                n.setNode(u)
            }
            let i = [], o = new X, s;
            if (t.orderBy) {
                s = new hr;
                for (let l of t.orderBy)
                    if (l.type === "Identifier") {
                        let c = n.resolveField(l.name, l.collection);
                        if (Qe(c))
                            continue;
                        o.add(c.field);
                        let u = new Cm(c.field, l.direction);
                        s.push(u)
                    } else {
                        let c = this.buildExpression(n, l)
                            , u = this.fieldId++
                            , f = new Oa(u, void 0, c.definition, void 0)
                            , d = new jm(c, f);
                        i.push(d);
                        let p = new Cm(f, l.direction);
                        s.push(p)
                    }
                s.merge(r)
            } else
                s = r;
            let a = this.buildSelectList(n, t.select, o, i);
            if (a.setOrdering(s),
                t.offset) {
                let l = a.takeNode()
                    , c = this.buildExpression(e, t.offset)
                    , u = this.normalizer.newRelationalOffset(l, c, s);
                a.setNode(u)
            }
            if (t.limit) {
                let l = a.takeNode()
                    , c = this.buildExpression(e, t.limit)
                    , u = this.normalizer.newRelationalLimit(l, c, s);
                a.setNode(u)
            }
            return a
        }
        buildSelectList(e, t, n, r) {
            let i = e.push()
                , o = new X(n)
                , s = [...r];
            for (let c of t)
                if (c.type === "Identifier") {
                    let u = e.resolveField(c.name, c.collection);
                    if (Qe(u))
                        continue;
                    o.add(u.field),
                        i.addField({
                            ...u,
                            name: c.alias ?? u.name
                        })
                } else {
                    let u = this.buildExpression(e, c);
                    A(c.alias, "Subqueries should have an alias");
                    let f = this.fieldId++
                        , d = c.alias
                        , p = new Oa(f, d, u.definition, void 0)
                        , v = new jm(u, p);
                    s.push(v),
                        i.addField({
                            field: p,
                            name: d
                        })
                }
            let a = e.takeNode()
                , l = this.normalizer.newRelationalProject(a, s, o);
            return i.setNode(l),
                i
        }
        buildFrom(e, t) {
            switch (t.type) {
                case "Collection":
                    return this.buildCollection(e, t);
                case "LeftJoin":
                    return this.buildJoin(e, t);
                default:
                    Ce(t, "Unsupported from type")
            }
        }
        buildCollection(e, t) {
            let n = e.push()
                , r = CB(t.data, this.locale)
                , i = t.alias
                , o = this.collectionId++
                , s = new ET(o, i, r);
            for (let [l, c] of Object.entries(r.schema)) {
                let u = this.fieldId++
                    , f = new Oa(u, l, c, s);
                n.addField({
                    field: f,
                    name: l,
                    collectionName: i
                }),
                    s.fields.add(f)
            }
            {
                let l = {
                    type: "number",
                    isNullable: !1
                }
                    , c = this.fieldId++
                    , u = new Oa(c, ls, l, s);
                n.addField({
                    field: u,
                    name: ls,
                    collectionName: i
                });
                let f = new hr
                    , d = new Cm(u);
                f.push(d),
                    n.setOrdering(f)
            }
            for (let l of r.indexes) {
                let c = [];
                for (let v of l.fields) {
                    let g = this.buildExpression(n, v);
                    c.push(g)
                }
                let u;
                l.where && (u = this.buildExpression(n, l.where));
                let f = new hr
                    , d = this.indexId++
                    , p = new FT(d, l, s, c, u, f);
                s.indexes.add(p)
            }
            let a = this.normalizer.newRelationalScan(s);
            return n.setNode(a),
                n
        }
        buildJoin(e, t) {
            let n = this.buildFrom(e, t.left)
                , r = this.buildFrom(e, t.right)
                , i = new hr
                , o = n.getRequiredOrdering();
            i.merge(o);
            let s = r.getRequiredOrdering();
            i.merge(s);
            let a = e.push();
            a.addFieldsFromScope(n),
                a.addFieldsFromScope(r),
                a.setOrdering(i);
            let l = this.buildExpression(a, t.constraint), c = n.takeNode(), u = r.takeNode(), f;
            switch (t.type) {
                case "LeftJoin":
                    f = this.normalizer.newRelationalLeftJoin(c, u, l);
                    break;
                default:
                    Ce(t.type, "Unsupported join type")
            }
            return a.setNode(f),
                a
        }
        buildExpression(e, t) {
            switch (t.type) {
                case "Identifier":
                    return this.buildIdentifier(e, t);
                case "LiteralValue":
                    return this.buildLiteralValue(t);
                case "FunctionCall":
                    return this.buildFunctionCall(e, t);
                case "Case":
                    return this.buildCase(e, t);
                case "UnaryOperation":
                    return this.buildUnaryOperation(e, t);
                case "BinaryOperation":
                    return this.buildBinaryOperation(e, t);
                case "TypeCast":
                    return this.buildTypeCast(e, t);
                case "Select":
                    throw new Error("Subqueries are only supported inside subquery function calls");
                default:
                    Ce(t, "Unsupported expression")
            }
        }
        buildIdentifier(e, t) {
            let n = e.resolveField(t.name, t.collection);
            if (n) {
                let r = !1;
                for (let i of this.subqueries)
                    r ? i.referencedOuterFields.add(n.field) : (r = i.inScope.has(n),
                        r && i.referencedFields.add(n.field));
                return this.normalizer.newScalarVariable(n.field, r)
            }
            return this.normalizer.newScalarConstant(ok, null)
        }
        buildLiteralValue(e) {
            let t = Me.parse(e.value);
            return this.normalizer.newScalarConstant(ok, t)
        }
        buildFunctionCall(e, t) {
            let n = r => {
                let i = t.arguments[r];
                return A(i, "Missing argument"),
                    this.buildExpression(e, i)
            }
                ;
            switch (t.functionName) {
                case "CONTAINS":
                    {
                        let r = n(0)
                            , i = n(1);
                        return this.normalizer.newScalarContains(r, i)
                    }
                case "STARTS_WITH":
                    {
                        let r = n(0)
                            , i = n(1);
                        return this.normalizer.newScalarStartsWith(r, i)
                    }
                case "ENDS_WITH":
                    {
                        let r = n(0)
                            , i = n(1);
                        return this.normalizer.newScalarEndsWith(r, i)
                    }
                case "LENGTH":
                    {
                        let r = n(0);
                        return this.normalizer.newScalarLength(r)
                    }
                case "INDEX_OF":
                    {
                        let r = n(0)
                            , i = n(1);
                        return this.normalizer.newScalarIndexOf(r, i)
                    }
                case "ARRAY":
                    {
                        let r = t.arguments[0];
                        return A(r, "Missing argument"),
                            A(r.type === "Select", "Subqueries require a select expression"),
                            this.buildSubqueryArray(e, r)
                    }
                case "FLAT_ARRAY":
                    {
                        let r = t.arguments[0];
                        return A(r, "Missing argument"),
                            A(r.type === "Select", "Subqueries require a select expression"),
                            this.buildSubqueryFlatArray(e, r)
                    }
                default:
                    throw new Error("Unsupported function name")
            }
        }
        buildSubqueryArray(e, t) {
            try {
                let n = new sk(e);
                this.subqueries.push(n);
                let r = this.buildSelect(e, t)
                    , i = r.takeNode()
                    , o = r.getNamedFields()
                    , s = r.getRequiredOrdering()
                    , a = n.referencedFields
                    , l = n.referencedOuterFields;
                return this.normalizer.newScalarArray(i, o, s, a, l)
            } finally {
                this.subqueries.pop()
            }
        }
        buildSubqueryFlatArray(e, t) {
            try {
                let n = new sk(e);
                this.subqueries.push(n);
                let r = this.buildSelect(e, t)
                    , i = r.takeNode()
                    , o = r.getSingleField()
                    , s = r.getRequiredOrdering()
                    , a = n.referencedFields
                    , l = n.referencedOuterFields;
                return this.normalizer.newScalarFlatArray(i, o, s, a, l)
            } finally {
                this.subqueries.pop()
            }
        }
        buildCase(e, t) {
            let n;
            t.value && (n = this.buildExpression(e, t.value));
            let r = t.conditions.map(o => {
                let s = this.buildExpression(e, o.when)
                    , a = this.buildExpression(e, o.then);
                return new Fg(s, a)
            }
            ), i;
            return t.else && (i = this.buildExpression(e, t.else)),
                this.normalizer.newScalarCase(n, r, i)
        }
        buildUnaryOperation(e, t) {
            let n = this.buildExpression(e, t.value);
            switch (t.operator) {
                case "not":
                    return this.normalizer.newScalarNot(n);
                default:
                    Ce(t.operator, "Unsupported unary operator")
            }
        }
        buildBinaryOperation(e, t) {
            let n = this.buildExpression(e, t.left)
                , r = this.buildExpression(e, t.right);
            switch (t.operator) {
                case "and":
                    return this.normalizer.newScalarAnd(n, r);
                case "or":
                    return this.normalizer.newScalarOr(n, r);
                case "==":
                    return this.normalizer.newScalarEquals(n, r);
                case "!=":
                    return this.normalizer.newScalarNotEquals(n, r);
                case "<":
                    return this.normalizer.newScalarLessThan(n, r);
                case "<=":
                    return this.normalizer.newScalarLessThanOrEqual(n, r);
                case ">":
                    return this.normalizer.newScalarGreaterThan(n, r);
                case ">=":
                    return this.normalizer.newScalarGreaterThanOrEqual(n, r);
                case "in":
                    return this.normalizer.newScalarIn(n, r);
                default:
                    Ce(t.operator, "Unsupported binary operator")
            }
        }
        buildTypeCast(e, t) {
            let n = this.buildExpression(e, t.value);
            switch (t.dataType) {
                case "BOOLEAN":
                    {
                        let r = {
                            type: "boolean",
                            isNullable: !0
                        };
                        return this.normalizer.newScalarCast(n, r)
                    }
                case "DATE":
                    {
                        let r = {
                            type: "date",
                            isNullable: !0
                        };
                        return this.normalizer.newScalarCast(n, r)
                    }
                case "NUMBER":
                    {
                        let r = {
                            type: "number",
                            isNullable: !0
                        };
                        return this.normalizer.newScalarCast(n, r)
                    }
                case "STRING":
                    {
                        let r = {
                            type: "string",
                            isNullable: !0
                        };
                        return this.normalizer.newScalarCast(n, r)
                    }
                default:
                    throw new Error("Unsupported data type")
            }
        }
    }
    ;
function CB(e, t) {
    if (vT(e))
        return new aB(e, t);
    if (Rg(e))
        return e;
    if (yT(e)) {
        for (; t;) {
            let n = e.collectionByLocaleId[t.id];
            if (n)
                return n;
            t = t.fallback
        }
        return e.collectionByLocaleId.default
    }
    Ce(e, "Unsupported collection type")
}
var sk = class {
    constructor(e) {
        this.inScope = e,
            E(this, "referencedFields", new X),
            E(this, "referencedOuterFields", new X)
    }
}
    , Lu = class extends On {
        constructor(e, t) {
            super(e.isSynchronous && t.isSynchronous),
                this.input = e,
                this.predicate = t,
                E(this, "inputGroup", this.input.getGroup())
        }
        getHash() {
            return de("RelationalFilter", this.inputGroup.id, this.predicate)
        }
        getOutputFields() {
            return this.inputGroup.relational.outputFields
        }
        canProvideOrdering() {
            return !0
        }
        canProvideResolvedFields() {
            return !0
        }
        getInputRequiredProps(e) {
            let t = new X(e.resolvedFields);
            return t.merge(this.predicate.referencedFields),
                new pn(e.ordering, t)
        }
        optimize(e, t) {
            let n = this.getInputRequiredProps(t)
                , r = e.optimizeGroup(this.inputGroup, n)
                , i = this.predicate.optimize(e);
            return new ce(0).add(ce.max(r, i))
        }
        getOptimized(e) {
            let t = this.getInputRequiredProps(e)
                , n = this.inputGroup.getOptimized(t)
                , r = this.predicate.getOptimized();
            return new Lu(n, r)
        }
        *evaluate(e) {
            let t = yield* this.input.evaluate(e)
                , n = yield* Mu(t.tuples.map(r => this.predicate.evaluate(e, r)));
            return t.filter((r, i) => {
                let o = n[i] ?? null;
                return $r(o)
            }
            )
        }
    }
    , Pn = class extends On {
        constructor(e, t) {
            super(!1),
                this.index = e,
                this.query = t
        }
        getHash() {
            return de("RelationalIndexLookup", this.index.id, ...this.query)
        }
        getOutputFields() {
            return this.index.collection.fields
        }
        canProvideOrdering(e) {
            return e.equals(this.index.ordering)
        }
        canProvideResolvedFields(e) {
            return e.subsetOf(this.index.resolvedFields)
        }
        optimize() {
            let e = this.query.every(t => t.type === "All");
            return ce.estimate(1, e ? 100 * Ou : 50 * Ou)
        }
        getOptimized() {
            return new Pn(this.index, this.query)
        }
        *evaluate() {
            let e = this.index
                , t = e.collection
                , n = this.getOutputFields()
                , i = (yield e.data.lookupItems(this.query)).map(o => {
                    let s = new gr;
                    for (let a of e.resolvedFields) {
                        let l = a.getValue(o);
                        s.addPointer(t, o.pointer),
                            s.addValue(a, l)
                    }
                    return s
                }
                );
            return new In(n, i)
        }
    }
    , _T = class extends On {
        constructor(e, t) {
            super(e.isSynchronous && t.isSynchronous),
                this.left = e,
                this.right = t,
                E(this, "leftGroup", this.left.getGroup()),
                E(this, "rightGroup", this.right.getGroup())
        }
        getHash() {
            return de("RelationalIntersection", this.leftGroup.id, this.rightGroup.id)
        }
        getOutputFields() {
            let e = new X
                , t = this.leftGroup.relational.outputFields
                , n = this.rightGroup.relational.outputFields;
            for (let r of t)
                n.has(r) && e.add(r);
            return e
        }
        canProvideOrdering() {
            return !1
        }
        canProvideResolvedFields() {
            return !0
        }
        getChildRequiredProps(e) {
            let t = new hr;
            return new pn(t, e.resolvedFields)
        }
        optimize(e, t) {
            let n = this.getChildRequiredProps(t)
                , r = e.optimizeGroup(this.leftGroup, n)
                , i = this.getChildRequiredProps(t)
                , o = e.optimizeGroup(this.rightGroup, i);
            return ce.max(r, o)
        }
        getOptimized(e) {
            let t = this.getChildRequiredProps(e)
                , n = this.leftGroup.getOptimized(t)
                , r = this.getChildRequiredProps(e)
                , i = this.rightGroup.getOptimized(r);
            return new _T(n, i)
        }
        *evaluate(e) {
            let { left: t, right: n } = yield* Ge({
                left: this.left.evaluate(e),
                right: this.right.evaluate(e)
            });
            return t.intersection(n)
        }
    }
    , cs = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarEquals", this.left, this.right)
        }
        toString() {
            return `${this.left} == ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new cs(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.equal(n, r, ps)
            }
        }
    }
    , Vu = class extends On {
        constructor(e, t, n) {
            super(e.isSynchronous && t.isSynchronous && n.isSynchronous),
                this.left = e,
                this.right = t,
                this.constraint = n,
                E(this, "leftGroup", this.left.getGroup()),
                E(this, "rightGroup", this.right.getGroup())
        }
        getHash() {
            return de("RelationalLeftJoin", this.leftGroup.id, this.rightGroup.id, this.constraint)
        }
        getOutputFields() {
            let e = new X;
            return e.merge(this.leftGroup.relational.outputFields),
                e.merge(this.rightGroup.relational.outputFields),
                e
        }
        canProvideOrdering() {
            return !1
        }
        canProvideResolvedFields() {
            return !0
        }
        getChildRequiredProps(e, t) {
            let n = new X
                , r = e.relational.outputFields;
            for (let o of t.resolvedFields)
                r.has(o) && n.add(o);
            for (let o of this.constraint.referencedFields)
                r.has(o) && n.add(o);
            let i = new hr;
            return new pn(i, n)
        }
        optimize(e, t) {
            let n = this.getChildRequiredProps(this.leftGroup, t)
                , r = e.optimizeGroup(this.leftGroup, n)
                , i = this.getChildRequiredProps(this.rightGroup, t)
                , o = e.optimizeGroup(this.rightGroup, i)
                , s = this.constraint.optimize(e);
            return ce.max(ce.max(r, o), s)
        }
        getOptimized(e) {
            let t = this.getChildRequiredProps(this.leftGroup, e)
                , n = this.leftGroup.getOptimized(t)
                , r = this.getChildRequiredProps(this.rightGroup, e)
                , i = this.rightGroup.getOptimized(r)
                , o = this.constraint.getOptimized();
            return new Vu(n, i, o)
        }
        *evaluateScalarEquals(e, t, n, r, i) {
            let o = new Map;
            for (let l of t.tuples) {
                let c = yield* r.evaluate(i, l)
                    , u = JSON.stringify(c?.value ?? null)
                    , f = o.get(u) ?? [];
                f.push(l),
                    o.set(u, f)
            }
            let s = this.getOutputFields()
                , a = new In(s);
            for (let l of e.tuples) {
                let c = yield* n.evaluate(i, l)
                    , u = JSON.stringify(c?.value ?? null)
                    , f = o.get(u) ?? [];
                if (f.length === 0)
                    a.push(l);
                else
                    for (let d of f) {
                        let p = new gr;
                        p.merge(l),
                            p.merge(d),
                            a.push(p)
                    }
            }
            return a
        }
        *evaluate(e) {
            let { left: t, right: n } = yield* Ge({
                left: this.left.evaluate(e),
                right: this.right.evaluate(e)
            });
            if (this.constraint instanceof cs) {
                if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                    return yield* this.evaluateScalarEquals(t, n, this.constraint.left, this.constraint.right, e);
                if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                    return yield* this.evaluateScalarEquals(t, n, this.constraint.right, this.constraint.left, e)
            }
            let r = this.getOutputFields()
                , i = new In(r);
            for (let o of t.tuples) {
                let s = !1;
                for (let a of n.tuples) {
                    let l = new gr;
                    l.merge(o),
                        l.merge(a);
                    let c = yield* this.constraint.evaluate(e, l);
                    $r(c) && (i.push(l),
                        s = !0)
                }
                s || i.push(o)
            }
            return i
        }
    }
    , Pg = class extends On {
        constructor(e, t, n) {
            super(e.isSynchronous && t.isSynchronous && n.isSynchronous),
                this.left = e,
                this.right = t,
                this.constraint = n,
                E(this, "leftGroup", this.left.getGroup()),
                E(this, "rightGroup", this.right.getGroup())
        }
        getHash() {
            return de("RelationalRightJoin", this.leftGroup.id, this.rightGroup.id, this.constraint)
        }
        getOutputFields() {
            let e = new X;
            return e.merge(this.leftGroup.relational.outputFields),
                e.merge(this.rightGroup.relational.outputFields),
                e
        }
        canProvideOrdering() {
            return !1
        }
        canProvideResolvedFields() {
            return !0
        }
        getChildRequiredProps(e, t) {
            let n = new X
                , r = e.relational.outputFields;
            for (let o of t.resolvedFields)
                r.has(o) && n.add(o);
            for (let o of this.constraint.referencedFields)
                r.has(o) && n.add(o);
            let i = new hr;
            return new pn(i, n)
        }
        optimize(e, t) {
            let n = this.getChildRequiredProps(this.leftGroup, t)
                , r = e.optimizeGroup(this.leftGroup, n)
                , i = this.getChildRequiredProps(this.rightGroup, t)
                , o = e.optimizeGroup(this.rightGroup, i)
                , s = this.constraint.optimize(e);
            return ce.max(ce.max(r, o), s)
        }
        getOptimized(e) {
            let t = this.getChildRequiredProps(this.leftGroup, e)
                , n = this.leftGroup.getOptimized(t)
                , r = this.getChildRequiredProps(this.rightGroup, e)
                , i = this.rightGroup.getOptimized(r)
                , o = this.constraint.getOptimized();
            return new Pg(n, i, o)
        }
        *evaluateScalarEquals(e, t, n, r, i) {
            let o = new Map;
            for (let l of e.tuples) {
                let c = yield* n.evaluate(i, l)
                    , u = JSON.stringify(c?.value ?? null)
                    , f = o.get(u) ?? [];
                f.push(l),
                    o.set(u, f)
            }
            let s = this.getOutputFields()
                , a = new In(s);
            for (let l of t.tuples) {
                let c = yield* r.evaluate(i, l)
                    , u = JSON.stringify(c?.value ?? null)
                    , f = o.get(u) ?? [];
                if (f.length === 0)
                    a.push(l);
                else
                    for (let d of f) {
                        let p = new gr;
                        p.merge(l),
                            p.merge(d),
                            a.push(p)
                    }
            }
            return a
        }
        *evaluate(e) {
            let { left: t, right: n } = yield* Ge({
                left: this.left.evaluate(e),
                right: this.right.evaluate(e)
            });
            if (this.constraint instanceof cs) {
                if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                    return yield* this.evaluateScalarEquals(t, n, this.constraint.left, this.constraint.right, e);
                if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                    return yield* this.evaluateScalarEquals(t, n, this.constraint.right, this.constraint.left, e)
            }
            let r = this.getOutputFields()
                , i = new In(r);
            for (let o of n.tuples) {
                let s = !1;
                for (let a of t.tuples) {
                    let l = new gr;
                    l.merge(o),
                        l.merge(a);
                    let c = yield* this.constraint.evaluate(e, l);
                    $r(c) && (i.push(l),
                        s = !0)
                }
                s || i.push(o)
            }
            return i
        }
    }
    , Au = class extends On {
        constructor(e) {
            super(!1),
                this.collection = e
        }
        getHash() {
            return de("RelationalScan", this.collection.id)
        }
        getOutputFields() {
            return this.collection.fields
        }
        canProvideOrdering() {
            return !1
        }
        canProvideResolvedFields(e) {
            return e.subsetOf(this.collection.fields)
        }
        optimize() {
            return ce.estimate(1, 200 * Ou)
        }
        getOptimized() {
            return new Au(this.collection)
        }
        *evaluate() {
            let e = this.collection
                , t = this.getOutputFields()
                , r = (yield e.data.scanItems()).map(i => {
                    let o = new gr;
                    for (let s of t) {
                        let a = s.getValue(i);
                        o.addPointer(e, i.pointer),
                            o.addValue(s, a)
                    }
                    return o
                }
                );
            return new In(t, r)
        }
    }
    , IT = class extends On {
        constructor(e, t) {
            super(e.isSynchronous && t.isSynchronous),
                this.left = e,
                this.right = t,
                E(this, "leftGroup", this.left.getGroup()),
                E(this, "rightGroup", this.right.getGroup())
        }
        getHash() {
            return de("RelationalUnion", this.leftGroup.id, this.rightGroup.id)
        }
        getOutputFields() {
            let e = new X
                , t = this.leftGroup.relational.outputFields
                , n = this.rightGroup.relational.outputFields;
            for (let r of t)
                n.has(r) && e.add(r);
            return e
        }
        canProvideOrdering() {
            return !1
        }
        canProvideResolvedFields() {
            return !0
        }
        getChildRequiredProps(e) {
            let t = new hr;
            return new pn(t, e.resolvedFields)
        }
        optimize(e, t) {
            let n = this.getChildRequiredProps(t)
                , r = e.optimizeGroup(this.leftGroup, n)
                , i = this.getChildRequiredProps(t)
                , o = e.optimizeGroup(this.rightGroup, i);
            return ce.max(r, o)
        }
        getOptimized(e) {
            let t = this.getChildRequiredProps(e)
                , n = this.leftGroup.getOptimized(t)
                , r = this.getChildRequiredProps(e)
                , i = this.rightGroup.getOptimized(r);
            return new IT(n, i)
        }
        *evaluate(e) {
            let { left: t, right: n } = yield* Ge({
                left: this.left.evaluate(e),
                right: this.right.evaluate(e)
            });
            return t.union(n)
        }
    }
    , Du = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarAnd", this.left, this.right)
        }
        toString() {
            return `${this.left} && ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new Du(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: $r(n) && $r(r)
            }
        }
    }
    , Hn = class extends Ze {
        constructor(e, t) {
            let n = new X
                , r = new X;
            super(n, r, !0),
                this.definition = e,
                this.value = t
        }
        getHash() {
            return de("ScalarConstant", this.definition, this.value)
        }
        toString() {
            return Me.stringify(this.value)
        }
        optimize() {
            return new ce(0)
        }
        getOptimized() {
            return this
        }
        *evaluate() {
            return this.value
        }
    }
    , TB = {
        type: 0
    }
    , _g = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.source = e,
                this.target = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarContains", this.source, this.target)
        }
        toString() {
            return `CONTAINS(${this.source}, ${this.target})`
        }
        optimize(e) {
            let t = this.source.optimize(e)
                , n = this.target.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.source.getOptimized()
                , t = this.target.getOptimized();
            return new _g(e, t)
        }
        *evaluate(e, t) {
            let { source: n, target: r } = yield* Ge({
                source: this.source.evaluate(e, t),
                target: this.target.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.contains(n, r, TB)
            }
        }
    }
    , RB = {
        type: 0
    }
    , Ig = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.source = e,
                this.target = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarEndsWith", this.source, this.target)
        }
        toString() {
            return `ENDS_WITH(${this.source}, ${this.target})`
        }
        optimize(e) {
            let t = this.source.optimize(e)
                , n = this.target.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.source.getOptimized()
                , t = this.target.getOptimized();
            return new Ig(e, t)
        }
        *evaluate(e, t) {
            let { source: n, target: r } = yield* Ge({
                source: this.source.evaluate(e, t),
                target: this.target.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.endsWith(n, r, RB)
            }
        }
    }
    , zu = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarGreaterThan", this.left, this.right)
        }
        toString() {
            return `${this.left} > ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new zu(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.greaterThan(n, r, ps)
            }
        }
    }
    , Bu = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarGreaterThanOrEqual", this.left, this.right)
        }
        toString() {
            return `${this.left} >= ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new Bu(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.greaterThanOrEqual(n, r, ps)
            }
        }
    }
    , $u = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarLessThan", this.left, this.right)
        }
        toString() {
            return `${this.left} < ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new $u(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.lessThan(n, r, ps)
            }
        }
    }
    , Nu = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarLessThanOrEqual", this.left, this.right)
        }
        toString() {
            return `${this.left} <= ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new Nu(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.lessThanOrEqual(n, r, ps)
            }
        }
    }
    , ju = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarNotEquals", this.left, this.right)
        }
        toString() {
            return `${this.left} != ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new ju(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: !Me.equal(n, r, ps)
            }
        }
    }
    , Hu = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarOr", this.left, this.right)
        }
        toString() {
            return `${this.left} || ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new Hu(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: $r(n) || $r(r)
            }
        }
    }
    , EB = {
        type: 0
    }
    , Og = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.source = e,
                this.target = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarStartsWith", this.source, this.target)
        }
        toString() {
            return `STARTS_WITH(${this.source}, ${this.target})`
        }
        optimize(e) {
            let t = this.source.optimize(e)
                , n = this.target.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.source.getOptimized()
                , t = this.target.getOptimized();
            return new Og(e, t)
        }
        *evaluate(e, t) {
            let { source: n, target: r } = yield* Ge({
                source: this.source.evaluate(e, t),
                target: this.target.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.startsWith(n, r, EB)
            }
        }
    }
    , FB = class {
        constructor(e) {
            this.normalizer = e,
                E(this, "memo", this.normalizer.memo)
        }
        explore(e) {
            let t = e.getGroup();
            if (e instanceof Vu) {
                let n = new Pg(e.right, e.left, e.constraint);
                this.memo.addRelational(n, t)
            }
            if (e instanceof Lu) {
                if (e.predicate instanceof Du) {
                    let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left)
                        , r = this.normalizer.newRelationalFilter(e.input, e.predicate.right)
                        , i = new _T(n, r);
                    this.memo.addRelational(i, t)
                }
                if (e.predicate instanceof Hu) {
                    let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left)
                        , r = this.normalizer.newRelationalFilter(e.input, e.predicate.right)
                        , i = new IT(n, r);
                    this.memo.addRelational(i, t)
                }
            }
            if (e instanceof Au)
                for (let n of e.collection.indexes) {
                    if (n.constraint)
                        continue;
                    let r = fr(n.lookupNodes.length)
                        , i = new Pn(n, r);
                    this.memo.addRelational(i, t)
                }
            if (e instanceof Lu) {
                for (let n of e.inputGroup.nodes)
                    if (n instanceof Au)
                        for (let r of n.collection.indexes) {
                            if (e.predicate instanceof cs && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("Equals")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "Equals",
                                    value: e.predicate.right.value
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof ju && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("NotEquals")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "NotEquals",
                                    value: e.predicate.right.value
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof $u && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("LessThan")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "LessThan",
                                    value: e.predicate.right.value,
                                    inclusive: !1
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof Nu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("LessThan")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "LessThan",
                                    value: e.predicate.right.value,
                                    inclusive: !0
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof zu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("GreaterThan")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "GreaterThan",
                                    value: e.predicate.right.value,
                                    inclusive: !1
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof Bu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Hn && r.data.supportedLookupTypes.includes("GreaterThan")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "GreaterThan",
                                    value: e.predicate.right.value,
                                    inclusive: !0
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof _g && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Hn && r.data.supportedLookupTypes.includes("Contains")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "Contains",
                                    value: e.predicate.target.value
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof Og && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Hn && r.data.supportedLookupTypes.includes("StartsWith")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "StartsWith",
                                    value: e.predicate.target.value
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                            if (e.predicate instanceof Ig && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Hn && r.data.supportedLookupTypes.includes("EndsWith")) {
                                let i = fr(r.lookupNodes.length);
                                i[0] = {
                                    type: "EndsWith",
                                    value: e.predicate.target.value
                                };
                                let o = new Pn(r, i);
                                this.memo.addRelational(o, t)
                            }
                        }
            }
        }
    }
    ;
function fr(e) {
    let t = {
        type: "All"
    };
    return new Array(e).fill(t)
}
var PB = class {
    constructor(e) {
        this.outputFields = e
    }
    isCompatible(e) {
        return this.outputFields.equals(e.outputFields)
    }
}
    , _B = class {
        constructor() {
            E(this, "nodes", new Map),
                E(this, "groups", [])
        }
        addGroup(e) {
            let t = this.groups.length
                , n = new kT(t, e);
            return this.groups.push(n),
                n
        }
        addRelational(e, t) {
            let n = e.getHash()
                , r = this.nodes.get(n);
            if (r)
                return r;
            this.nodes.set(n, e);
            let i = e.getOutputFields()
                , o = new PB(i);
            return t ?? (t = this.addGroup(o)),
                t.addNode(e),
                A(o.isCompatible(t.relational), "Group has inconsistent relational props"),
                e
        }
        addScalar(e) {
            let t = e.getHash()
                , n = this.nodes.get(t);
            return n || (this.nodes.set(t, e),
                e)
        }
    }
    , OT = class extends On {
    }
    , MT = class extends OT {
        constructor(e, t) {
            super(!1),
                this.input = e,
                this.fields = t,
                E(this, "inputGroup", this.input.getGroup())
        }
        getHash() {
            return de("EnforcerResolve", this.inputGroup.id, this.fields)
        }
        getOutputFields() {
            return this.inputGroup.relational.outputFields
        }
        canProvideOrdering() {
            return !0
        }
        canProvideResolvedFields(e) {
            return e.subsetOf(this.fields)
        }
        getInputRequiredProps(e) {
            let t = new X;
            return new pn(e.ordering, t)
        }
        optimize(e, t) {
            let n = this.getInputRequiredProps(t)
                , r = e.optimizeGroup(this.inputGroup, n);
            return ce.estimate(0, 100 * Ou).add(r)
        }
        getOptimized(e) {
            let t = this.getInputRequiredProps(e)
                , n = this.inputGroup.getOptimized(t);
            return new MT(n, this.fields)
        }
        *evaluate(e) {
            let t = yield* this.input.evaluate(e);
            A(this.fields.subsetOf(t.fields), "Fields can't be resolved");
            let n = new Set;
            for (let i of this.fields)
                A(i.collection, "Collection required to resolve field"),
                    n.add(i.collection);
            for (let i of t.tuples)
                for (let o of this.fields) {
                    let s = i.getValue(o);
                    s?.type === "richtext" && (A(s.value instanceof Eg, "Pointer must be wrapped"),
                        s.value.resolve())
                }
            let r = yield Promise.all(Array.from(n).map(async i => {
                let o = [];
                for (let a of t.tuples) {
                    let l = a.getPointer(i);
                    l && o.push(l)
                }
                let s = await i.data.resolveItems(o);
                return A(s.length === o.length, "Invalid number of items"),
                    [i, s]
            }
            ));
            return t.map(t.fields, i => {
                let o = new gr;
                o.merge(i);
                for (let [s, a] of r) {
                    let l = i.getPointer(s);
                    if (!l)
                        continue;
                    let c = a.shift();
                    A(c, "Item not found"),
                        A(c.pointer === l, "Pointer mismatch");
                    for (let u of s.fields) {
                        let f = u.getValue(c);
                        o.addValue(u, f)
                    }
                }
                return o
            }
            )
        }
    }
    , Tm = {
        type: 0
    }
    , LT = class extends OT {
        constructor(e, t) {
            super(e.isSynchronous),
                this.input = e,
                this.ordering = t,
                E(this, "inputGroup", this.input.getGroup())
        }
        getHash() {
            return de("EnforcerSort", this.inputGroup.id, this.ordering)
        }
        getOutputFields() {
            return this.inputGroup.relational.outputFields
        }
        canProvideOrdering(e) {
            return e.equals(this.ordering)
        }
        canProvideResolvedFields() {
            return !0
        }
        getInputRequiredProps(e) {
            let t = new X(e.resolvedFields);
            for (let { field: r } of this.ordering.fields)
                r.name !== ls && (Qe(r.collection) || t.add(r));
            let n = new hr;
            return new pn(n, t)
        }
        optimize(e, t) {
            let n = this.getInputRequiredProps(t)
                , r = e.optimizeGroup(this.inputGroup, n);
            return new ce(0).add(r)
        }
        getOptimized(e) {
            let t = this.getInputRequiredProps(e)
                , n = this.inputGroup.getOptimized(t);
            return new LT(n, this.ordering)
        }
        *evaluate(e) {
            return (yield* this.input.evaluate(e)).sort((n, r) => {
                for (let { field: i, direction: o } of this.ordering.fields) {
                    let s = o === "asc";
                    if (i.name === ls) {
                        let c = i.collection;
                        A(c, "Collection required for sorting");
                        let u = n.getPointer(c);
                        A(u, "Pointer required for sorting");
                        let f = {
                            pointer: u,
                            data: {}
                        }
                            , d = r.getPointer(c);
                        A(d, "Pointer required for sorting");
                        let p = {
                            pointer: d,
                            data: {}
                        }
                            , v = c.data.compareItems(f, p);
                        return s ? v : -v
                    }
                    let a = n.getValue(i)
                        , l = r.getValue(i);
                    if (!Me.equal(a, l, Tm)) {
                        if (dr(a) || Me.lessThan(a, l, Tm))
                            return s ? -1 : 1;
                        if (dr(l) || Me.greaterThan(a, l, Tm))
                            return s ? 1 : -1;
                        throw new Error("Invalid comparison")
                    }
                }
                return 0
            }
            )
        }
    }
    ;
var VT = class extends On {
    constructor(e, t, n) {
        super(e.isSynchronous && t.isSynchronous),
            this.input = e,
            this.limit = t,
            this.ordering = n,
            E(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return de("RelationalLimit", this.inputGroup.id, this.limit)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering(e) {
        return e.equals(this.ordering)
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new X(e.resolvedFields);
        return t.merge(this.limit.referencedFields),
            new pn(this.ordering, t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
            , r = e.optimizeGroup(this.inputGroup, n)
            , i = this.limit.optimize(e);
        return new ce(0).add(ce.max(r, i))
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
            , n = this.inputGroup.getOptimized(t)
            , r = this.limit.getOptimized();
        return new VT(n, r, this.ordering)
    }
    *evaluate(e) {
        let { input: t, limit: n } = yield* Ge({
            input: this.input.evaluate(e),
            limit: this.limit.evaluate(e, void 0)
        })
            , r = wT(n) ?? 1 / 0;
        return r === 1 / 0 ? t : t.slice(0, r)
    }
}
    , AT = class extends On {
        constructor(e, t, n) {
            super(e.isSynchronous && t.isSynchronous),
                this.input = e,
                this.offset = t,
                this.ordering = n,
                E(this, "inputGroup", this.input.getGroup())
        }
        getHash() {
            return de("RelationalOffset", this.inputGroup.id, this.offset)
        }
        getOutputFields() {
            return this.inputGroup.relational.outputFields
        }
        canProvideOrdering(e) {
            return e.equals(this.ordering)
        }
        canProvideResolvedFields() {
            return !0
        }
        getInputRequiredProps(e) {
            let t = new X(e.resolvedFields);
            return t.merge(this.offset.referencedFields),
                new pn(this.ordering, t)
        }
        optimize(e, t) {
            let n = this.getInputRequiredProps(t)
                , r = e.optimizeGroup(this.inputGroup, n)
                , i = this.offset.optimize(e);
            return new ce(0).add(ce.max(r, i))
        }
        getOptimized(e) {
            let t = this.getInputRequiredProps(e)
                , n = this.inputGroup.getOptimized(t)
                , r = this.offset.getOptimized();
            return new AT(n, r, this.ordering)
        }
        *evaluate(e) {
            let { input: t, offset: n } = yield* Ge({
                input: this.input.evaluate(e),
                offset: this.offset.evaluate(e, void 0)
            })
                , r = wT(n) ?? 0;
            return r === 0 ? t : t.slice(r)
        }
    }
    , DT = class extends Ze {
        constructor(e, t, n, r, i) {
            super(r, i, e.isSynchronous),
                this.input = e,
                this.namedFields = t,
                this.ordering = n,
                this.referencedFields = r,
                this.referencedOuterFields = i,
                E(this, "inputGroup", this.input.getGroup()),
                E(this, "definition");
            let o = {}
                , s = Object.entries(t);
            for (let [a, l] of s)
                o[a] = l.definition;
            this.definition = {
                type: "array",
                isNullable: !1,
                definition: {
                    type: "object",
                    isNullable: !1,
                    definitions: o
                }
            }
        }
        getHash() {
            let e = {}
                , t = Object.entries(this.namedFields);
            for (let [n, r] of t)
                e[n] = r.id;
            return de("ScalarArray", this.inputGroup.id, e, this.ordering, this.referencedFields, this.referencedOuterFields)
        }
        toString() {
            return `ARRAY(${this.inputGroup.id})`
        }
        getInputRequiredProps() {
            let e = new X
                , t = Object.values(this.namedFields);
            for (let n of t)
                Qe(n.collection) || e.add(n);
            return new pn(this.ordering, e)
        }
        optimize(e) {
            let t = this.getInputRequiredProps()
                , n = e.optimizeGroup(this.inputGroup, t);
            return new ce(0).add(n)
        }
        getOptimized() {
            let e = this.getInputRequiredProps()
                , t = this.inputGroup.getOptimized(e);
            return new DT(t, this.namedFields, this.ordering, this.referencedFields, this.referencedOuterFields)
        }
        *evaluate(e, t) {
            let n = new gr;
            e && n.merge(e),
                t && n.merge(t);
            let r = yield* this.input.evaluate(n)
                , i = Object.entries(this.namedFields);
            return {
                type: "array",
                value: r.tuples.map(o => {
                    let s = {};
                    for (let [a, l] of i)
                        s[a] = o.getValue(l);
                    return {
                        type: "object",
                        value: s
                    }
                }
                )
            }
        }
    }
    , zT = class extends Ze {
        constructor(e, t) {
            super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
                this.input = e,
                this.definition = t,
                A(t.isNullable, "Unsupported non-nullable cast")
        }
        getHash() {
            return de("ScalarCast", this.input, this.definition)
        }
        toString() {
            return `CAST(${this.input} AS ${this.definition.type.toUpperCase()})`
        }
        optimize(e) {
            return this.input.optimize(e)
        }
        getOptimized() {
            let e = this.input.getOptimized();
            return new zT(e, this.definition)
        }
        *evaluate(e, t) {
            let n = yield* this.input.evaluate(e, t);
            return Me.cast(n, this.definition)
        }
    }
    , BT = class extends Ze {
        constructor(e, t, n, r, i) {
            super(r, i, e.isSynchronous),
                this.input = e,
                this.field = t,
                this.ordering = n,
                this.referencedFields = r,
                this.referencedOuterFields = i,
                E(this, "inputGroup", this.input.getGroup()),
                E(this, "definition"),
                this.definition = {
                    type: "array",
                    isNullable: !1,
                    definition: this.field.definition
                }
        }
        getHash() {
            return de("ScalarFlatArray", this.inputGroup.id, this.field.id, this.ordering, this.referencedFields, this.referencedOuterFields)
        }
        toString() {
            return `FLAT_ARRAY(${this.inputGroup.id})`
        }
        getInputRequiredProps() {
            let e = new X;
            return Qe(this.field.collection) || e.add(this.field),
                new pn(this.ordering, e)
        }
        optimize(e) {
            let t = this.getInputRequiredProps()
                , n = e.optimizeGroup(this.inputGroup, t);
            return new ce(0).add(n)
        }
        getOptimized() {
            let e = this.getInputRequiredProps()
                , t = this.inputGroup.getOptimized(e);
            return new BT(t, this.field, this.ordering, this.referencedFields, this.referencedOuterFields)
        }
        *evaluate(e, t) {
            let n = new gr;
            return e && n.merge(e),
                t && n.merge(t),
            {
                type: "array",
                value: (yield* this.input.evaluate(n)).tuples.map(i => i.getValue(this.field))
            }
        }
    }
    , IB = {
        type: 0
    }
    , $T = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarIn", this.left, this.right)
        }
        toString() {
            return `${this.left} IN ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new $T(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: Me.in(n, r, IB)
            }
        }
    }
    , OB = {
        type: 1
    }
    , NT = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.source = e,
                this.target = t,
                E(this, "definition", {
                    type: "number",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarIndexOf", this.source, this.target)
        }
        toString() {
            return `INDEX_OF(${this.source}, ${this.target})`
        }
        optimize(e) {
            let t = this.source.optimize(e)
                , n = this.target.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.source.getOptimized()
                , t = this.target.getOptimized();
            return new NT(e, t)
        }
        *evaluate(e, t) {
            let { source: n, target: r } = yield* Ge({
                source: this.source.evaluate(e, t),
                target: this.target.evaluate(e, t)
            });
            return {
                type: "number",
                value: Me.indexOf(n, r, OB)
            }
        }
    }
    , jT = class extends Ze {
        constructor(e) {
            super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
                this.input = e,
                E(this, "definition", {
                    type: "number",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarLength", this.input)
        }
        toString() {
            return `LENGTH(${this.input})`
        }
        optimize(e) {
            return this.input.optimize(e)
        }
        getOptimized() {
            let e = this.input.getOptimized();
            return new jT(e)
        }
        *evaluate(e, t) {
            let n = yield* this.input.evaluate(e, t);
            return {
                type: "number",
                value: Me.length(n)
            }
        }
    }
    , Um = class extends Ze {
        constructor(e) {
            super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
                this.input = e,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarNot", this.input)
        }
        toString() {
            return `NOT ${this.input}`
        }
        optimize(e) {
            return this.input.optimize(e)
        }
        getOptimized() {
            let e = this.input.getOptimized();
            return new Um(e)
        }
        *evaluate(e, t) {
            let n = yield* this.input.evaluate(e, t);
            return {
                type: "boolean",
                value: !$r(n)
            }
        }
    }
    , MB = {
        type: 0
    }
    , HT = class extends Ze {
        constructor(e, t) {
            let n = new X;
            n.merge(e.referencedFields),
                n.merge(t.referencedFields);
            let r = new X;
            r.merge(e.referencedOuterFields),
                r.merge(t.referencedOuterFields);
            let i = e.isSynchronous && t.isSynchronous;
            super(n, r, i),
                this.left = e,
                this.right = t,
                E(this, "definition", {
                    type: "boolean",
                    isNullable: !1
                })
        }
        getHash() {
            return de("ScalarNotIn", this.left, this.right)
        }
        toString() {
            return `${this.left} NOT IN ${this.right}`
        }
        optimize(e) {
            let t = this.left.optimize(e)
                , n = this.right.optimize(e);
            return ce.max(t, n)
        }
        getOptimized() {
            let e = this.left.getOptimized()
                , t = this.right.getOptimized();
            return new HT(e, t)
        }
        *evaluate(e, t) {
            let { left: n, right: r } = yield* Ge({
                left: this.left.evaluate(e, t),
                right: this.right.evaluate(e, t)
            });
            return {
                type: "boolean",
                value: !Me.in(n, r, MB)
            }
        }
    }
    , fn = class extends Ze {
        constructor(e, t) {
            A(e.name !== ls, "Invalid field name");
            let n = new X
                , r = new X;
            t ? r.add(e) : n.add(e),
                super(n, r, !0),
                this.field = e,
                this.isOuterField = t,
                E(this, "definition", this.field.definition)
        }
        getHash() {
            return de("ScalarVariable", this.field.id, this.isOuterField)
        }
        toString() {
            return `"${this.field.name}" /* ${this.field.id} */`
        }
        optimize() {
            return new ce(0)
        }
        getOptimized() {
            return this
        }
        *evaluate(e, t) {
            return this.isOuterField ? (A(e, "Context must exist"),
                e.getValue(this.field)) : (A(t, "Tuple must exist"),
                    t.getValue(this.field))
        }
    }
    , LB = class {
        constructor(e) {
            this.memo = e
        }
        finishRelational(e) {
            return this.memo.addRelational(e)
        }
        newRelationalScan(e) {
            let t = new Au(e);
            return this.finishRelational(t)
        }
        newRelationalIndexLookup(e, t) {
            let n = new Pn(e, t);
            return this.finishRelational(n)
        }
        newRelationalLeftJoin(e, t, n) {
            let r = new Vu(e, t, n);
            return this.finishRelational(r)
        }
        newRelationalRightJoin(e, t, n) {
            return this.newRelationalLeftJoin(t, e, n)
        }
        newRelationalFilter(e, t) {
            if (e instanceof Vu && t.referencedFields.subsetOf(e.leftGroup.relational.outputFields)) {
                let r = this.newRelationalFilter(e.left, t);
                return this.newRelationalLeftJoin(r, e.right, e.constraint)
            }
            if (e instanceof Pg && t.referencedFields.subsetOf(e.rightGroup.relational.outputFields)) {
                let r = this.newRelationalFilter(e.right, t);
                return this.newRelationalLeftJoin(e.left, r, e.constraint)
            }
            let n = new Lu(e, t);
            return this.finishRelational(n)
        }
        newRelationalProject(e, t, n) {
            let r = new Hm(e, t, n);
            return this.finishRelational(r)
        }
        newRelationalLimit(e, t, n) {
            if (e instanceof Hm && t.referencedFields.subsetOf(e.inputGroup.relational.outputFields) && n.providedByFields(e.inputGroup.relational.outputFields)) {
                let i = this.newRelationalLimit(e.input, t, n);
                return this.newRelationalProject(i, e.projections, e.passthrough)
            }
            let r = new VT(e, t, n);
            return this.finishRelational(r)
        }
        newRelationalOffset(e, t, n) {
            let r = new AT(e, t, n);
            return this.finishRelational(r)
        }
        finishScalar(e) {
            if (!(e instanceof Hn) && e.isSynchronous && e.referencedFields.size === 0 && e.referencedOuterFields.size === 0) {
                let n = e.evaluateSync();
                return this.newScalarConstant(e.definition, n)
            }
            return this.memo.addScalar(e)
        }
        removeUnknown(e, t) {
            if (e.definition.type !== "unknown" || t.type === "unknown")
                return e;
            let n = {
                ...t,
                isNullable: !0
            };
            return this.newScalarCast(e, n)
        }
        newScalarVariable(e, t) {
            let n = new fn(e, t);
            return this.finishScalar(n)
        }
        newScalarConstant(e, t) {
            let n = new Hn(e, t);
            return this.finishScalar(n)
        }
        newScalarNot(e) {
            if (e instanceof Um) {
                if (e.input.definition.type === "boolean")
                    return e.input;
                let n = {
                    type: "boolean",
                    isNullable: !0
                };
                return this.newScalarCast(e.input, n)
            }
            if (e instanceof cs)
                return this.newScalarNotEquals(e.left, e.right);
            if (e instanceof ju)
                return this.newScalarEquals(e.left, e.right);
            if (e instanceof $u)
                return this.newScalarGreaterThanOrEqual(e.left, e.right);
            if (e instanceof Nu)
                return this.newScalarGreaterThan(e.left, e.right);
            if (e instanceof zu)
                return this.newScalarLessThanOrEqual(e.left, e.right);
            if (e instanceof Bu)
                return this.newScalarLessThan(e.left, e.right);
            if (e instanceof Du) {
                let n = this.newScalarNot(e.left)
                    , r = this.newScalarNot(e.right);
                return this.newScalarOr(n, r)
            }
            if (e instanceof Hu) {
                let n = this.newScalarNot(e.left)
                    , r = this.newScalarNot(e.right);
                return this.newScalarAnd(n, r)
            }
            let t = new Um(e);
            return this.finishScalar(t)
        }
        newScalarAnd(e, t) {
            let n = new Du(e, t);
            return this.finishScalar(n)
        }
        newScalarOr(e, t) {
            let n = new Hu(e, t);
            return this.finishScalar(n)
        }
        newScalarEquals(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarEquals(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new cs(e, t);
            return this.finishScalar(i)
        }
        newScalarNotEquals(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarNotEquals(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new ju(e, t);
            return this.finishScalar(i)
        }
        newScalarLessThan(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarGreaterThan(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new $u(e, t);
            return this.finishScalar(i)
        }
        newScalarLessThanOrEqual(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarGreaterThanOrEqual(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new Nu(e, t);
            return this.finishScalar(i)
        }
        newScalarGreaterThan(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarLessThan(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new zu(e, t);
            return this.finishScalar(i)
        }
        newScalarGreaterThanOrEqual(e, t) {
            let n = e instanceof fn;
            if (t instanceof fn && !n)
                return this.newScalarLessThanOrEqual(t, e);
            e = this.removeUnknown(e, t.definition),
                t = this.removeUnknown(t, e.definition);
            let i = new Bu(e, t);
            return this.finishScalar(i)
        }
        newScalarIn(e, t) {
            t.definition.type === "array" && (e = this.removeUnknown(e, t.definition.definition));
            let n = {
                type: "array",
                isNullable: !0,
                definition: e.definition
            };
            t = this.removeUnknown(t, n);
            let r = new $T(e, t);
            return this.finishScalar(r)
        }
        newScalarNotIn(e, t) {
            t.definition.type === "array" && (e = this.removeUnknown(e, t.definition.definition));
            let n = {
                type: "array",
                isNullable: !0,
                definition: e.definition
            };
            t = this.removeUnknown(t, n);
            let r = new HT(e, t);
            return this.finishScalar(r)
        }
        newScalarCase(e, t, n) {
            if (e) {
                let i = [];
                for (let { when: o, then: s } of t) {
                    let a = this.removeUnknown(o, e.definition)
                        , l = new Fg(a, s);
                    i.push(l)
                }
                t = i
            }
            let r = new PT(e, t, n);
            return this.finishScalar(r)
        }
        newScalarContains(e, t) {
            let n = new _g(e, t);
            return this.finishScalar(n)
        }
        newScalarStartsWith(e, t) {
            let n = new Og(e, t);
            return this.finishScalar(n)
        }
        newScalarEndsWith(e, t) {
            let n = new Ig(e, t);
            return this.finishScalar(n)
        }
        newScalarLength(e) {
            let t = new jT(e);
            return this.finishScalar(t)
        }
        newScalarIndexOf(e, t) {
            let n = new NT(e, t);
            return this.finishScalar(n)
        }
        newScalarArray(e, t, n, r, i) {
            let o = new DT(e, t, n, r, i);
            return this.finishScalar(o)
        }
        newScalarFlatArray(e, t, n, r, i) {
            let o = new BT(e, t, n, r, i);
            return this.finishScalar(o)
        }
        newScalarCast(e, t) {
            if (e.definition.type === t.type)
                return e;
            let n = new zT(e, t);
            return this.finishScalar(n)
        }
    }
    , VB = class {
        constructor(e, t) {
            this.query = e,
                this.locale = t,
                E(this, "memo", new _B),
                E(this, "normalizer", new LB(this.memo)),
                E(this, "explorer", new FB(this.normalizer))
        }
        optimize() {
            let t = new kB(this.normalizer, this.query, this.locale).build()
                , r = t.takeNode().getGroup()
                , i = t.getRequiredProps();
            this.optimizeGroup(r, i);
            let o = r.getOptimized(i)
                , s = t.getNamedFields();
            return [o, s]
        }
        optimizeGroup(e, t) {
            let n = e.getWinner(t);
            if (n.node)
                return n.cost;
            let r = e.nodes[0];
            A(r, "Normalized node not found"),
                this.createEnforcer(n, r, t);
            for (let i of e.nodes) {
                if (t.canProvide(i)) {
                    let o = i.optimize(this, t);
                    n.update(i, o)
                }
                t.isMinimal && this.explorer.explore(i)
            }
            return n.cost
        }
        createEnforcer(e, t, n) {
            if (n.resolvedFields.size > 0) {
                let r = new MT(t, n.resolvedFields)
                    , i = r.optimize(this, n);
                e.update(r, i)
            }
            if (n.ordering.length > 0) {
                let r = new LT(t, n.ordering)
                    , i = r.optimize(this, n);
                e.update(r, i)
            }
        }
    }
    ;
function AB(e) {
    return e.collection ? `"${e.collection}"."${e.name}"` : `"${e.name}"`
}
function DB(e) {
    return typeof e.value == "string" ? `'${e.value}'` : e.value
}
function zB(e) {
    return `${e.functionName}(${e.arguments.map(t => jt(t)).join(", ")})`
}
function BB(e) {
    let t = "CASE";
    e.value && (t += ` ${jt(e.value)}`);
    for (let n of e.conditions)
        t += ` WHEN ${jt(n.when)} THEN ${jt(n.then)}`;
    return e.else && (t += ` ELSE ${jt(e.else)}`),
        t += " END",
        t
}
function $B(e) {
    let t = jt(e.value);
    return `${e.operator.toUpperCase()} ${t}`
}
function NB(e) {
    let t = jt(e.left)
        , n = jt(e.right)
        , r = e.operator.toUpperCase();
    return `${t} ${r} ${n}`
}
function jB(e) {
    return `CAST(${jt(e.value)} as ${e.dataType})`
}
function jt(e) {
    switch (e.type) {
        case "Identifier":
            return AB(e);
        case "LiteralValue":
            return DB(e);
        case "FunctionCall":
            return zB(e);
        case "Case":
            return BB(e);
        case "UnaryOperation":
            return $B(e);
        case "BinaryOperation":
            return NB(e);
        case "TypeCast":
            return jB(e);
        case "Select":
            return `${WT(e)}`;
        default:
            Ce(e)
    }
}
function HB(e) {
    return Rg(e.data) ? "Collection" : e.alias ? `"${e.data.displayName}" AS "${e.alias}"` : `"${e.data.displayName}"`
}
function WB(e) {
    let t = `${Gm(e.left)} LEFT JOIN ${Gm(e.right)}`;
    return e.constraint && (t += ` ON ${jt(e.constraint)}`),
        t
}
function Gm(e) {
    switch (e.type) {
        case "Collection":
            return HB(e);
        case "LeftJoin":
            return WB(e);
        default:
            Ce(e)
    }
}
function UB(e) {
    let t = "";
    return e.split(/\s+/u).forEach(r => {
        r !== "" && (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(r) ? t += `
${r}` : ["AND", "OR"].includes(r) ? t += `
	${r}` : t += ` ${r}`)
    }
    ),
        t.trim()
}
function WT(e) {
    let t = "";
    return t += `SELECT ${e.select.map(n => {
        let r = jt(n);
        return n.alias ? `${r} AS "${n.alias}"` : r
    }
    ).join(", ")}`,
        t += ` FROM ${Gm(e.from)}`,
        e.where && (t += ` WHERE ${jt(e.where)}`),
        e.orderBy && (t += ` ORDER BY ${e.orderBy.map(n => `${jt(n)} ${n.direction ?? "asc"}`).join(", ")}`),
        e.limit && (t += ` LIMIT ${jt(e.limit)}`),
        e.offset && (t += ` OFFSET ${jt(e.offset)}`),
        UB(t)
}
var GB = rB("query-engine"), qB = class {
    async query(e, t) {
        GB.debug(`Query:
${WT(e)}`);
        let n = new VB(e, t)
            , [r, i] = n.optimize()
            , o = await r.evaluateAsync()
            , s = Object.entries(i);
        return await Promise.all(o.tuples.map(async l => {
            let c = await Promise.all(s.map(async ([u, f]) => {
                let d = l.getValue(f)
                    , p = await this.resolveValue(d);
                return [u, p]
            }
            ));
            return Object.fromEntries(c)
        }
        ))
    }
    async resolveValue(e) {
        if (e?.type === "richtext")
            return A(e.value instanceof Eg, "Pointer must be wrapped"),
                e.value.resolve();
        if (e?.type === "array")
            return Promise.all(e.value.map(async t => this.resolveValue(t)));
        if (e?.type === "object") {
            let t = Object.entries(e.value)
                , n = await Promise.all(t.map(async ([r, i]) => {
                    let o = await this.resolveValue(i);
                    return [r, o]
                }
                ));
            return Object.fromEntries(n)
        }
        return e?.value ?? null
    }
}
    , ku = "default", XB = new Set([ku]), Cu, YB = class {
        constructor() {
            E(this, "entries", new Map),
                tn(this, Cu, {})
        }
        set(e, t, n, r) {
            switch (t) {
                case "transformTemplate":
                    {
                        A(typeof n == "string", `transformTemplate must be a string, received: ${n}`),
                            this.setHash(e, r, {
                                transformTemplate: n,
                                legacy: !0
                            });
                        break
                    }
                case "initial":
                case "animate":
                    {
                        A(typeof n == "object", `${t} must be a valid object, received: ${n}`),
                            this.setHash(e, r, {
                                [t]: n,
                                legacy: !0
                            });
                        break
                    }
                default:
                    break
            }
        }
        setHash(e, t = ku, n) {
            let r = this.entries.get(e) ?? {}
                , i = r[t] ?? {};
            r[t] = n === null ? null : {
                ...i,
                ...n
            },
                this.entries.set(e, r)
        }
        variantHash(e, t) {
            if (e === t?.primaryVariantId)
                return ku;
            let n = me(this, Cu)[e];
            if (n)
                return n;
            let r = t?.variantClassNames[e];
            return r ? me(this, Cu)[e] = mT(r) : ku
        }
        setAll(e, t = XB, n, r) {
            var i;
            if (n === null) {
                for (let c of t)
                    this.setHash(e, this.variantHash(c, r), null);
                return
            }
            let o = Un(n.transformTemplate) ? (i = n.transformTemplate) == null ? void 0 : i.call(n, {}, UT) : void 0
                , s = n.__framer__presenceInitial ?? n.initial
                , a = n.__framer__presenceAnimate ?? n.animate
                , l = {
                    initial: Se(s) ? s : void 0,
                    animate: Se(a) ? a : void 0,
                    transformTemplate: ye(o) ? o : void 0
                };
            for (let c of t)
                this.setHash(e, this.variantHash(c, r), l)
        }
        clear() {
            this.entries.clear()
        }
        toObject() {
            return Object.fromEntries(this.entries)
        }
    }
    ;
Cu = new WeakMap;
var Mg = new YB;
function YU(e) {
    return x.forwardRef(({ optimized: t, ...n }, r) => {
        let i = x.useContext(JC)
            , o = x.useContext(Tg)
            , s = n[KB];
        return s && !Gn() && Mg.setAll(s, o, t ? n : null, i),
            k(e, {
                ref: r,
                ...n
            })
    }
    )
}
var KU = (e, t, n, r) => (Gn() || Mg.set(t, e, n, r),
    n)
    , UT = "__Appear_Animation_Transform__"
    , QU = (e, t) => {
        if (!Gn()) {
            let n = t?.({}, UT);
            if (n === void 0)
                return t;
            Mg.set(e, "transformTemplate", n)
        }
        return t
    }
    , KB = "data-framer-appear-id"
    , ZU = "data-framer-appear-animation";
function Rm(e, t) {
    e.forEach(n => clearTimeout(n)),
        e.clear(),
        t.forEach(n => n && n("Callback cancelled by variant change")),
        t.clear()
}
function ak() {
    return new Set
}
function e9(e) {
    let t = yt(ak)
        , n = yt(ak);
    return VC(() => () => Rm(n, t)),
        x.useEffect(() => () => Rm(n, t), [t, n]),
        x.useEffect(() => {
            Rm(n, t)
        }
            , [e, t, n]),
        x.useRef({
            activeVariantCallback: r => (...i) => new Promise((o, s) => {
                t.add(s),
                    r(...i).then(o)
            }
            ).catch(() => { }
            ),
            delay: async (r, i) => {
                await new Promise(o => n.add(globalThis.setTimeout(() => o(!0), i))),
                    r()
            }
        }).current
}
function QB(e, t, n) {
    return x.useCallback(r => {
        var i, o, s;
        return n ? e ? t ? Object.assign({}, (i = n[e]) == null ? void 0 : i[r], (o = n[t]) == null ? void 0 : o[r]) : ((s = n[e]) == null ? void 0 : s[r]) || {} : {} : {}
    }
        , [e, t, n])
}
function ZB(e) {
    for (let [t, n] of Object.entries(e))
        if (it.matchMedia(n).matches)
            return t
}
function JB(e) {
    var t;
    for (let { hash: n, mediaQuery: r } of e) {
        if (!r)
            continue;
        if (it.matchMedia(r).matches)
            return n
    }
    return (t = e[0]) == null ? void 0 : t.hash
}
function r9(e, t, n = !0) {
    let r = D(BC)
        , i = V(Gn() ? ZB(t) ?? e : e)
        , o = V(n && r ? e : i.current)
        , s = Zu()
        , a = Sb()
        , l = Q(c => {
            (c !== i.current || c !== o.current) && a(() => {
                i.current = o.current = c,
                    at(() => {
                        s()
                    }
                    )
            }
            )
        }
            , [a, s]);
    return xC(() => {
        !n || r !== !0 || l(i.current)
    }
        , []),
        H(() => {
            let c = [];
            for (let [u, f] of Object.entries(t)) {
                let d = it.matchMedia(f)
                    , p = v => {
                        v.matches && l(u)
                    }
                    ;
                e$(d, p),
                    c.push([d, p])
            }
            return () => c.forEach(([u, f]) => t$(u, f))
        }
            , [t, l]),
        [i.current, o.current]
}
function e$(e, t) {
    e.addEventListener ? e.addEventListener("change", t) : e.addListener(t)
}
function t$(e, t) {
    e.removeEventListener ? e.removeEventListener("change", t) : e.removeListener(t)
}
var n$ = "style[data-framer-breakpoint-css]";
function r$(e) {
    setTimeout(e, 1)
}
function i9(e) {
    var t, n;
    let r = JB(e);
    if (r)
        for (let o of document.querySelectorAll(".hidden-" + r))
            (t = o.parentNode) == null || t.removeChild(o);
    (it.requestIdleCallback ?? r$)(() => {
        var o;
        (o = document.querySelector(n$)) == null || o.remove()
    }
    );
    for (let o of document.querySelectorAll(".ssr-variant:empty"))
        (n = o.parentNode) == null || n.removeChild(o)
}
function lk(e, t) {
    if (e[t])
        return e[t];
    if (!(t in e))
        return e.default
}
function i$(e, t) {
    if (hs())
        return;
    let r = x.useRef(!0)
        , i = x.useRef(t);
    VC((o, s) => {
        let a = o && !s;
        if (!r.current && a) {
            let l = lk(i.current, e);
            l && l()
        }
        r.current = a
    }
        , []),
        x.useEffect(() => {
            if (r.current) {
                let o = lk(i.current, e);
                o && o()
            }
        }
            , [e])
}
function u9(e) {
    i$("default", {
        default: e
    })
}
var o$ = class {
    constructor(e) {
        this.queryEngine = e,
            E(this, "cache", new Map)
    }
    get(e, t) {
        let n = l$(e, t)
            , r = this.cache.get(n);
        if (r)
            return r;
        let i = () => this.queryEngine.query(e, t)
            , o = new rf(i);
        return this.cache.set(n, o),
            o
    }
}
    , ck = new WeakMap;
function s$(e) {
    let t = ck.get(e);
    if (t)
        return t;
    let n = Math.random().toString(16).slice(2);
    return ck.set(e, n),
        n
}
function a$(e, t) {
    return Se(t) && t.type === "Collection" && iB(t.data) ? s$(t.data) : t
}
function l$(e, t) {
    let n = t?.id ?? "default";
    return JSON.stringify(e, a$) + n
}
function c$(e) {
    throw e
}
var u$ = new qB
    , f$ = new o$(u$);
function p9(e) {
    let { activeLocale: t } = Yu()
        , n = f$.get(e, t)
        , r = n.preload();
    return r && c$(r),
        n.read()
}
function m9(e, t) {
    let r = Object.entries(e ?? {}).filter(([, i]) => !(Qe(i) || Se(i))).map(([i, o]) => ({
        type: "BinaryOperation",
        operator: "==",
        left: {
            type: "TypeCast",
            value: {
                type: "Identifier",
                name: i,
                collection: t
            },
            dataType: "STRING"
        },
        right: {
            type: "LiteralValue",
            value: String(o)
        }
    }));
    return r.length === 0 ? {
        type: "LiteralValue",
        value: !1
    } : r.reduce((i, o) => ({
        type: "BinaryOperation",
        operator: "and",
        left: i,
        right: o
    }))
}
function uk(e, t) {
    return `${e}-${t}`
}
function d$(e, t) {
    let r = e.indexOf(t) + 1;
    r >= e.length && (r = 0);
    let i = e[r];
    return A(i !== void 0, "nextVariant should be defined"),
        i
}
function h$(e, t) {
    if (e) {
        if (t) {
            let n = e[t];
            if (n)
                return n
        }
        return e.default
    }
}
function fk(e, t, n, r, i) {
    let { hover: o, pressed: s, loading: a, error: l } = e || {};
    if (l && i)
        return "error";
    if (a && r)
        return "loading";
    if (s && n)
        return "pressed";
    if (o && t)
        return "hover"
}
function p$(e, t) {
    let n = t[e];
    return n || `framer-v-${e}`
}
function dk(e, t, n) {
    return e && n.has(e) ? e : t
}
var m$ = Symbol("cycle");
function y9({ variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i = [], variantProps: o = {}, variantClassNames: s = {} }) {
    let a = Zu()
        , l = hs()
        , c = yt(() => new Set(i))
        , { wrapUpdatesInTransitions: u } = Qa()
        , f = x.useRef({
            isHovered: !1,
            isPressed: !1,
            isError: !1,
            hasPressedVariants: !0,
            baseVariant: dk(e, t, c),
            lastVariant: e,
            gestureVariant: void 0,
            loadedBaseVariant: {},
            defaultVariant: t,
            enabledGestures: r,
            cycleOrder: i,
            transitions: n
        })
        , d = x.useCallback(F => {
            let { isHovered: P, isPressed: B, isError: $, enabledGestures: N, defaultVariant: U } = f.current
                , j = dk(F, U, c)
                , ae = fk(N?.[j], P, B, !1, $)
                , te = ae ? uk(j, ae) : void 0;
            return [j, te]
        }
            , [c])
        , p = x.useCallback(({ isHovered: F, isPressed: P, isError: B }) => {
            F !== void 0 && (f.current.isHovered = F),
                P !== void 0 && (f.current.isPressed = P),
                B !== void 0 && (f.current.isError = B);
            let { baseVariant: $, gestureVariant: N, defaultVariant: U } = f.current
                , [j, ae] = d($);
            (j !== $ || ae !== N) && (f.current.baseVariant = j || U,
                f.current.gestureVariant = ae,
                B || u ? x.startTransition(() => {
                    a()
                }
                ) : a())
        }
            , [d, a, u])
        , v = x.useCallback(F => {
            let { defaultVariant: P, cycleOrder: B, baseVariant: $, gestureVariant: N } = f.current
                , U = F === m$ ? d$(B || [], $ || P) : F
                , [j, ae] = d(U);
            (j !== $ || ae !== N) && (f.current.isError = !1,
                f.current.baseVariant = j || P,
                f.current.gestureVariant = ae,
                u ? x.startTransition(() => {
                    a()
                }
                ) : a())
        }
            , [d, u, a])
        , g = x.useCallback(() => {
            let { baseVariant: F } = f.current;
            f.current.loadedBaseVariant[F] = !0,
                x.startTransition(() => {
                    a()
                }
                )
        }
            , [a]);
    if (e !== f.current.lastVariant) {
        let [F, P] = d(e);
        f.current.lastVariant = F,
            (F !== f.current.baseVariant || P !== f.current.gestureVariant) && (f.current.baseVariant = F,
                f.current.gestureVariant = P)
    }
    let { baseVariant: b, gestureVariant: m, defaultVariant: h, enabledGestures: y, isHovered: w, isPressed: C, isError: S, loadedBaseVariant: T } = f.current
        , R = QB(f.current.baseVariant, f.current.gestureVariant, o);
    return x.useMemo(() => {
        var F;
        let P = [];
        b !== h && P.push(b);
        let B = (F = y?.[b]) == null ? void 0 : F.loading
            , $ = !S && !l && !!B && !T[b]
            , N = $ ? uk(b, "loading") : m;
        N && P.push(N);
        let U = y?.[b]
            , j = {
                onMouseEnter: () => p({
                    isHovered: !0
                }),
                onMouseLeave: () => p({
                    isHovered: !1
                })
            };
        return U?.pressed && Object.assign(j, {
            onTapStart: () => p({
                isPressed: !0
            }),
            onTapCancel: () => p({
                isPressed: !1
            }),
            onTap: () => p({
                isPressed: !1
            })
        }),
        {
            variants: P,
            baseVariant: b,
            gestureVariant: N,
            isLoading: $,
            transition: h$(f.current.transitions, b),
            setVariant: v,
            setGestureState: p,
            clearLoadingGesture: g,
            addVariantProps: R,
            gestureHandlers: j,
            classNames: no(p$(b, s), fk(U, w, C, $, S))
        }
    }
        , [b, m, w, C, T, R, v, h, y, p, g, s])
}
var g$ = new Set(["visibleVariantId", "obscuredVariantId", "threshold", "animateOnce", "variantAppearEffectEnabled", "targets", "exitTarget", "scrollDirection"])
    , hk = {
        inputRange: [],
        outputRange: []
    };
function v$(e, t, n) {
    let r = []
        , i = mg(e, t, s => r.unshift(s, s));
    if (n) {
        let s = i[i.length - 1];
        if (!De(s))
            return hk;
        i.push(s + 1),
            r.push(-1)
    }
    let o = i[0];
    return De(o) ? o <= 1 ? {
        inputRange: i,
        outputRange: r
    } : {
        inputRange: [0, Math.max(o - 1, 0), ...i],
        outputRange: [-1, -1, ...r]
    } : hk
}
var C9 = e => x.forwardRef((t, n) => {
    if (fe.current() === fe.canvas)
        return k(e, {
            ...t,
            ref: n
        });
    let { wrapUpdatesInTransitions: r } = Qa()
        , [i, o] = jz(t, g$)
        , { visibleVariantId: s, obscuredVariantId: a, animateOnce: l, threshold: c, variantAppearEffectEnabled: u, targets: f, exitTarget: d, scrollDirection: p } = i
        , [v, g] = x.useState(a)
        , b = x.useRef(!1)
        , m = hg(n);
    return OC(m, h => {
        i.targets || i.scrollDirection || l && b.current === !0 || b.current !== h && (b.current = h,
            h ? r ? x.startTransition(() => {
                g(s)
            }
            ) : g(s) : r ? x.startTransition(() => {
                g(a)
            }
            ) : g(a))
    }
        , {
            enabled: u,
            animateOnce: l,
            threshold: {
                y: c
            }
        }),
        x.useEffect(() => {
            if (p || !f)
                return;
            let h = {}, y;
            return Tr(({ y: w }) => {
                var C;
                if (!f[0] || f[0].ref && !f[0].ref.current)
                    return;
                let { inputRange: S, outputRange: T } = v$(f, (c ?? 0) * w.containerLength, d);
                if (S.length === 0 || S.length !== T.length)
                    return;
                let R = Math.floor(wo(w.current, S, T));
                if (l && h[R])
                    return;
                h[R] = !0;
                let F = ((C = f[R]) == null ? void 0 : C.target) ?? void 0;
                F !== y && (y = F,
                    r ? x.startTransition(() => {
                        g(F)
                    }
                    ) : g(F))
            }
            )
        }
            , [l, c, f, t.variant, p, d, r]),
        XC(p, g, {
            enabled: u,
            repeat: !l
        }),
        !("variantAppearEffectEnabled" in i) || u === !0 ? k(e, {
            ...o,
            variant: v ?? t.variant,
            ref: m
        }) : k(e, {
            ...o
        })
}
);
var y$ = x.createContext(void 0)
    , b$ = () => x.useContext(y$);
var x$ = {
    Arial: {
        Regular: {
            selector: "Arial",
            weight: void 0
        },
        Black: {
            selector: "Arial-Black",
            weight: void 0
        },
        Narrow: {
            selector: "Arial Narrow",
            weight: void 0
        },
        "Rounded Bold": {
            selector: "Arial Rounded MT Bold",
            weight: void 0
        }
    },
    Avenir: {
        Book: {
            selector: "Avenir",
            weight: void 0
        },
        Light: {
            selector: "Avenir-Light",
            weight: void 0
        },
        Medium: {
            selector: "Avenir-Medium",
            weight: void 0
        },
        Heavy: {
            selector: "Avenir-Heavy",
            weight: void 0
        },
        Black: {
            selector: "Avenir-Black",
            weight: void 0
        }
    },
    "Avenir Next": {
        Regular: {
            selector: "Avenir Next",
            weight: void 0
        },
        "Ultra Light": {
            selector: "AvenirNext-UltraLight",
            weight: void 0
        },
        Medium: {
            selector: "AvenirNext-Medium",
            weight: void 0
        },
        "Demi Bold": {
            selector: "AvenirNext-DemiBold",
            weight: void 0
        },
        Heavy: {
            selector: "AvenirNext-Heavy",
            weight: void 0
        }
    },
    "Avenir Next Condensed": {
        Regular: {
            selector: "Avenir Next Condensed",
            weight: void 0
        },
        "Ultra Light": {
            selector: "AvenirNextCondensed-UltraLight",
            weight: void 0
        },
        Medium: {
            selector: "AvenirNextCondensed-Medium",
            weight: void 0
        },
        "Demi Bold": {
            selector: "AvenirNextCondensed-DemiBold",
            weight: void 0
        },
        Heavy: {
            selector: "AvenirNextCondensed-Heavy",
            weight: void 0
        }
    },
    Baskerville: {
        Regular: {
            selector: "Baskerville",
            weight: void 0
        },
        "Semi Bold": {
            selector: "Baskerville-SemiBold",
            weight: void 0
        }
    },
    "Bodoni 72": {
        Book: {
            selector: "Bodoni 72",
            weight: void 0
        },
        Oldstyle: {
            selector: "Bodoni 72 Oldstyle",
            weight: void 0
        },
        Smallcaps: {
            selector: "Bodoni 72 Smallcaps",
            weight: void 0
        }
    },
    Courier: {
        Regular: {
            selector: "Courier",
            weight: void 0
        }
    },
    "Courier New": {
        Regular: {
            selector: "Courier New",
            weight: void 0
        }
    },
    Futura: {
        Medium: {
            selector: "Futura",
            weight: void 0
        },
        Condensed: {
            selector: "Futura-CondensedMedium",
            weight: void 0
        },
        "Condensed ExtraBold": {
            selector: "Futura-CondensedExtraBold",
            weight: void 0
        }
    },
    Georgia: {
        Regular: {
            selector: "Georgia",
            weight: void 0
        }
    },
    "Gill Sans": {
        Regular: {
            selector: "Gill Sans",
            weight: void 0
        },
        Light: {
            selector: "GillSans-Light",
            weight: void 0
        },
        SemiBold: {
            selector: "GillSans-SemiBold",
            weight: void 0
        },
        UltraBold: {
            selector: "GillSans-UltraBold",
            weight: void 0
        }
    },
    Helvetica: {
        Regular: {
            selector: "Helvetica",
            weight: void 0
        },
        Light: {
            selector: "Helvetica-Light",
            weight: void 0
        },
        Bold: {
            selector: "Helvetica-Bold",
            weight: void 0
        },
        Oblique: {
            selector: "Helvetica-Oblique",
            weight: void 0
        },
        "Light Oblique": {
            selector: "Helvetica-LightOblique",
            weight: void 0
        },
        "Bold Oblique": {
            selector: "Helvetica-BoldOblique",
            weight: void 0
        }
    },
    "Helvetica Neue": {
        Regular: {
            selector: "Helvetica Neue",
            weight: void 0
        },
        UltraLight: {
            selector: "HelveticaNeue-UltraLight",
            weight: void 0
        },
        Thin: {
            selector: "HelveticaNeue-Thin",
            weight: void 0
        },
        Light: {
            selector: "HelveticaNeue-Light",
            weight: void 0
        },
        Medium: {
            selector: "HelveticaNeue-Medium",
            weight: void 0
        },
        Bold: {
            selector: "HelveticaNeue-Bold",
            weight: void 0
        },
        Italic: {
            selector: "HelveticaNeue-Italic",
            weight: void 0
        },
        "UltraLight Italic": {
            selector: "HelveticaNeue-UltraLightItalic",
            weight: void 0
        },
        "Thin Italic": {
            selector: "HelveticaNeue-ThinItalic",
            weight: void 0
        },
        "Light Italic": {
            selector: "HelveticaNeue-LightItalic",
            weight: void 0
        },
        "Medium Italic": {
            selector: "HelveticaNeue-MediumItalic",
            weight: void 0
        },
        "Bold Italic": {
            selector: "HelveticaNeue-BoldItalic",
            weight: void 0
        },
        "Condensed Bold": {
            selector: "HelveticaNeue-CondensedBold",
            weight: void 0
        },
        "Condensed Black": {
            selector: "HelveticaNeue-CondensedBlack",
            weight: void 0
        }
    },
    "Hoefler Text": {
        Regular: {
            selector: "Hoefler Text",
            weight: void 0
        }
    },
    Impact: {
        Regular: {
            selector: "Impact",
            weight: void 0
        }
    },
    "Lucida Grande": {
        Regular: {
            selector: "Lucida Grande",
            weight: void 0
        }
    },
    Menlo: {
        Regular: {
            selector: "Menlo",
            weight: void 0
        }
    },
    Monaco: {
        Regular: {
            selector: "Monaco",
            weight: void 0
        }
    },
    Optima: {
        Regular: {
            selector: "Optima",
            weight: void 0
        },
        ExtraBlack: {
            selector: "Optima-ExtraBlack",
            weight: void 0
        }
    },
    Palatino: {
        Regular: {
            selector: "Palatino",
            weight: void 0
        }
    },
    "SF Pro Display": {
        Regular: {
            selector: "__SF-UI-Display-Regular__",
            weight: 400
        },
        Ultralight: {
            selector: "__SF-UI-Display-Ultralight__",
            weight: 100
        },
        Thin: {
            selector: "__SF-UI-Display-Thin__",
            weight: 200
        },
        Light: {
            selector: "__SF-UI-Display-Light__",
            weight: 300
        },
        Medium: {
            selector: "__SF-UI-Display-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Display-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Display-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Display-Heavy__",
            weight: 800
        },
        Black: {
            selector: "__SF-UI-Display-Black__",
            weight: 900
        },
        Italic: {
            selector: "__SF-UI-Display-Italic__",
            weight: 400
        },
        "Ultralight Italic": {
            selector: "__SF-UI-Display-Ultralight-Italic__",
            weight: 100
        },
        "Thin Italic": {
            selector: "__SF-UI-Display-Thin-Italic__",
            weight: 200
        },
        "Light Italic": {
            selector: "__SF-UI-Display-Light-Italic__",
            weight: 300
        },
        "Medium Italic": {
            selector: "__SF-UI-Display-Medium-Italic__",
            weight: 500
        },
        "Semibold Italic": {
            selector: "__SF-UI-Display-Semibold-Italic__",
            weight: 600
        },
        "Bold Italic": {
            selector: "__SF-UI-Display-Bold-Italic__",
            weight: 700
        },
        "Heavy Italic": {
            selector: "__SF-UI-Display-Heavy-Italic__",
            weight: 800
        },
        "Black Italic": {
            selector: "__SF-UI-Display-Black-Italic__",
            weight: 900
        }
    },
    "SF Pro Display Condensed": {
        Regular: {
            selector: "__SF-UI-Display-Condensed-Regular__",
            weight: 400
        },
        Ultralight: {
            selector: "__SF-UI-Display-Condensed-Ultralight__",
            weight: 100
        },
        Thin: {
            selector: "__SF-UI-Display-Condensed-Thin__",
            weight: 200
        },
        Light: {
            selector: "__SF-UI-Display-Condensed-Light__",
            weight: 300
        },
        Medium: {
            selector: "__SF-UI-Display-Condensed-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Display-Condensed-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Display-Condensed-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Display-Condensed-Heavy__",
            weight: 800
        },
        Black: {
            selector: "__SF-UI-Display-Condensed-Black__",
            weight: 900
        }
    },
    "SF Pro Text": {
        Regular: {
            selector: "__SF-UI-Text-Regular__",
            weight: 400
        },
        Light: {
            selector: "__SF-UI-Text-Light__",
            weight: 200
        },
        Medium: {
            selector: "__SF-UI-Text-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Text-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Text-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Text-Heavy__",
            weight: 800
        },
        Italic: {
            selector: "__SF-UI-Text-Italic__",
            weight: 400
        },
        "Light Italic": {
            selector: "__SF-UI-Text-Light-Italic__",
            weight: 200
        },
        "Medium Italic": {
            selector: "__SF-UI-Text-Medium-Italic__",
            weight: 500
        },
        "Semibold Italic": {
            selector: "__SF-UI-Text-Semibold-Italic__",
            weight: 600
        },
        "Bold Italic": {
            selector: "__SF-UI-Text-Bold-Italic__",
            weight: 700
        },
        "Heavy Italic": {
            selector: "__SF-UI-Text-Heavy-Italic__",
            weight: 800
        }
    },
    "SF Pro Text Condensed": {
        Regular: {
            selector: "__SF-UI-Text-Condensed-Regular__",
            weight: 400
        },
        Light: {
            selector: "__SF-UI-Text-Condensed-Light__",
            weight: 200
        },
        Medium: {
            selector: "__SF-UI-Text-Condensed-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Text-Condensed-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Text-Condensed-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Text-Condensed-Heavy__",
            weight: 800
        }
    },
    Tahoma: {
        Regular: {
            selector: "Tahoma",
            weight: void 0
        }
    },
    Times: {
        Regular: {
            selector: "Times",
            weight: void 0
        }
    },
    "Times New Roman": {
        Regular: {
            selector: "Times New Roman",
            weight: void 0
        }
    },
    Trebuchet: {
        Regular: {
            selector: "Trebuchet MS",
            weight: void 0
        }
    },
    Verdana: {
        Regular: {
            selector: "Verdana",
            weight: void 0
        }
    }
}
    , w$ = {
        "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular",
        "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight",
        "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin",
        "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light",
        "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium",
        "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold",
        "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy",
        "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black",
        "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold",
        "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText",
        "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light",
        "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium",
        "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold",
        "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold",
        "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy",
        "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic",
        "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic",
        "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic",
        "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic",
        "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic",
        "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic",
        "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular",
        "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light",
        "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium",
        "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold",
        "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold",
        "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy",
        "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic",
        "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic",
        "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic",
        "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic",
        "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic",
        "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic",
        "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular",
        "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight",
        "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin",
        "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light",
        "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium",
        "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold",
        "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold",
        "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy",
        "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black",
        "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay",
        "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight",
        "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin",
        "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light",
        "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium",
        "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold",
        "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold",
        "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy",
        "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black",
        "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic",
        "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic",
        "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic",
        "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic",
        "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic",
        "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic",
        "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic",
        "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic",
        "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic",
        "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular",
        "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light",
        "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium",
        "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold",
        "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold",
        "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy",
        "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular",
        "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight",
        "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin",
        "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light",
        "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium",
        "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold",
        "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold",
        "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy",
        "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black"
    }
    , pk = x$;
function Wu(e) {
    return e.weight !== void 0 && e.style !== void 0
}
var S$ = "System Default"
    , k$ = class {
        constructor() {
            E(this, "name", "local"),
                E(this, "fontFamilies", []),
                E(this, "byFamilyName", new Map),
                E(this, "fontAliasBySelector", new Map),
                E(this, "fontAliases", new Map)
        }
        getFontFamilyByName(e) {
            return this.byFamilyName.get(e) ?? null
        }
        createFontFamily(e) {
            let t = {
                name: e,
                fonts: [],
                source: this.name
            };
            return this.addFontFamily(t),
                t
        }
        addFontFamily(e) {
            this.fontFamilies.push(e),
                this.byFamilyName.set(e.name, e)
        }
        importFonts() {
            let e = [];
            for (let r of Object.keys(pk)) {
                let i = pk[r];
                if (!i)
                    continue;
                let o = this.createFontFamily(r);
                for (let s of Object.keys(i)) {
                    let a = i[s];
                    if (!a)
                        continue;
                    let { selector: l, weight: c } = a
                        , u = {
                            variant: s,
                            selector: l,
                            weight: c,
                            family: o
                        };
                    o.fonts.push(u)
                }
                e.push(...o.fonts)
            }
            for (let [r, i] of Object.entries(w$))
                this.addFontAlias(r, i);
            let { fontFamily: t, aliases: n } = this.getSystemFontFamily();
            this.addFontFamily(t);
            for (let [r, i] of n)
                this.addFontAlias(r, i);
            return e.push(...t.fonts),
                e
        }
        addFontAlias(e, t) {
            this.fontAliases.set(e, t),
                this.fontAliasBySelector.set(t, e)
        }
        getSystemFontFamily() {
            let e = "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif"
                , t = {
                    name: S$,
                    fonts: [],
                    source: this.name
                }
                , n = new Map
                , r = [400, 100, 200, 300, 500, 600, 700, 800, 900]
                , i = ["normal", "italic"];
            for (let o of i)
                for (let s of r) {
                    let a = C$(s, o)
                        , l = `__SystemDefault-${s}-${o}__`
                        , c = {
                            variant: a,
                            selector: l,
                            style: o,
                            weight: s,
                            family: t
                        };
                    t.fonts.push(c),
                        n.set(l, e)
                }
            return {
                fontFamily: t,
                aliases: n
            }
        }
        getFontAliasBySelector(e) {
            return this.fontAliasBySelector.get(e) || null
        }
        getFontSelectorByAlias(e) {
            return this.fontAliases.get(e) || null
        }
        isFontFamilyAlias(e) {
            return !!(e && /^__.*__$/u.exec(e))
        }
    }
    , mk = {
        100: "Thin",
        200: "Extra Light",
        300: "Light",
        400: "Normal",
        500: "Medium",
        600: "Semi Bold",
        700: "Bold",
        800: "Extra Bold",
        900: "Black"
    };
function C$(e, t) {
    let n = t === "normal" ? "Regular" : "Italic";
    return e === 400 ? n : t !== "normal" ? `${mk[e]} ${n}` : `${mk[e]}`
}
var T$ = yr(Km(), 1);
function GT(e) {
    return !!e.variationAxes
}
function Em(e) {
    return GT(e) && e.family.source !== "custom" ? R$(e.family.name) : e.family.name
}
function R$(e) {
    return `${e} Variable`
}
var ns = "CUSTOM;";
function E$(e, t) {
    if (!t)
        return e.substring(0, e.lastIndexOf("."));
    let { font: n } = t
        , r = n.preferredFamily || n.fontFamily
        , i = Array.isArray(n.variationAxes);
    if (i && r.toLowerCase().includes("variable"))
        return r;
    let o = i ? "Variable" : n.preferredSubFamily || n.fontSubFamily;
    return `${r} ${o}`
}
var F$ = class {
    constructor() {
        E(this, "name", "custom"),
            E(this, "fontFamilies", []),
            E(this, "byFamilyName", new Map),
            E(this, "assetsByFamily", new Map)
    }
    importFonts(e) {
        var t, n, r;
        this.fontFamilies.length = 0,
            this.byFamilyName.clear(),
            this.assetsByFamily.clear();
        let i = [];
        for (let o of e) {
            if (!this.isValidCustomFontAsset(o))
                continue;
            let s = (t = o.properties) == null ? void 0 : t.font.variationAxes
                , a = Array.isArray(s)
                , l = E$(o.name, o.properties)
                , c = this.createFontFamily(l)
                , u = (n = o.properties) == null ? void 0 : n.font.openTypeData
                , f = a ? "variable" : this.inferVariantName(l)
                , d = {
                    family: c,
                    selector: `${ns}${l}`,
                    variant: f,
                    postscriptName: (r = o.properties) == null ? void 0 : r.font.postscriptName,
                    file: o.url,
                    openTypeFeatures: this.validateOpenTypeData(u),
                    variationAxes: this.validateVariationAxes(s)
                };
            c.fonts.push(d),
                c.owner = o.ownerType === "team" ? "team" : "project",
                this.assetsByFamily.set(l, o),
                i.push(...c.fonts)
        }
        return i
    }
    isValidCustomFontAsset(e) {
        var t;
        return !e.mimeType.startsWith("font/") || ((t = e.properties) == null ? void 0 : t.kind) !== "font" || !e.properties.font ? !1 : "fontFamily" in e.properties.font
    }
    validateOpenTypeData(e) {
        if (e && Array.isArray(e))
            return e.map(t => {
                if (this.isOpenTypeFeature(t))
                    return {
                        tag: t.tag,
                        coverage: t.coverage
                    }
            }
            )
    }
    validateVariationAxes(e) {
        if (!e || !Array.isArray(e))
            return;
        let t = [];
        for (let n of e)
            this.isVariationAxis(n) && t.push({
                tag: n.tag,
                name: n.name,
                minValue: n.minValue,
                maxValue: n.maxValue,
                defaultValue: n.defaultValue
            });
        return t
    }
    isOpenTypeFeature(e) {
        return !(typeof e != "object" || e === null || !("tag" in e) || typeof e.tag != "string" || "coverage" in e && typeof e.coverage < "u" && !Array.isArray(e.coverage))
    }
    isVariationAxis(e) {
        return !(typeof e != "object" || e === null || !("tag" in e) || typeof e.tag != "string" || !("name" in e) || typeof e.name != "string" || !("minValue" in e) || typeof e.minValue != "number" || !("maxValue" in e) || typeof e.maxValue != "number" || !("defaultValue" in e) || typeof e.defaultValue != "number")
    }
    inferVariantName(e) {
        let t = ["thin", "ultra light", "extra light", "light", "normal", "medium", "semi bold", "bold", "extra bold", "black"]
            , n = [...t.map(s => `${s} italic`), ...t]
            , r = e.toLowerCase()
            , i = [...r.split(" "), ...r.split("-"), ...r.split("_")]
            , o = n.find(s => i.includes(s) || i.includes(s.replace(/\s+/gu, "")));
        return o ? o.replace(/^\w|\s\w/gu, s => s.toUpperCase()) : "Regular"
    }
    createFontFamily(e) {
        let t = this.byFamilyName.get(e);
        if (t)
            return t;
        let n = {
            source: this.name,
            name: e,
            fonts: []
        };
        return this.addFontFamily(n),
            n
    }
    addFontFamily(e) {
        this.fontFamilies.push(e),
            this.byFamilyName.set(e.name, e)
    }
    parseSelector(e) {
        if (!e.startsWith(ns))
            return null;
        let t = e.split(ns);
        return t[1] === void 0 ? null : {
            source: "custom",
            name: t[1]
        }
    }
    getFontBySelector(e, t = !0) {
        let n = this.parseSelector(e);
        if (!n || !t && !this.byFamilyName.get(n.name))
            return;
        let r = this.getFontFamilyByName(n.name).fonts;
        return r.find(o => {
            var s;
            return (s = o.file) == null ? void 0 : s.endsWith(".woff2")
        }
        ) || r[0]
    }
    getFontFamilyByName(e) {
        let t = this.byFamilyName.get(e);
        if (t)
            return t;
        let n = {
            source: "custom",
            name: e,
            fonts: []
        };
        return n.fonts.push({
            selector: `${ns}${e}`,
            variant: this.inferVariantName(e),
            family: n
        }),
            n
    }
}
    ;
function qT(e, t) {
    return {
        ...P$(e, t),
        ..._$(e, t)
    }
}
function P$(e, t) {
    if (t.length === 0)
        return {
            variantBold: void 0,
            variantBoldItalic: void 0,
            variantItalic: void 0
        };
    let { weight: n, style: r } = e
        , i = new Map
        , o = new Map;
    for (let u of t)
        u.isVariable === e.isVariable && (i.set(`${u.weight}-${u.style}`, u),
            !(u.weight <= n) && (o.has(u.style) || o.set(u.style, u)));
    let s = o.get(r)
        , a = o.get("italic")
        , l = e.weight;
    l <= 300 ? (s = i.get(`400-${r}`) ?? s,
        a = i.get("400-italic") ?? a) : l <= 500 ? (s = i.get(`700-${r}`) ?? s,
            a = i.get("700-italic") ?? a) : (s = i.get(`900-${r}`) ?? s,
                a = i.get("900-italic") ?? a);
    let c = i.get(`${n}-italic`);
    return {
        variantBold: s,
        variantItalic: c,
        variantBoldItalic: a
    }
}
function _$(e, t) {
    if (t.length === 0)
        return {
            variantVariable: void 0,
            variantVariableItalic: void 0
        };
    let n = new Map;
    for (let r of t)
        r.isVariable && n.set(`${r.weight}-${r.style}`, r);
    return {
        variantVariable: n.get(`${e.weight}-normal`) ?? n.get("400-normal") ?? void 0,
        variantVariableItalic: n.get(`${e.weight}-italic`) ?? n.get("400-italic") ?? void 0
    }
}
var I$ = ["display", "sans", "serif", "slab", "handwritten", "script"];
function O$(e) {
    return e.split(",").map(t => t.trim().toLowerCase()).filter(M$)
}
function M$(e) {
    return I$.includes(e)
}
var Ma = "FS;"
    , XT = {
        thin: 100,
        hairline: 100,
        extralight: 200,
        light: 300,
        regular: 400,
        medium: 500,
        semibold: 600,
        bold: 700,
        extrabold: 800,
        ultra: 800,
        black: 900,
        heavy: 900
    }
    , YT = Object.keys(XT)
    , L$ = (() => new RegExp(`^(?:${[...YT, "italic", "variable"].join("|")})`, "u"))()
    , $a = class {
        constructor() {
            E(this, "name", "fontshare"),
                E(this, "fontFamilies", []),
                E(this, "byFamilyName", new Map)
        }
        getFontFamilyByName(e) {
            return this.byFamilyName.get(e) ?? null
        }
        static parseVariant(e) {
            let t = e.toLowerCase().split(" ")
                , n = YT.find(s => t.includes(s))
                , r = e.toLowerCase().includes("italic") ? "italic" : "normal";
            return {
                weight: n && XT[n] || 400,
                style: r === "italic" ? r : "normal"
            }
        }
        parseSelector(e) {
            if (!e.startsWith(Ma))
                return null;
            let t = e.split("-");
            if (t.length !== 2)
                return null;
            let [n, r] = t;
            return !n || !r ? null : {
                name: n.replace(Ma, ""),
                variant: r,
                source: this.name,
                isVariable: r.toLowerCase().includes("variable")
            }
        }
        static createSelector(e, t) {
            return `${Ma}${e}-${t.toLowerCase()}`
        }
        static createVariationAxesSelector(e) {
            return `${Ma}${e}`
        }
        addFontFamily(e) {
            this.fontFamilies.push(e),
                this.byFamilyName.set(e.name, e)
        }
        importFonts(e, t) {
            this.fontFamilies.length = 0,
                this.byFamilyName.clear();
            let n = [];
            for (let r of e) {
                let o = r.font_styles.filter(u => {
                    let f = u.name.toLowerCase();
                    return !(!L$.exec(f) || f.split(" ").includes("wide"))
                }
                ).map(u => ({
                    ...$a.parseVariant(u.name),
                    selector: $a.createSelector(r.name, u.name),
                    isVariable: u.is_variable,
                    fontshareVariantName: u.name,
                    file: u.file
                }))
                    , s = $a.createVariationAxesSelector(r.name)
                    , a = t?.[s]
                    , l = r.name
                    , c = this.getFontFamilyByName(l);
                c || (c = {
                    name: l,
                    fonts: [],
                    source: this.name
                },
                    this.addFontFamily(c));
                for (let u of o) {
                    let { variantBold: f, variantBoldItalic: d, variantItalic: p, variantVariable: v, variantVariableItalic: g } = qT(u, o)
                        , b = {
                            family: c,
                            variant: u.fontshareVariantName.toLowerCase(),
                            selector: u.selector,
                            selectorBold: f?.selector,
                            selectorBoldItalic: d?.selector,
                            selectorItalic: p?.selector,
                            selectorVariable: v?.selector,
                            selectorVariableItalic: g?.selector,
                            weight: u.weight,
                            style: u.style,
                            file: u.file,
                            category: V$(r.category),
                            variationAxes: u.isVariable ? a : void 0
                        };
                    c.fonts.push(b),
                        n.push(b)
                }
            }
            return n
        }
    }
    ;
function V$(e) {
    let t = {
        serif: "serif",
        sans: "sans-serif",
        slab: "slab",
        display: "display",
        handwritten: "handwriting",
        script: "handwriting"
    }
        , n = O$(e)[0];
    return n && t[n]
}
var A$ = "Inter"
    , D$ = "FR;"
    , z$ = {
        Thin: 100,
        ExtraLight: 200,
        Light: 300,
        "": 400,
        Medium: 500,
        SemiBold: 600,
        Bold: 700,
        ExtraBold: 800,
        Black: 900
    }
    , qm = class {
        constructor() {
            E(this, "name", "framer"),
                E(this, "fontFamilies", []),
                E(this, "byFamilyName", new Map)
        }
        getFontFamilyByName(e) {
            return this.byFamilyName.get(e) ?? null
        }
        addFontFamily(e) {
            let t = {
                name: e,
                fonts: [],
                source: this.name
            };
            return this.fontFamilies.push(t),
                this.byFamilyName.set(t.name, t),
                t
        }
        static getDraftFontPropertiesBySelector(e) {
            if (!e.startsWith(D$) && !e.startsWith(A$))
                return null;
            let t = e.split("-")
                , [n, r = ""] = t;
            if (!n)
                return null;
            let i = r.includes("Italic") ? "italic" : "normal"
                , o = r.replace("Italic", "")
                , s = o && z$[o] || 400;
            return {
                family: n,
                style: i,
                weight: s,
                source: "framer",
                variant: void 0,
                category: "sans-serif"
            }
        }
        static createVariationAxesKey(e) {
            return e.familyName
        }
        importFonts(e, t) {
            this.fontFamilies.length = 0,
                this.byFamilyName.clear();
            let n = [];
            return e.forEach(r => {
                let { familyName: i, ...o } = r
                    , s = qm.createVariationAxesKey(r)
                    , a = t?.[s]
                    , l = this.getFontFamilyByName(i);
                l || (l = this.addFontFamily(i));
                let c = r.selector === r.selectorVariable || r.selector === r.selectorVariableItalic
                    , u = {
                        ...o,
                        family: l,
                        variationAxes: c ? a : void 0
                    };
                l.fonts.push(u),
                    n.push(u)
            }
            ),
                n
        }
    }
    , La = "GF;"
    , qi = class {
        constructor() {
            E(this, "name", "google"),
                E(this, "fontFamilies", []),
                E(this, "byFamilyName", new Map)
        }
        getFontFamilyByName(e) {
            return this.byFamilyName.get(e) ?? null
        }
        static parseVariant(e) {
            if (e === "regular")
                return {
                    style: "normal",
                    weight: 400
                };
            let t = /(\d*)(normal|italic)?/u.exec(e);
            if (!t)
                return {};
            let n = parseInt(t[1] || "400")
                , r = t[2] === "italic" ? "italic" : "normal";
            return {
                weight: n,
                style: r
            }
        }
        parseSelector(e) {
            if (!e.startsWith(La))
                return null;
            let t = e.includes("-variable-")
                , n = t ? e.split("-variable-") : e.split("-");
            if (n.length !== 2)
                return null;
            let [r, i] = n;
            return !r || !i ? null : {
                name: r.replace(La, ""),
                variant: i,
                source: this.name,
                isVariable: t
            }
        }
        static createSelector(e, t, n) {
            return `${La}${e}-${n ? "variable-" : ""}${t}`
        }
        static createVariationAxesSelector(e) {
            return `${La}${e}`
        }
        addFontFamily(e) {
            let t = {
                name: e,
                fonts: [],
                source: this.name
            };
            return this.fontFamilies.push(t),
                this.byFamilyName.set(t.name, t),
                t
        }
        importFonts(e, t, n) {
            var r;
            this.fontFamilies.length = 0,
                this.byFamilyName.clear();
            let i = []
                , o = gk(e, a => a.family)
                , s = gk(t, a => a.family);
            for (let a in o) {
                let l = o[a];
                if (!l)
                    continue;
                let c = this.getFontFamilyByName(l.family);
                c || (c = this.addFontFamily(l.family));
                let f = l.variants.map(h => ({
                    ...qi.parseVariant(h),
                    googleFontsVariantName: h,
                    selector: qi.createSelector(a, h, !1),
                    isVariable: !1,
                    file: l.files[h]
                }))
                    , d = s[a]
                    , p = d?.axes ? d.variants.map(h => ({
                        ...qi.parseVariant(h),
                        googleFontsVariantName: h,
                        selector: qi.createSelector(a, h, !0),
                        isVariable: !0,
                        file: d.files[h]
                    })) : []
                    , v = qi.createVariationAxesSelector(l.family)
                    , g = n?.[v]
                    , b = [...f, ...p]
                    , m = b.filter(Wu);
                for (let h of b) {
                    let { weight: y, style: w, selector: C, googleFontsVariantName: S } = h
                        , T = Wu(h) ? qT(h, m) : void 0
                        , { variantBold: R, variantItalic: F, variantBoldItalic: P, variantVariable: B, variantVariableItalic: $ } = T ?? {}
                        , N = {
                            family: c,
                            variant: S,
                            selector: C,
                            selectorBold: R?.selector,
                            selectorBoldItalic: P?.selector,
                            selectorItalic: F?.selector,
                            selectorVariable: B?.selector,
                            selectorVariableItalic: $?.selector,
                            weight: y,
                            style: w,
                            category: B$(l.category),
                            file: (r = h.file) == null ? void 0 : r.replace("http://", "https://"),
                            variationAxes: h.isVariable ? g : void 0
                        };
                    c.fonts.push(N),
                        i.push(N)
                }
            }
            return i
        }
    }
    ;
function B$(e) {
    let t = {
        serif: "serif",
        "sans-serif": "sans-serif",
        display: "display",
        handwriting: "handwriting",
        monospace: "monospace"
    };
    if (e)
        return t[e]
}
function gk(e, t) {
    return e.reduce((n, r) => (n[t(r)] = r,
        n), {})
}
var $$ = yr(KM(), 1)
    , vk = 5e3
    , N$ = 3
    , KT = class extends Error {
        constructor(e) {
            super(e),
                this.name = "FontLoadingError"
        }
    }
    , Fm = new Map
    , Pm = new Map
    , yk = (e, t) => QT(e, t);
async function QT(e, t, n = 0) {
    let { family: r, url: i, stretch: o, unicodeRange: s, isVariableFont: a } = e
        , l = a ? e.weight : e.weight || 500
        , c = e.style || "normal"
        , u = `${r}-${c}-${l}-${i}`;
    if (!Fm.has(u) || n > 0) {
        let f = new FontFace(r, `url(${i})`, {
            weight: ye(l) ? l : l?.toString(),
            style: c,
            stretch: o,
            unicodeRange: s
        })
            , d = f.load().then(() => (t.fonts.add(f),
                ZT(r, c, l))).catch(p => {
                    if (p.name !== "NetworkError")
                        throw p;
                    if (n < N$)
                        return QT(e, t, n + 1);
                    throw new KT(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({
                        family: r,
                        style: c,
                        weight: l,
                        url: i,
                        stretch: o,
                        unicodeRange: s
                    })}`)
                }
                );
        Fm.set(u, d)
    }
    await Fm.get(u)
}
async function ZT(e, t, n) {
    let r = `${e}-${t}-${n}`;
    if (!Pm.has(r)) {
        let o = new $$.default(e, {
            style: t,
            weight: n
        }).load(null, vk);
        Pm.set(r, o)
    }
    try {
        await Pm.get(r)
    } catch {
        throw new KT(`Failed to check if font is ready (${vk}ms timeout exceeded): ${JSON.stringify({
            family: e,
            style: t,
            weight: n
        })}`)
    }
}
var bk = {
    Inter: [{
        tag: "opsz",
        minValue: 14,
        maxValue: 32,
        defaultValue: 14,
        name: "Optical size"
    }, {
        tag: "wght",
        minValue: 100,
        maxValue: 900,
        defaultValue: 400,
        name: "Weight"
    }]
};
function _m(e) {
    try {
        if (e === "framer")
            return xk(bk) ? bk : void 0;
        {
            let t = (async () => {
                switch (e) {
                    case "google":
                        return (await import("./google-5Y2W5CAB-KAMWJK7N.mjs")).default;
                    case "fontshare":
                        return (await import("./fontshare-XR4PZDC4-PHFHRCTW.mjs")).default;
                    default:
                        Ce(e)
                }
            }
            )();
            return xk(t) ? t : void 0
        }
    } catch (t) {
        console.error(t);
        return
    }
}
function xk(e) {
    return Se(e) && Object.values(e).every(H$)
}
function j$(e) {
    return Se(e) && ye(e.tag)
}
function H$(e) {
    return Array.isArray(e) && e.every(j$)
}
var W$ = class {
    constructor() {
        E(this, "enabled", !1),
            E(this, "bySelector", new Map),
            E(this, "getGoogleFontsListPromise"),
            E(this, "getFontshareFontsListPromise"),
            E(this, "loadedSelectors", new Set),
            E(this, "local"),
            E(this, "google"),
            E(this, "fontshare"),
            E(this, "framer"),
            E(this, "custom"),
            this.local = new k$,
            this.google = new qi,
            this.fontshare = new $a,
            this.framer = new qm,
            this.custom = new F$,
            this.bySelector = new Map,
            this.importLocalFonts()
    }
    addFont(e) {
        this.bySelector.set(e.selector, e)
    }
    getAvailableFonts() {
        return Array.from(this.bySelector.values())
    }
    importLocalFonts() {
        for (let e of this.local.importFonts())
            this.addFont(e),
                this.loadFont(e)
    }
    async importGoogleFonts() {
        return this.getGoogleFontsListPromise || (this.getGoogleFontsListPromise = Promise.resolve().then(async () => {
            let { staticFonts: e, variableFonts: t } = await vt.fetchGoogleFontsList()
                , n = await _m("google");
            for (let r of this.google.importFonts(e, t, n))
                this.addFont(r);
            return {
                staticFonts: e,
                variableFonts: t
            }
        }
        )),
            this.getGoogleFontsListPromise
    }
    async importFontshareFonts() {
        if (!this.getFontshareFontsListPromise) {
            this.getFontshareFontsListPromise = vt.fetchFontshareFontsList();
            let e = await this.getFontshareFontsListPromise
                , t = await _m("fontshare");
            for (let n of this.fontshare.importFonts(e, t))
                this.addFont(n)
        }
        return this.getFontshareFontsListPromise
    }
    importFramerFonts(e) {
        let t = _m("framer");
        this.framer.importFonts(e, t).forEach(n => {
            this.addFont(n)
        }
        )
    }
    importCustomFonts(e) {
        this.bySelector.forEach((t, n) => {
            n.startsWith(ns) && this.bySelector.delete(n)
        }
        );
        for (let t of this.custom.importFonts(e))
            this.addFont(t)
    }
    getFontFamily(e) {
        return this[e.source].getFontFamilyByName(e.name)
    }
    getFontBySelector(e, t = !0) {
        if (e)
            return e.startsWith(ns) ? this.custom.getFontBySelector(e, t) : this.bySelector.get(e)
    }
    getDraftPropertiesBySelector(e) {
        let t = this.getFontBySelector(e);
        if (t)
            return {
                style: t.style,
                weight: t.weight,
                variant: t.variant,
                family: Em(t),
                source: t.family.source,
                category: t.category
            };
        let n = this.google.parseSelector(e);
        if (n) {
            let o = qi.parseVariant(n.variant);
            if (Wu(o))
                return {
                    style: o.style,
                    weight: o.weight,
                    variant: n.variant,
                    family: n.name,
                    source: "google",
                    category: void 0
                }
        }
        let r = this.fontshare.parseSelector(e);
        if (r) {
            let o = $a.parseVariant(r.variant);
            if (Wu(o))
                return {
                    style: o.style,
                    weight: o.weight,
                    variant: r.variant,
                    family: r.name,
                    source: "fontshare",
                    category: void 0
                }
        }
        let i = qm.getDraftFontPropertiesBySelector(e);
        return i || null
    }
    isSelectorLoaded(e) {
        return this.loadedSelectors.has(e)
    }
    async loadFont(e) {
        if (this.isSelectorLoaded(e.selector))
            return 0;
        let t = e.family.source
            , n = GT(e);
        switch (t) {
            case "local":
                return this.loadedSelectors.add(e.selector),
                    1;
            case "framer":
                if (T$.default.env.NODE_ENV !== "test" && await ZT(e.family.name, e.style, e.weight),
                    n) {
                    if (!e.file)
                        return Promise.reject(`Unable to load font: ${e.selector}`);
                    await yk({
                        family: Em(e),
                        url: e.file,
                        weight: e.weight,
                        style: e.style,
                        isVariableFont: n
                    }, document)
                }
                return this.loadedSelectors.add(e.selector),
                    1;
            case "google":
            case "fontshare":
            case "custom":
                return e.file ? (await yk({
                    family: Em(e),
                    url: e.file,
                    weight: e.weight,
                    style: e.style,
                    isVariableFont: n
                }, document),
                    this.loadedSelectors.add(e.selector),
                    1) : Promise.reject(`Unable to load font: ${e.selector}`);
            default:
                Ce(t)
        }
    }
    async loadFontsFromSelectors(e) {
        if (!this.enabled)
            return [];
        let t = e.some(i => i.startsWith(La))
            , n = e.some(i => i.startsWith(Ma));
        if (t || n) {
            try {
                await this.importFontshareFonts()
            } catch (i) {
                ja("Failed to load Fontshare fonts:", i)
            }
            try {
                await this.importGoogleFonts()
            } catch (i) {
                ja("Failed to load Google fonts:", i)
            }
        }
        let r = e.map(i => this.bySelector.get(i)).filter(i => !!i);
        return Promise.allSettled(r.map(i => this.loadFont(i)))
    }
    async loadFonts(e) {
        return {
            newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(r => r.status === "fulfilled" && r.value === 1).length
        }
    }
    async loadMissingFonts(e, t) {
        let n = e.filter(i => !Tu.isSelectorLoaded(i));
        if (n.length === 0)
            return;
        await Tu.loadWebFontsFromSelectors(n),
            n.every(i => Tu.isSelectorLoaded(i)) && t && t()
    }
    async loadWebFontsFromSelectors(e) {
        return this.loadFontsFromSelectors(e)
    }
    get defaultFont() {
        let e = this.getFontBySelector("Inter");
        return A(e, "Can\u2019t find Inter font"),
            e
    }
}
    , Tu = new W$;
Promise.allSettled = Promise.allSettled || (e => Promise.all(e.map(t => t.then(n => ({
    status: "fulfilled",
    value: n
})).catch(n => ({
    status: "rejected",
    reason: n
})))));
var JT = (e => (e.Padding = "--framer-input-padding",
    e.BorderRadiusTopLeft = "--framer-input-border-radius-top-left",
    e.BorderRadiusTopRight = "--framer-input-border-radius-top-right",
    e.BorderRadiusBottomRight = "--framer-input-border-radius-bottom-right",
    e.BorderRadiusBottomLeft = "--framer-input-border-radius-bottom-left",
    e.BorderColor = "--framer-input-border-color",
    e.BorderTopWidth = "--framer-input-border-top-width",
    e.BorderRightWidth = "--framer-input-border-right-width",
    e.BorderBottomWidth = "--framer-input-border-bottom-width",
    e.BorderLeftWidth = "--framer-input-border-left-width",
    e.BorderStyle = "--framer-input-border-style",
    e.Background = "--framer-input-background",
    e.FontFamily = "--framer-input-font-family",
    e.FontWeight = "--framer-input-font-weight",
    e.FontSize = "--framer-input-font-size",
    e.FontColor = "--framer-input-font-color",
    e.FontStyle = "--framer-input-font-style",
    e.FontLetterSpacing = "--framer-input-font-letter-spacing",
    e.FontTextAlignment = "--framer-input-font-text-alignment",
    e.FontLineHeight = "--framer-input-font-line-height",
    e.FontOpenType = "--framer-input-font-open-type-features",
    e.PlaceholderColor = "--framer-input-placeholder-color",
    e.BoxShadow = "--framer-input-box-shadow",
    e.FocusedBorderColor = "--framer-input-focused-border-color",
    e.FocusedBorderWidth = "--framer-input-focused-border-width",
    e.FocusedBorderStyle = "--framer-input-focused-border-style",
    e.FocusedBackground = "--framer-input-focused-background",
    e.FocusedBoxShadow = "--framer-input-focused-box-shadow",
    e.FocusedTransition = "--framer-input-focused-transition",
    e.BooleanCheckedBackground = "--framer-input-boolean-checked-background",
    e.BooleanCheckedBorderColor = "--framer-input-boolean-checked-border-color",
    e.BooleanCheckedBorderWidth = "--framer-input-boolean-checked-border-width",
    e.BooleanCheckedBorderStyle = "--framer-input-boolean-checked-border-style",
    e.BooleanCheckedBoxShadow = "--framer-input-boolean-checked-box-shadow",
    e.BooleanCheckedTransition = "--framer-input-boolean-checked-transition",
    e.InvalidTextColor = "--framer-input-invalid-text-color",
    e.IconBackgroundImage = "--framer-input-icon-image",
    e.IconMaskImage = "--framer-input-icon-mask-image",
    e.IconColor = "--framer-input-icon-color",
    e.WrapperHeight = "--framer-input-wrapper-height",
    e))(JT || {})
    , Fe = JT
    , Nt = "framer-form-input"
    , Za = "framer-form-input-wrapper"
    , eR = "framer-form-input-empty"
    , Uu = "framer-form-input-forced-focus";
function U$(e) {
    return typeof e == "number" ? e : e.startsWith("--") ? z.variable(e) : e === "" ? '""' : e
}
function z(e, t) {
    let n = " ";
    for (let r in t) {
        let i = t[r];
        n += `${r.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${U$(i)}; `
    }
    return e + " {" + n + "}"
}
(e => {
    function t(...n) {
        let r = n[n.length - 1]
            , i = r.startsWith("--") ? `var(${r})` : r;
        for (let o = n.length - 2; o >= 0; o--)
            i = `var(${n[o]}, ${i})`;
        return i
    }
    e.variable = t
}
)(z || (z = {}));
var tR = [z(`.${Nt}`, {
    padding: z.variable(Fe.Padding),
    background: "transparent",
    fontFamily: z.variable(Fe.FontFamily),
    fontWeight: z.variable(Fe.FontWeight),
    fontSize: z.variable(Fe.FontSize),
    fontStyle: z.variable(Fe.FontStyle),
    color: z.variable(Fe.FontColor),
    fontFeatureSettings: z.variable(Fe.FontOpenType),
    border: "none",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden",
    width: "100%",
    height: z.variable(Fe.WrapperHeight, "100%"),
    letterSpacing: z.variable(Fe.FontLetterSpacing),
    textAlign: z.variable(Fe.FontTextAlignment),
    lineHeight: z.variable(Fe.FontLineHeight)
}), z(`.${Nt}:focus-visible`, {
    outline: "none"
})]
    , nR = (() => [z(`.${Za}`, {
        overflow: "hidden"
    })])()
    , rR = `var(${Fe.BorderTopWidth}) var(${Fe.BorderRightWidth}) var(${Fe.BorderBottomWidth}) var(${Fe.BorderLeftWidth})`
    , iR = [`.${Za}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${Fe.BorderRadiusTopLeft});
        border-top-right-radius: var(${Fe.BorderRadiusTopRight});
        border-bottom-right-radius: var(${Fe.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${Fe.BorderRadiusBottomLeft});
        border-color: var(${Fe.BorderColor});
        border-top-width: var(${Fe.BorderTopWidth});
        border-right-width: var(${Fe.BorderRightWidth});
        border-bottom-width: var(${Fe.BorderBottomWidth});
        border-left-width: var(${Fe.BorderLeftWidth});
        border-style: var(${Fe.BorderStyle});
        transition: var(${Fe.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius;
    }`]
    , G$ = "customError"
    , q$ = "valid";
function X$(e) {
    return e !== G$ && e !== q$
}
function wk(e) {
    for (let t in e)
        if (X$(t) && e?.[t] === !0)
            return !0;
    return !1
}
function oR(e, t, n, r, i) {
    let o = x.useRef(null)
        , s = x.useCallback(c => {
            t && o.current !== !1 && (o.current = !1,
                c.currentTarget.setCustomValidity(" "),
                c.currentTarget.reportValidity(),
                t(c))
        }
            , [t])
        , a = x.useCallback(c => {
            if (n?.(c),
                !t && !e)
                return;
            let u = c.target.validity;
            o.current === !1 && !wk(u) && (c.currentTarget.setCustomValidity(""),
                c.target.reportValidity(),
                o.current = !0,
                e?.())
        }
            , [t, e, n])
        , l = x.useCallback(c => {
            if (!t) {
                r?.(c);
                return
            }
            if (o.current === !1)
                return;
            let u = c.currentTarget.validity;
            if (wk(u)) {
                s(c);
                return
            }
            r?.(c)
        }
            , [s, r, t]);
    return x.useMemo(() => ({
        onInvalid: s,
        onChange: a,
        onBlur: l,
        onFocus: i
    }), [s, a, l, i])
}
var os = 10
    , Im = 16
    , sR = {
        content: "",
        display: "block",
        position: "absolute",
        right: 0,
        top: 0,
        bottom: 0,
        width: `${Im}px`,
        boxSizing: "content-box",
        padding: z.variable(Fe.Padding),
        border: "none",
        pointerEvents: "none",
        backgroundRepeat: "no-repeat",
        backgroundSize: `${Im}px`,
        maskRepeat: "no-repeat",
        maskSize: `${Im}px`,
        backgroundColor: z.variable(Fe.IconColor)
    }
    , Y$ = {
        "data-1p-ignore": !0,
        "data-lpignore": !0,
        "data-form-type": "other",
        autocomplete: "off"
    }
    , K$ = Ie(function (t, n) {
        let { autoFocus: r, className: i, inputName: o, max: s, min: a, placeholder: l, required: c, step: u, style: f, type: d, maxLength: p, defaultValue: v, autofillEnabled: g, onChange: b, onBlur: m, onInvalid: h, onFocus: y, onValid: w, ...C } = t
            , [S, T] = Ee(!!v)
            , [R, F] = Ee();
        v !== R && (T(!!v),
            F(v));
        let P = Q(async N => {
            await Zi();
            let U = N.target.value;
            b?.(N),
                at(() => T(!!U))
        }
            , [b])
            , B = oR(w, h, P, m, y);
        if (d === "hidden")
            return k(Ye.input, {
                type: "hidden",
                name: o,
                defaultValue: v
            });
        let $ = g === !1 ? Y$ : void 0;
        return k(Ye.div, {
            ref: n,
            style: f,
            className: no(st, Za, i),
            ...C,
            children: d === "textarea" ? Nr(Ye.textarea, {
                ...$,
                ...B,
                key: v,
                required: c,
                autoFocus: r,
                name: o,
                placeholder: l,
                className: Nt,
                defaultValue: v,
                maxLength: p
            }) : Nr(Ye.input, {
                ...$,
                ...B,
                key: v,
                type: d,
                required: c,
                autoFocus: r,
                name: o,
                placeholder: l,
                className: no(Nt, !S && eR),
                defaultValue: v,
                min: a,
                max: s,
                step: u,
                maxLength: p
            })
        })
    })
    , Q$ = 16
    , st = "framer-form-text-input"
    , Z$ = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14"><path d="m1.5 8 7-7M9 5.5l-3 3" stroke="%23999" stroke-width="1.5" stroke-linecap="round"></path></svg>'
    , J$ = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="rgb(153, 153, 153)" d="M3 5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2H3Z" opacity=".3"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M3.25 5.25a2 2 0 0 1 2-2h5.5a2 2 0 0 1 2 2v5.5a2 2 0 0 1-2 2h-5.5a2 2 0 0 1-2-2ZM3 6.75h9.5"/></svg>'
    , eN = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M2.5 8a5.5 5.5 0 1 1 11 0 5.5 5.5 0 1 1-11 0Z"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7.75 8.25v-3m0 3h2"/></svg>'
    , tN = (() => [...tR, ...iR, ...nR, z(`.${Za}`, {
        boxShadow: z.variable("--framer-input-box-shadow"),
        borderTopLeftRadius: z.variable("--framer-input-border-radius-top-left"),
        borderTopRightRadius: z.variable("--framer-input-border-radius-top-right"),
        borderBottomRightRadius: z.variable("--framer-input-border-radius-bottom-right"),
        borderBottomLeftRadius: z.variable("--framer-input-border-radius-bottom-left"),
        background: z.variable("--framer-input-background"),
        transition: z.variable("--framer-input-focused-transition"),
        transitionProperty: "background, box-shadow"
    }), z(`.${st} .${Nt}::placeholder`, {
        color: z.variable("--framer-input-placeholder-color")
    }), z(`.${st} .${Nt}[type="date"], .${st} .${Nt}[type="time"]`, {
        "-webkit-appearance": "none",
        appearance: "none"
    }), z(`.${st} .${Nt}::-webkit-date-and-time-value`, {
        textAlign: "start"
    }), z(`.${st} textarea`, {
        display: "flex",
        resize: z.variable("--framer-textarea-resize"),
        overflowY: "auto",
        minHeight: "inherit",
        maxHeight: "inherit",
        whiteSpace: "break-spaces"
    }), z(`.${st} textarea::-webkit-resizer`, {
        background: `no-repeat url('${Z$}')`
    }), z(`.${st} textarea::-webkit-scrollbar`, {
        cursor: "pointer",
        background: "transparent"
    }), z(`.${st} textarea::-webkit-scrollbar-thumb:window-inactive`, {
        opacity: 0
    }), z(`.${st} textarea::-webkit-scrollbar-corner`, {
        background: "none",
        backgroundColor: "transparent",
        outline: "none"
    }), z(`.${st} .${Nt}.${eR}::-webkit-datetime-edit`, {
        color: z.variable("--framer-input-placeholder-color"),
        "-webkit-text-fill-color": z.variable("--framer-input-placeholder-color"),
        height: z.variable("--framer-input-font-line-height"),
        overflow: "visible"
    }), z(`.${st} .${Nt}[type="date"]::before, .${st} .${Nt}[type="time"]::before`, {
        ...sR,
        paddingLeft: `${os}px`,
        maskPosition: `${os}px center`,
        backgroundPosition: `${os}px center`
    }), z(`.${st} .${Nt}[type="date"]::before`, {
        maskImage: z.variable("--framer-input-icon-mask-image", `url('${J$}')`),
        backgroundImage: z.variable("--framer-input-icon-image")
    }), z(`.${st} .${Nt}[type="time"]::before`, {
        maskImage: z.variable("--framer-input-icon-mask-image", `url('${eN}')`),
        backgroundImage: z.variable("--framer-input-icon-image")
    }), z(`.${st} .${Nt}::-webkit-calendar-picker-indicator`, {
        opacity: 0,
        position: "absolute",
        right: 0,
        top: 0,
        bottom: 0,
        padding: z.variable("--framer-input-padding"),
        paddingTop: 0,
        paddingBottom: 0,
        width: `${Q$}px`,
        height: "100%"
    }), z(`.${st}:focus-within, .${st}.${Uu}`, {
        boxShadow: z.variable("--framer-input-focused-box-shadow", "--framer-input-box-shadow"),
        background: z.variable("--framer-input-focused-background", "--framer-input-background")
    }), z(`.${st}:focus-within::after, .${st}.${Uu}::after`, {
        borderColor: z.variable("--framer-input-focused-border-color", "--framer-input-border-color"),
        borderStyle: z.variable("--framer-input-focused-border-style", "--framer-input-border-style"),
        borderWidth: z.variable("--framer-input-focused-border-width", rR)
    })])()
    , V9 = nf(K$, tN);
var nN = x.forwardRef(function (t, n) {
    let { autoFocus: r, className: i, inputName: o, required: s, hidden: a, defaultValue: l, selectOptions: c, style: u, onValid: f, onChange: d, onBlur: p, onInvalid: v, onFocus: g, ...b } = t
        , m = oR(f, v, d, p, g)
        , h = Array.isArray(l) ? l[0] : l;
    return a ? k(Ye.input, {
        type: "hidden",
        name: o,
        defaultValue: l
    }) : k(Ye.div, {
        ref: n,
        style: u,
        className: no(Za, jn, i),
        ...b,
        children: k(Ye.select, {
            name: o,
            autoFocus: r,
            required: s,
            className: Nt,
            defaultValue: l,
            ...m,
            children: c?.map((y, w) => {
                switch (y.type) {
                    case "divider":
                        return k("hr", {}, w);
                    case "option":
                        return k("option", {
                            value: y.value ?? y.title,
                            disabled: y.disabled,
                            children: y.title ?? y.value
                        }, w)
                }
            }
            )
        }, h)
    })
})
    , jn = "framer-form-select-wrapper"
    , Sk = 16
    , rN = (() => `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${Sk}" height="${Sk}"><path d="M 3.5 6 L 8 10.5 L 12.5 6" fill="transparent" stroke-width="1.5" stroke="rgb(153, 153, 153)" stroke-linecap="round" stroke-linejoin="round"></path></svg>`)()
    , iN = (() => [...tR, ...iR, ...nR, z(`.${jn}`, {
        padding: z.variable("--framer-input-padding"),
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        background: z.variable("--framer-input-background"),
        borderTopLeftRadius: z.variable("--framer-input-border-radius-top-left"),
        borderTopRightRadius: z.variable("--framer-input-border-radius-top-right"),
        borderBottomRightRadius: z.variable("--framer-input-border-radius-bottom-right"),
        borderBottomLeftRadius: z.variable("--framer-input-border-radius-bottom-left"),
        boxShadow: z.variable("--framer-input-box-shadow"),
        transition: z.variable("--framer-input-focused-transition"),
        transitionProperty: "background, box-shadow"
    }), z(`.${jn} select`, {
        appearance: "none",
        "-webkit-appearance": "none",
        padding: z.variable("--framer-input-padding"),
        background: "transparent"
    }), z(`.${jn}::before`, {
        ...sR,
        paddingLeft: `${os}px`,
        backgroundPosition: `${os}px center`,
        maskPosition: `${os}px center`,
        backgroundImage: z.variable("--framer-input-icon-image"),
        maskImage: z.variable("--framer-input-icon-mask-image", `url('${rN}')`)
    }), z(`.${jn} select:required:invalid`, {
        color: z.variable("--framer-input-invalid-text-color")
    }), z(`.${jn}:focus-within, .${jn}.${Uu}`, {
        background: z.variable("--framer-input-focused-background", "--framer-input-background"),
        boxShadow: z.variable("--framer-input-focused-box-shadow", "--framer-input-box-shadow")
    }), z(`.${jn}:focus-within::after, .${jn}.${Uu}::after`, {
        borderColor: z.variable("--framer-input-focused-border-color", "--framer-input-border-color"),
        borderStyle: z.variable("--framer-input-focused-border-style", "--framer-input-border-style"),
        borderWidth: z.variable("--framer-input-focused-border-width", rR)
    }), z(`.${jn} select option`, {
        color: "#000"
    }), z(`.${jn} select option:disabled`, {
        color: "rgba(0, 0, 0, 0.4)"
    })])()
    , $9 = nf(nN, iN)
    , H9 = x.forwardRef(function (t, n) {
        let { background: r, children: i, alt: o, draggable: s, ...a } = t
            , l = {
                ...a.style
            };
        r && delete l.background;
        let c = Ya(t.as);
        return ge(c, {
            ...a,
            style: l,
            ref: n,
            children: [r && k(gC, {
                image: r,
                alt: o,
                draggable: s
            }), i]
        })
    });
function oN(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r])
}
var sN = /[^\p{Letter}\p{Number}()]+/gu
    , aN = /^-+|-+$/gu;
function lN(e) {
    return e.toLowerCase().replace(sN, "-").replace(aN, "")
}
var cN = /[&<>'"]/gu
    , uN = e => e.replace(cN, t => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
    })[t] || t)
    , fN = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
function dN(e, t, n, r) {
    return e.replace(fN, (i, o, s, a, l, c, u) => {
        var f, d;
        if (s.toLowerCase() !== "a")
            return i;
        let p = l || c
            , v = yg(p.replace(/&amp;/gu, "&"));
        if (!v || !v.target)
            return i;
        let g = t(v.target);
        if (!h1(g) || !h1(n))
            return i;
        let b = g.path
            , m = n.path;
        if (!b || !m)
            return i;
        let h = ` data-framer-page-link-target="${v.target}"`
            , y = qu(g, v.element ?? void 0);
        y && (h += ` data-framer-page-link-element="${v.element}"`);
        let w = Ga(p);
        if (!w || ye(w))
            return i;
        oT(n, w, r) && (h += " data-framer-page-link-current");
        let C = b
            , S = Object.assign({}, r, (f = v.collectionItem) == null ? void 0 : f.pathVariables);
        if (Object.keys(S).length > 0 && (C = C.replace(iT, (T, R) => "" + S[R])),
            (d = v.collectionItem) != null && d.pathVariables) {
            let T = new URLSearchParams(v.collectionItem.pathVariables);
            h += ` data-framer-page-link-path-variables="${T}"`
        }
        return C = Vk(m, C),
            o + a + `"${uN(C + (y ? `#${y}` : ""))}"` + h + u
    }
    )
}
var hN = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
}
    , aR = /[&<>"']/gu
    , pN = (() => new RegExp(aR.source))();
function kk(e) {
    return e && pN.test(e) ? e.replace(aR, t => hN[t] ?? "") : e || ""
}
var Ck = "{{ text-placeholder }}"
    , mN = "rich-text-wrapper"
    , gN = Ie(function (t, n) {
        let { id: r, name: i, html: o, htmlFromDesign: s, text: a, textFromDesign: l, fonts: c = [], width: u, height: f, left: d, right: p, top: v, bottom: g, center: b, className: m, stylesPresetsClassName: h, visible: y = !0, opacity: w, rotation: C = 0, verticalAlignment: S = "top", isEditable: T = !1, willChangeTransform: R, environment: F = fe.current, withExternalLayout: P = !1, positionSticky: B, positionStickyTop: $, positionStickyRight: N, positionStickyBottom: U, positionStickyLeft: j, __htmlStructure: ae, __fromCanvasComponent: te = !1, _forwardedOverrideId: Y, _forwardedOverrides: ne, _usesDOMRect: G, children: he, ...se } = t
            , le = qa()
            , q = fs(t)
            , Je = V(null)
            , Re = n ?? Je
            , { navigate: et, getRoute: Pe } = bi()
            , mn = ro();
        dV(t.preload ?? []),
            Ju(t, Re);
        let Tt = D(ds)
            , qn = hs()
            , pe = a
            , Jt = Y ?? r;
        if (Jt && ne) {
            let tt = ne[Jt];
            typeof tt == "string" && (pe = tt)
        }
        let dt = "";
        if (pe) {
            let tt = kk(pe);
            dt = ae ? ae.replace(Ck, tt) : `<p>${tt}</p>`
        } else if (o)
            dt = o;
        else if (l) {
            let tt = kk(l);
            dt = ae ? ae.replace(Ck, tt) : `<p>${tt}</p>`
        } else
            s && (dt = s);
        let gn = xg()
            , Ja = ue(() => qn || !Pe || !mn ? dt : dN(dt, Pe, mn, gn), [qn, dt, Pe, mn, gn]);
        if (H(() => {
            let tt = Re.current;
            if (tt === null)
                return;
            function vr(en) {
                let xi = vg(en.target, Re.current);
                if (en.metaKey || !et || !xi || xi.getAttribute("target") === "_blank")
                    return;
                K5(et, xi, gn) && en.preventDefault()
            }
            return tt.addEventListener("click", vr),
                () => {
                    tt.removeEventListener("click", vr)
                }
        }
            , [et, gn]),
            cR(c, te, Re),
            ht(() => {
                Xa()
            }
                , []),
            !y)
            return null;
        let _ = T && F() === fe.canvas
            , O = {
                outline: "none",
                display: "flex",
                flexDirection: "column",
                justifyContent: lR(S),
                opacity: _ ? 0 : w,
                flexShrink: 0
            }
            , L = fe.hasRestrictions()
            , K = Ha(t, le || 0, !1)
            , ve = G && (u === "auto" || f === "auto")
            , bt = !!t.transformTemplate || !K || !L || te || ve ? t.transformTemplate ?? Qu(b) : void 0;
        if (!P) {
            if (K && L && !ve) {
                let tt = ft.getNumber(C).toFixed(4);
                O.transform = `translate(${K.x}px, ${K.y}px) rotate(${tt}deg)`,
                    O.width = K.width,
                    O.minWidth = K.width,
                    O.height = K.height
            } else
                O.left = d,
                    O.right = p,
                    O.top = v,
                    O.bottom = g,
                    O.width = u,
                    O.height = f,
                    O.rotate = C;
            B ? (!qn || Tt) && (O.position = "sticky",
                O.willChange = "transform",
                O.zIndex = 1,
                O.top = $,
                O.right = N,
                O.bottom = U,
                O.left = j) : qn && (t.positionFixed || t.positionAbsolute) && (O.position = "absolute")
        }
        return pg(t, O),
            MC(t, O),
            R && cg(O),
            Object.assign(O, t.style),
            k(Ye.div, {
                id: r,
                ref: Re,
                ...se,
                style: O,
                layoutId: q,
                "data-framer-name": i,
                "data-framer-component-type": "DeprecatedRichText",
                "data-center": b,
                className: no(m, h, mN),
                transformTemplate: bt,
                dangerouslySetInnerHTML: {
                    __html: Ja
                }
            })
    });
function lR(e) {
    switch (e) {
        case "top":
            return "flex-start";
        case "center":
            return "center";
        case "bottom":
            return "flex-end"
    }
}
function cR(e, t, n) {
    let r = V([]);
    oN(r.current, e) || (r.current = e,
        Tu.loadFonts(e).then(({ newlyLoadedFontCount: i }) => {
            !t || !n.current || fe.current() !== fe.canvas || i > 0 && jD(n.current)
        }
        ))
}
function Xm() {
    return {
        current: null
    }
}
async function uR(e, t) {
    let n = e.current;
    if (n)
        return n;
    let r, i = new Promise((o, s) => {
        r = o,
            t.signal.addEventListener("abort", () => s())
    }
    );
    return Object.defineProperty(e, "current", {
        get() {
            return n
        },
        set(o) {
            if (n = o,
                o === null) {
                t.abort();
                return
            }
            r(o)
        },
        configurable: !0
    }),
        i
}
var fR = {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    skewX: 0,
    skewY: 0,
    filter: "none"
};
function vN(e) {
    return e in fR
}
function yN(e) {
    let t = {};
    for (let n in e)
        !vN(n) || Qe(e[n]) || (t[n] = [e[n], fR[n]]);
    return t
}
var bN = /\p{Regional_Indicator}{2}|\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?(?:\u{200d}\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?)*|./gu;
function xN(e, t = "character", n, r) {
    switch (t) {
        case "character":
        case "line":
            {
                let i = e.split(" ")
                    , o = i.length - 1;
                return i.map((s, a) => {
                    var l;
                    let c = a === o
                        , u = s.length <= 12;
                    return ge(bn, {
                        children: [k("span", {
                            style: {
                                whiteSpace: u ? "nowrap" : "unset"
                            },
                            children: (l = s.match(bN)) == null ? void 0 : l.map((f, d) => {
                                let p = Xm();
                                return n.add(p),
                                    k("span", {
                                        ref: p,
                                        style: r,
                                        children: f
                                    }, f + d)
                            }
                            )
                        }), c ? null : " "]
                    }, s + a + c)
                }
                )
            }
        case "word":
            {
                let i = e.split(" ")
                    , o = i.length - 1;
                return i.map((s, a) => {
                    let l = a === o
                        , c = Xm();
                    return n.add(c),
                        ge(bn, {
                            children: [k("span", {
                                ref: c,
                                style: r,
                                children: s
                            }), l ? null : " "]
                        }, s + a + l)
                }
                )
            }
        case "element":
        default:
            return e
    }
}
function wN(e) {
    let t = e.type;
    switch (t) {
        case "appear":
            return e.tokenization ?? "character";
        default:
            Ce(t)
    }
}
function Tk(e) {
    let t = [];
    return De(e.x) && t.push(`translateX(${e.x}px)`),
        De(e.y) && t.push(`translateY(${e.y}px)`),
        De(e.scale) && t.push(`scale(${e.scale})`),
        De(e.rotate) && t.push(`rotate(${e.rotate}deg)`),
        De(e.rotateX) && t.push(`rotateX(${e.rotateX}deg)`),
        De(e.rotateY) && t.push(`rotateY(${e.rotateY}deg)`),
        De(e.skewX) && t.push(`skewX(${e.skewX}deg)`),
        De(e.skewY) && t.push(`skewY(${e.skewY}deg)`),
        t.join(" ")
}
function SN(e, t, n) {
    if (!n || !n.effect)
        return;
    let r = n.type;
    switch (r) {
        case "appear":
            switch (n.tokenization) {
                case "element":
                    return !e || !t ? void 0 : {
                        opacity: n.effect.opacity,
                        filter: n.effect.filter,
                        transform: Tk(n.effect)
                    };
                case "line":
                case "word":
                case "character":
                default:
                    return !e || !t ? {
                        display: "inline-block"
                    } : {
                        display: "inline-block",
                        opacity: n.effect.opacity,
                        filter: n.effect.filter,
                        transform: Tk(n.effect)
                    }
            }
        default:
            Ce(r)
    }
}
function kN(e, t, n) {
    let r = yt(() => new Set)
        , i = hs()
        , o = n || !i
        , s = V({
            hasMounted: !1,
            hasAnimatedOnce: !1,
            isAnimating: !1,
            effect: e
        });
    s.current.effect = e;
    let a = e?.trigger ?? "onMount"
        , l = e?.target
        , c = e?.threshold;
    H(() => {
        if (!o || n)
            return;
        s.current.hasMounted = !0;
        function d() {
            let { effect: p } = s.current;
            if (!o || !p || p?.repeat !== !0 && s.current.hasAnimatedOnce || p?.type === "appear" && s.current.isAnimating)
                return;
            Object.assign(s.current, {
                hasAnimatedOnce: !0,
                isAnimating: !0
            });
            let v = p.type;
            switch (v) {
                case "appear":
                    {
                        let { transition: g, startDelay: b, repeat: m, tokenization: h } = p
                            , y = {
                                current: void 0
                            };
                        return Rk(h, p.effect, r, g, b, m, () => {
                            Object.assign(s.current, {
                                isAnimating: !1
                            })
                        }
                            , y),
                            () => {
                                var w;
                                return (w = y.current) == null ? void 0 : w.call(y)
                            }
                    }
                default:
                    Ce(v)
            }
        }
        switch (a) {
            case "onMount":
                d();
                return;
            case "onInView":
                {
                    let p = t?.current;
                    return p ? zl(p, d, {
                        amount: c ?? 0
                    }) : void 0
                }
            case "onScrollTarget":
                {
                    let p = l?.ref.current;
                    return p ? zl(p, d, {
                        amount: c ?? 0,
                        root: document,
                        margin: l?.offset ? `${l.offset}px 0px 0px 0px` : void 0
                    }) : void 0
                }
            default:
                Ce(a)
        }
    }
        , [o, r, n, t, l, c, a]);
    let u = !!e
        , f = e ? wN(e) : void 0;
    return ue(() => ({
        getTokenizer: () => {
            if (r.clear(),
                !u)
                return;
            let { hasMounted: d, hasAnimatedOnce: p, effect: v } = s.current
                , g = SN(o, n || CN(d, p, v), s.current.effect);
            return {
                text: b => xN(b, f, r, g),
                props: b => {
                    if (v?.tokenization !== "element")
                        return;
                    let m = Xm();
                    return r.add(m),
                    {
                        ref: m,
                        style: {
                            ...b,
                            ...g
                        }
                    }
                }
            }
        }
        ,
        play: () => {
            let { effect: d } = s.current;
            if (!d)
                return;
            let p = d.type;
            switch (p) {
                case "appear":
                    {
                        let { transition: v, startDelay: g } = d;
                        Rk(f, d.effect, r, v, g);
                        break
                    }
                default:
                    Ce(p)
            }
        }
    }), [o, u, r, n, f])
}
function CN(e, t, n) {
    return !(e && n?.trigger === "onMount" || t && !n?.repeat && (n?.trigger === "onInView" || n?.trigger === "onScrollTarget"))
}
async function Rk(e = "character", t, n, r, i = 0, o = !1, s, a) {
    let l = yN(t)
        , c = new AbortController;
    switch (a && (a.current = () => c.abort()),
    e) {
        case "character":
        case "element":
        case "word":
            {
                let u = await TN(n, c);
                if (u === null || (rr(u, l, {
                    ...r,
                    restDelta: .001,
                    delay: qd(r?.delay ?? 0, {
                        startDelay: i
                    })
                }).then(() => s?.()),
                    !o || !a))
                    return;
                a.current = () => void rr(u, t, {
                    ...r,
                    restDelta: .001,
                    delay: qd(r?.delay ?? 0, {
                        startDelay: i
                    })
                });
                return
            }
        case "line":
            {
                try {
                    for (let f of n)
                        await uR(f, c)
                } catch {
                    return
                }
                let u;
                if (J.read(() => {
                    u = RN(n),
                        u.length !== 0 && J.update(() => {
                            let f = u.map((d, p) => rr(d, l, {
                                ...r,
                                restDelta: .001,
                                delay: i + p * (r?.delay ?? 0)
                            }));
                            Promise.all(f).then(() => s?.())
                        }
                        )
                }
                ),
                    !o || !a)
                    return;
                a.current = () => {
                    u.length !== 0 && u.forEach((f, d) => {
                        rr(f, t, {
                            ...r,
                            restDelta: .001,
                            delay: i + d * (r?.delay ?? 0)
                        })
                    }
                    )
                }
                    ;
                return
            }
        default:
            Ce(e)
    }
}
async function TN(e, t) {
    if (e.size === 0)
        return null;
    let n = [];
    for (let r of e)
        try {
            let i = await uR(r, t);
            i && n.push(i)
        } catch {
            return null
        }
    return n
}
function RN(e) {
    let t = []
        , n = []
        , r = null;
    for (let i of e) {
        if (!i.current)
            continue;
        let o = i.current.offsetTop
            , s = i.current.offsetHeight;
        !s || r === null || o === r ? n.push(i.current) : (t.push(n),
            n = [i.current]),
            s && (r = o)
    }
    return t.push(n),
        t
}
var Ek = Ie(({ viewBoxScale: e, viewBox: t, children: n, ...r }, i) => k(Ye.svg, {
    ref: i,
    ...r,
    viewBox: t,
    children: k(Ye.foreignObject, {
        width: "100%",
        height: "100%",
        className: "framer-fit-text",
        transform: `scale(${e})`,
        style: {
            overflow: "visible",
            transformOrigin: "center center"
        },
        children: n
    })
}))
    , EN = Ie((e, t) => {
        let { __fromCanvasComponent: n = !1, _forwardedOverrideId: r, _forwardedOverrides: i, _usesDOMRect: o, anchorLinkOffsetY: s, as: a, bottom: l, center: c, children: u, environment: f = fe.current, fonts: d = [], height: p, isEditable: v = !1, left: g, name: b, opacity: m, positionSticky: h, positionStickyBottom: y, positionStickyLeft: w, positionStickyRight: C, positionStickyTop: S, right: T, rotation: R = 0, style: F, _initialStyle: P, stylesPresetsClassNames: B, text: $, top: N, verticalAlignment: U = "top", visible: j = !0, width: ae, willChangeTransform: te, withExternalLayout: Y = !1, viewBox: ne, viewBoxScale: G = 1, effect: he, ...se } = e
            , le = qa()
            , q = hs()
            , Je = D(ds)
            , Re = fs(e)
            , et = V(null)
            , Pe = t ?? et;
        Ju(e, Pe),
            cR(d, n, Pe),
            ht(() => {
                Xa()
            }
                , []);
        let mn = kN(he, Pe)
            , Tt = ue(() => {
                if (u)
                    return dR(u, B, $, s, void 0, mn.getTokenizer())
            }
                , [u, B, $, s, mn]);
        if (!j)
            return null;
        let qn = v && f() === fe.canvas
            , pe = {
                outline: "none",
                display: "flex",
                flexDirection: "column",
                justifyContent: lR(U),
                opacity: qn ? 0 : m,
                flexShrink: 0
            }
            , Jt = fe.hasRestrictions()
            , dt = Ha(e, le || 0, !1)
            , gn = o && (ae === "auto" || p === "auto")
            , _ = !!e.transformTemplate || !dt || !Jt || n || gn ? e.transformTemplate ?? Qu(c) : void 0;
        Y || (dt && Jt && !gn ? (pe.x = dt.x,
            pe.y = dt.y,
            pe.rotate = ft.getNumber(R),
            pe.width = dt.width,
            pe.minWidth = dt.width,
            pe.height = dt.height) : (pe.left = g,
                pe.right = T,
                pe.top = N,
                pe.bottom = l,
                pe.width = ae,
                pe.height = p,
                pe.rotate = R),
            h ? (!q || Je) && (pe.position = "sticky",
                pe.willChange = "transform",
                pe.zIndex = 1,
                pe.top = S,
                pe.right = C,
                pe.bottom = y,
                pe.left = w) : q && (e.positionFixed || e.positionAbsolute) && (pe.position = "absolute")),
            pg(e, pe),
            MC(e, pe),
            te && cg(pe),
            Object.assign(pe, P, F),
            Re && (se.layout = "preserve-aspect");
        let O = Ya(e.as);
        return ye(e.viewBox) ? e.as !== void 0 ? k(O, {
            ...se,
            ref: Pe,
            style: pe,
            layoutId: Re,
            transformTemplate: _,
            "data-framer-name": b,
            "data-framer-component-type": "RichTextContainer",
            children: k(Ek, {
                viewBox: ne,
                viewBoxScale: G,
                style: {
                    width: "100%",
                    height: "100%"
                },
                children: Tt
            })
        }) : k(Ek, {
            ...se,
            ref: Pe,
            style: pe,
            layoutId: Re,
            viewBox: ne,
            viewBoxScale: G,
            transformTemplate: _,
            "data-framer-name": b,
            "data-framer-component-type": "RichTextContainer",
            children: Tt
        }) : k(O, {
            ...se,
            ref: Pe,
            style: pe,
            layoutId: Re,
            transformTemplate: _,
            "data-framer-name": b,
            "data-framer-component-type": "RichTextContainer",
            children: Tt
        })
    }
    );
function FN(e) {
    return e.type === bn
}
function PN(e) {
    return e.type === "br"
}
function dR(e, t, n, r, i = {}, o, s = FN(e) ? -1 : 0) {
    let a = yn.toArray(e.props.children);
    ye(n) && (a = a.slice(0, 1));
    let l = !0;
    a = a.map(f => {
        if ((!At(f) || !PN(f)) && (l = !1),
            At(f))
            return dR(f, t, n, r, i, o, s + 1);
        let d = ye(n) ? n : f;
        return ye(d) && o ? o.text(d) : d
    }
    );
    let { ["data-preset-tag"]: c, ...u } = e.props;
    if (ye(e.type) || Bl(e.type)) {
        let f = Ud(e.type) || e.type
            , d = c || f
            , p = ye(d) ? t?.[d] : void 0;
        u.className = no("framer-text", u.className, p),
            o && s === 0 && !l && Object.assign(u, o.props(u.style));
        let v = f === "h1" || f === "h2" || f === "h3" || f === "h4" || f === "h5" || f === "h6"
            , g = t?.anchor;
        if (v && g) {
            let b = _N(a, i);
            u.id = b;
            let m = no("framer-text", g)
                , h = k("a", {
                    href: `#${b}`,
                    className: m,
                    children: a
                });
            u.style = {
                ...u.style ?? {},
                scrollMarginTop: r
            },
                a = [h]
        }
    }
    return xr(e, u, ...a)
}
function _N(e, t) {
    let n = e.map(Ym).join("")
        , r = lN(n)
        , i = t[r] ?? 0;
    return i > 0 && (r += `-${i}`),
        t[r] = i + 1,
        r
}
function Ym(e) {
    return ye(e) || De(e) ? e.toString() : At(e) ? Ym(e.props.children) : Array.isArray(e) ? e.map(Ym).join("") : ""
}
var Y9 = Ie(({ children: e, html: t, htmlFromDesign: n, ...r }, i) => {
    let o = t || e || n;
    if (ye(o)) {
        !r.stylesPresetsClassName && Se(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(" "));
        let s = {
            [ye(t) ? "html" : "htmlFromDesign"]: o
        };
        return k(gN, {
            ...r,
            ...s,
            ref: i
        })
    }
    if (!r.stylesPresetsClassNames && ye(r.stylesPresetsClassName)) {
        let [s, a, l, c, u] = r.stylesPresetsClassName.split(" ");
        s === void 0 || a === void 0 || l === void 0 || c === void 0 || u === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = {
            h1: s,
            h2: a,
            h3: l,
            p: c,
            a: u
        }
    }
    return k(EN, {
        ...r,
        ref: i,
        children: At(o) ? o : void 0
    })
}
);
function IN(e) {
    var t, n;
    let r = e * Math.PI / 180
        , i = {
            x: -Math.sin(r) * 100,
            y: Math.cos(r) * 100
        }
        , o = hn(i.x, i.y)
        , s = _n(hn(.5, .5), o)
        , a = oe.points({
            x: 0,
            y: 0,
            width: 1,
            height: 1
        })
        , l = a.map(g => ({
            point: g,
            distance: hn.distance(o, g)
        })).sort((g, b) => g.distance - b.distance)
        , c = (t = l[0]) == null ? void 0 : t.point
        , u = (n = l[1]) == null ? void 0 : n.point;
    A(c && u, "linearGradientLine: Must have 2 closest points.");
    let [f, d] = a.filter(g => !hn.isEqual(g, c) && !hn.isEqual(g, u));
    A(f && d, "linearGradientLine: Must have 2 opposing points.");
    let p = _n.intersection(s, _n(c, u))
        , v = _n.intersection(s, _n(f, d));
    return A(p && v, "linearGradientLine: Must have a start and end point."),
        _n(p, v)
}
function ON(e, t) {
    var n, r;
    let i = IN(e.angle)
        , o = Ka(e)
        , s = ((n = o[0]) == null ? void 0 : n.position) ?? 0
        , a = ((r = o[o.length - 1]) == null ? void 0 : r.position) ?? 1
        , l = _n.pointAtPercentDistance(i, s)
        , c = _n.pointAtPercentDistance(i, a)
        , u = bo([s, a], [0, 1]);
    return {
        id: `id${t}g${Wa.hash(e)}`,
        x1: l.x,
        y1: l.y,
        x2: c.x,
        y2: c.y,
        stops: o.map(f => ({
            color: f.value,
            alpha: ug.getAlpha(f.value) * e.alpha,
            position: u(f.position)
        }))
    }
}
function MN(e, t) {
    return {
        id: `id${t}g${Ua.hash(e)}`,
        widthFactor: e.widthFactor,
        heightFactor: e.heightFactor,
        centerAnchorX: e.centerAnchorX,
        centerAnchorY: e.centerAnchorY,
        stops: Ka(e).map(n => ({
            color: n.value,
            alpha: ug.getAlpha(n.value) * e.alpha,
            position: n.position
        }))
    }
}
function hR(e) {
    if (!ye(e) || e.charAt(e.length - 1) !== "%")
        return !1;
    let n = e.slice(0, -1)
        , r = parseFloat(n);
    return De(r)
}
function pR(e) {
    let t = e.slice(0, -1)
        , n = parseFloat(t);
    return De(n) ? n : 50
}
function Fk(e) {
    return hR(e) ? pR(e) / 100 : e === "left" ? 0 : e === "right" ? 1 : .5
}
function Pk(e) {
    return hR(e) ? pR(e) / 100 : e === "top" ? 0 : e === "bottom" ? 1 : .5
}
function LN(e, t, n, r) {
    if (e = ft.get(e, "#09F"),
        !Xi.isImageObject(e) || !e.pixelWidth || !e.pixelHeight)
        return;
    let i = e.pixelWidth, o = e.pixelHeight, s, { fit: a } = e, l = 1, c = 1, u = 0, f = 0;
    if (a === "fill" || a === "fit" || a === "tile" || !a) {
        let p = 1
            , v = 1
            , g = i / o
            , b = t.height * g
            , m = t.width / g
            , h = b / t.width
            , y = m / t.height;
        if (a === "tile") {
            e.backgroundSize ?? (e.backgroundSize = 1),
                l = Math.round(e.backgroundSize * (i / 2)),
                c = Math.round(e.backgroundSize * (o / 2));
            let w = t.x ?? 0
                , C = t.y ?? 0
                , S = 0
                , T = 0;
            r && (S = w,
                T = C),
                u = (t.width - l) * Fk(e.positionX) + S,
                f = (t.height - c) * Pk(e.positionY) + T,
                s = `translate(${u + w}, ${f + C})`
        } else
            (a === "fill" || !a ? y > h : y < h) ? (v = y,
                f = (1 - y) * Pk(e.positionY)) : (p = h,
                    u = (1 - h) * Fk(e.positionX)),
                s = `translate(${u}, ${f}) scale(${p}, ${v})`
    }
    return {
        id: `id${n}g-fillImage`,
        path: e.src ?? "",
        transform: s,
        width: l,
        height: c,
        offsetX: u,
        offsetY: f
    }
}
var VN = "framer/asset-reference,";
function AN(e) {
    return e.startsWith(`data:${VN}`)
}
function DN(e, t) {
    if (/^\w+:/u.test(e) && !AN(e))
        return e;
    typeof t != "number" ? t = void 0 : t <= 512 ? t = 512 : t <= 1024 ? t = 1024 : t <= 2048 ? t = 2048 : t = 4096;
    let n = fe.current() === fe.export;
    return vt.assetResolver(e, {
        pixelSize: t,
        isExport: n
    }) ?? ""
}
var zN = ({ id: e, path: t, transform: n, repeat: r, width: i, height: o, offsetX: s, offsetY: a }) => {
    let l = DN(t);
    return k("pattern", {
        id: e,
        width: r ? i : "100%",
        height: r ? o : "100%",
        patternContentUnits: r ? void 0 : "objectBoundingBox",
        patternUnits: r ? "userSpaceOnUse" : void 0,
        x: r ? s : void 0,
        y: r ? a : void 0,
        children: k("image", {
            width: r ? i : 1,
            height: r ? o : 1,
            href: l,
            preserveAspectRatio: "none",
            transform: r ? void 0 : n,
            x: r ? 0 : void 0,
            y: r ? 0 : void 0
        }, l)
    })
}
    ;
var Om, BN = (() => !OD() && typeof Document < "u" && typeof Document.parseHTMLUnsafe == "function")();
function $N(e, t) {
    return BN && !t ? Document.parseHTMLUnsafe(e) : (Om ?? (Om = new DOMParser),
        Om.parseFromString(e, t ?? "text/html"))
}
var _k = Gn()
    , NN = class {
        constructor(e, t, n, r, i = 0) {
            this.id = e,
                this.svg = t,
                this.innerHTML = n,
                this.viewBox = r,
                this.count = i
        }
    }
    , Ik = "position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict"
    , jN = class {
        constructor() {
            E(this, "entries", new Map)
        }
        debugGetEntries() {
            return this.entries
        }
        subscribe(e, t, n) {
            if (!e || e === "")
                return "";
            let r = this.entries.get(e);
            if (!r) {
                n || (n = `svg${String(RC(e))}_${String(e.length)}`);
                let i = e, o, s = HN(e);
                s && (t && WN(s, n),
                    s.id = n,
                    o = XN(s),
                    s.removeAttribute("xmlns"),
                    s.removeAttribute("xlink"),
                    s.removeAttribute("xmlns:xlink"),
                    i = s.outerHTML),
                    r = this.createDOMElementFor(i, n, o),
                    this.entries.set(e, r)
            }
            return r.count += 1,
                r.innerHTML
        }
        getViewBox(e) {
            if (!e || e === "")
                return;
            let t = this.entries.get(e);
            return t?.viewBox
        }
        unsubscribe(e) {
            if (!e || e === "")
                return;
            let t = this.entries.get(e);
            t && (t.count -= 1,
                !(t.count > 0) && setTimeout(() => this.maybeRemoveEntry(e), 5e3))
        }
        maybeRemoveEntry(e) {
            let t = this.entries.get(e);
            t && (t.count > 0 || (this.entries.delete(e),
                this.removeDOMElement(t)))
        }
        removeDOMElement(e) {
            if (_k) {
                let t = document?.getElementById(e.id);
                t?.remove()
            }
        }
        createDOMElementFor(e, t, n) {
            if (_k) {
                let s = document.getElementById("svg-templates");
                if (s || (s = document.createElement("div"),
                    s.id = "svg-templates",
                    s.ariaHidden = "true",
                    s.style.cssText = Ik,
                    document.body.appendChild(s)),
                    !document.getElementById(t)) {
                    let a = document.createElement("div");
                    a.innerHTML = e;
                    let l = a.firstElementChild;
                    l && (l.id = t,
                        s.appendChild(l))
                }
            }
            let r = n ? `0 0 ${n.width} ${n.height}` : void 0
                , o = `<svg style="width:100%;height:100%"${r ? ` viewBox="${r}"` : ""}><use href="#${t}"/></svg>`;
            return new NN(t, e, o, r)
        }
        clear() {
            this.entries.clear()
        }
        generateTemplates() {
            let e = [];
            return e.push(`<div id="svg-templates" style="${Ik}" aria-hidden="true">`),
                this.entries.forEach(t => e.push(t.svg)),
                e.push("</div>"),
                e.join(`
`)
        }
    }
    , es = new jN;
function HN(e) {
    try {
        let n = $N(e).getElementsByTagName("svg")[0];
        if (!n)
            throw Error("no svg element found");
        return n
    } catch {
        return
    }
}
function WN(e, t) {
    let n = UN(t);
    mR(e, n)
}
function UN(e) {
    return e.replace(/[^\w\-:.]|^[^a-z]+/gi, "")
}
function mR(e, t) {
    GN(e, t),
        Array.from(e.children).forEach(r => {
            mR(r, t)
        }
        )
}
function GN(e, t) {
    e.getAttributeNames().forEach(r => {
        let i = e.getAttribute(r);
        if (!i)
            return;
        if (r === "id" && e.setAttribute(r, `${t}_${i}`),
            r === "href" || r === "xlink:href") {
            let [s, a] = i.split("#");
            if (s)
                return;
            e.setAttribute(r, `#${t}_${a}`);
            return
        }
        let o = "url(#";
        if (i.includes(o)) {
            let s = i.replace(o, `${o}${t}_`);
            e.setAttribute(r, s)
        }
    }
    )
}
var qN = (() => ({
    cm: 96 / 2.54,
    mm: 96 / 2.54 / 10,
    Q: 96 / 2.54 / 40,
    in: 96,
    pc: 96 / 6,
    pt: 96 / 72,
    px: 1,
    em: 16,
    ex: 8,
    ch: 8,
    rem: 16
}))();
function Ok(e) {
    var t;
    if (!e)
        return;
    let n = /(-?[\d.]+)([a-z%]*)/u.exec(e);
    if (!(n?.[1] === void 0 || n?.[2] === void 0) && !((t = n[2]) != null && t.startsWith("%")))
        return Math.round(parseFloat(n[1]) * (qN[n[2]] || 1))
}
function XN(e) {
    let t = Ok(e.getAttribute("width"))
        , n = Ok(e.getAttribute("height"));
    if (!(typeof t != "number" || typeof n != "number") && !(t <= 0 || n <= 0))
        return {
            width: t,
            height: n
        }
}
function J9(e) {
    let t = qa()
        , n = fs(e)
        , r = x.useRef(null)
        , i = b$();
    return Ju(e, r),
        k(e6, {
            ...e,
            innerRef: r,
            parentSize: t,
            layoutId: n,
            providedWindow: i
        })
}
var YN = 5e4;
function KN(e) {
    return e.indexOf("image") >= 0
}
function QN(e) {
    return e.indexOf("var(--") >= 0
}
function ZN(e) {
    return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius)
}
function Mk(e, t) {
    var n, r;
    let i = e.current;
    if (!i)
        return;
    let o = t.providedWindow ?? it
        , s = i.firstElementChild;
    if (!s || !(s instanceof o.SVGSVGElement))
        return;
    if (!s.getAttribute("viewBox")) {
        let p = es.getViewBox(t.svg);
        p && s.setAttribute("viewBox", p)
    }
    let { withExternalLayout: a, parentSize: l } = t;
    if (!a && us(t) && l !== 1 && l !== 2)
        return;
    let { intrinsicWidth: u, intrinsicHeight: f, _constraints: d } = t;
    ((n = s.viewBox.baseVal) == null ? void 0 : n.width) === 0 && ((r = s.viewBox.baseVal) == null ? void 0 : r.height) === 0 && re(u) && re(f) && s.setAttribute("viewBox", `0 0 ${u} ${f}`),
        d && d.aspectRatio ? s.setAttribute("preserveAspectRatio", "") : s.setAttribute("preserveAspectRatio", "none"),
        s.setAttribute("width", "100%"),
        s.setAttribute("height", "100%")
}
function JN() {
    return x.useInsertionEffect(() => {
        Xa()
    }
        , []),
        null
}
var e6 = (() => {
    var e;
    return e = class extends za {
        constructor() {
            super(...arguments),
                E(this, "container", x.createRef()),
                E(this, "svgElement", null),
                E(this, "setSVGElement", t => {
                    this.svgElement = t,
                        this.setLayerElement(t)
                }
                ),
                E(this, "previouslyRenderedSVG", ""),
                E(this, "unmountedSVG", "")
        }
        static frame(t) {
            return Ha(t, t.parentSize || 0)
        }
        get frame() {
            return Ha(this.props, this.props.parentSize || 0)
        }
        componentDidMount() {
            if (this.unmountedSVG) {
                let { svgContentId: t } = this.props
                    , n = t ? `svg${t}` : null;
                es.subscribe(this.unmountedSVG, !t, n),
                    this.previouslyRenderedSVG = this.unmountedSVG
            }
            this.props.svgContentId || Mk(this.container, this.props)
        }
        componentWillUnmount() {
            es.unsubscribe(this.previouslyRenderedSVG),
                this.unmountedSVG = this.previouslyRenderedSVG,
                this.previouslyRenderedSVG = ""
        }
        componentDidUpdate(t) {
            if (super.componentDidUpdate(t),
                this.props.svgContentId)
                return;
            let { fill: n } = this.props;
            Xi.isImageObject(n) && Xi.isImageObject(t.fill) && n.src !== t.fill.src && TC(this.svgElement, "fill", null, !1),
                Mk(this.container, this.props)
        }
        collectLayout(t, n) {
            if (this.props.withExternalLayout) {
                n.width = "100%",
                    n.height = "100%",
                    n.aspectRatio = "inherit";
                return
            }
            let r = this.frame
                , { rotation: i, intrinsicWidth: o, intrinsicHeight: s, width: a, height: l } = this.props
                , c = ft.getNumber(i);
            if (t.opacity = re(this.props.opacity) ? this.props.opacity : 1,
                fe.hasRestrictions() && r) {
                Object.assign(t, {
                    transform: `translate(${r.x}px, ${r.y}px) rotate(${c.toFixed(4)}deg)`,
                    width: `${r.width}px`,
                    height: `${r.height}px`
                }),
                    us(this.props) && (t.position = "absolute");
                let v = r.width / (o || 1)
                    , g = r.height / (s || 1);
                n.transformOrigin = "top left";
                let { zoom: b, target: m } = zm;
                if (m === fe.export) {
                    let h = b > 1 ? b : 1;
                    n.transform = `scale(${v * h}, ${g * h})`,
                        n.zoom = 1 / h
                } else
                    n.transform = `scale(${v}, ${g})`;
                o && s && (n.width = o,
                    n.height = s);
                return
            }
            let { left: u, right: f, top: d, bottom: p } = this.props;
            Object.assign(t, {
                left: u,
                right: f,
                top: d,
                bottom: p,
                width: a,
                height: l,
                rotate: c
            }),
                Object.assign(n, {
                    left: 0,
                    top: 0,
                    bottom: 0,
                    right: 0,
                    position: "absolute"
                })
        }
        render() {
            let { id: t, visible: n, style: r, fill: i, svg: o, intrinsicHeight: s, intrinsicWidth: a, title: l, description: c, layoutId: u, className: f, variants: d, withExternalLayout: p, innerRef: v, svgContentId: g, height: b, opacity: m, width: h, ...y } = this.props;
            if (!p && (!n || !t))
                return null;
            let w = t ?? u ?? "svg"
                , C = this.frame
                , S = C || {
                    width: a || 100,
                    height: s || 100
                }
                , T = {
                    ...r,
                    imageRendering: "pixelated",
                    flexShrink: 0
                }
                , R = {};
            this.collectLayout(T, R),
                D3(this.props, T),
                pg(this.props, T),
                za.applyWillChange(this.props, T, !1);
            let F = null;
            if (typeof i == "string" || Z.isColorObject(i)) {
                let G = Z.isColorObject(i) ? i.initialValue || Z.toRgbString(i) : i;
                T.fill = G,
                    T.color = G
            } else if (Wa.isLinearGradient(i)) {
                let G = i
                    , he = `${encodeURI(t || "")}g${Wa.hash(G)}`;
                T.fill = `url(#${he})`;
                let { stops: se, x1: le, x2: q, y1: Je, y2: Re } = ON(G, w);
                F = k("svg", {
                    ref: this.setSVGElement,
                    width: "100%",
                    height: "100%",
                    style: {
                        position: "absolute"
                    },
                    children: k("linearGradient", {
                        id: he,
                        x1: le,
                        x2: q,
                        y1: Je,
                        y2: Re,
                        children: se.map((et, Pe) => k("stop", {
                            offset: et.position,
                            stopColor: et.color,
                            stopOpacity: et.alpha
                        }, Pe))
                    })
                })
            } else if (Ua.isRadialGradient(i)) {
                let G = i
                    , he = `${encodeURI(t || "")}g${Ua.hash(G)}`;
                T.fill = `url(#${he})`;
                let se = MN(G, w);
                F = k("svg", {
                    ref: this.setSVGElement,
                    width: "100%",
                    height: "100%",
                    style: {
                        position: "absolute"
                    },
                    children: k("radialGradient", {
                        id: he,
                        cy: G.centerAnchorY,
                        cx: G.centerAnchorX,
                        r: G.widthFactor,
                        children: se.stops.map((le, q) => k("stop", {
                            offset: le.position,
                            stopColor: le.color,
                            stopOpacity: le.alpha
                        }, q))
                    })
                })
            } else if (Xi.isImageObject(i)) {
                let G = LN(i, S, w);
                G && (T.fill = `url(#${G.id})`,
                    F = k("svg", {
                        ref: this.setSVGElement,
                        width: "100%",
                        height: "100%",
                        style: {
                            position: "absolute"
                        },
                        children: k("defs", {
                            children: k(zN, {
                                ...G
                            })
                        })
                    }))
            }
            let P = {
                "data-framer-component-type": "SVG"
            }
                , B = !C;
            B && Object.assign(P, yC(this.props.center));
            let $ = !F && !T.fill && !T.background && !T.backgroundImage && o.length < YN && !KN(o) && !QN(o)
                , N = null;
            if ($)
                T.backgroundSize = "100% 100%",
                    T.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(o)}')`,
                    es.unsubscribe(this.previouslyRenderedSVG),
                    this.previouslyRenderedSVG = "";
            else {
                let G = g ? `svg${g}` : null
                    , he = es.subscribe(o, !g, G);
                es.unsubscribe(this.previouslyRenderedSVG),
                    this.previouslyRenderedSVG = o,
                    ZN(T) && (T.overflow = "hidden"),
                    N = ge(lt, {
                        children: [F, k("div", {
                            className: "svgContainer",
                            style: R,
                            ref: this.container,
                            dangerouslySetInnerHTML: {
                                __html: he
                            }
                        }, Xi.isImageObject(i) ? i.src : "")]
                    })
            }
            let U = Ya(this.props.as)
                , { href: j, target: ae, rel: te, onClick: Y } = this.props
                , ne = l || c;
            return ge(U, {
                ...P,
                ...y,
                layoutId: u,
                transformTemplate: B ? Qu(this.props.center) : void 0,
                id: t,
                ref: v,
                style: T,
                className: f,
                variants: d,
                tabIndex: this.props.tabIndex,
                role: ne ? "img" : void 0,
                "aria-label": l,
                "aria-description": c,
                "aria-hidden": ne ? void 0 : "true",
                href: j,
                target: ae,
                rel: te,
                onClick: Y,
                children: [N, k(JN, {})]
            })
        }
    }
        ,
        E(e, "supportsConstraints", !0),
        E(e, "defaultSVGProps", {
            left: void 0,
            right: void 0,
            top: void 0,
            bottom: void 0,
            style: void 0,
            _constraints: {
                enabled: !0,
                aspectRatio: null
            },
            parentSize: 0,
            rotation: 0,
            visible: !0,
            svg: "",
            shadows: []
        }),
        E(e, "defaultProps", {
            ...za.defaultProps,
            ...e.defaultSVGProps
        }),
        e
}
)();
var t6 = 1e3;
function c7(e) {
    return e > t6 ? "lazy" : void 0
}
function u7(e, t, n) {
    let r = gR(t);
    !n?.supportsExplicitInterCodegen && !r.some(i => i.explicitInter === !1) && r.push({
        explicitInter: !1,
        fonts: []
    }),
        Object.assign(e, {
            fonts: r
        })
}
function f7(e) {
    return e.fonts ?? []
}
function d7(e) {
    return e.length === 0 ? [{
        explicitInter: !1,
        fonts: []
    }] : gR(e)
}
function gR(e) {
    let t = {
        explicitInter: !1,
        fonts: []
    }
        , n = [];
    for (let r of e)
        r6(r) ? n.push(r) : t.fonts.push(i6(r));
    return t.fonts.length > 0 && n.push(t),
        n
}
var n6 = "explicitInter";
function r6(e) {
    return n6 in e
}
function i6(e) {
    let t;
    return e.url.startsWith("https://fonts.gstatic.com/s/") ? t = "google" : e.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/") ? t = "fontshare" : t = "custom",
    {
        ...e,
        source: t
    }
}
function h7(e, t) {
    let n = `${e}-start`;
    performance.mark(n),
        t();
    let r = `${e}-end`;
    performance.mark(r),
        performance.measure(e, n, r)
}
Fl.prototype.addChild = function ({ transformer: e = t => t }) {
    let t = Xe(e(this.get()));
    return this.onChange(n => t.set(e(n))),
        t
}
    ;
/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
export { x as a, yn as b, bn as c, br as d, xr as e, Nr as f, Kg as g, Ie as h, UR as i, at as j, Q as k, D as l, H as m, wi as n, ht as o, ze as p, ue as q, V as r, Ee as s, Rt as t, lt as u, k as v, ge as w, J as x, Jn as y, Ye as z, sb as A, nr as B, Dt as C, II as D, pb as E, gb as F, JI as G, jS as H, WM as I, QM as J, RH as K, _H as L, MH as M, VH as N, DH as O, bi as P, Yu as Q, Qk as R, KH as S, e8 as T, fe as U, l8 as V, iA as W, h8 as X, rD as Y, uD as Z, fD as _, bW as $, no as aa, y5 as ba, ZW as ca, iU as da, oU as ea, x5 as fa, mU as ga, B5 as ha, nf as ia, wU as ja, JC as ka, EU as la, G5 as ma, Z5 as na, l4 as oa, OU as pa, DU as qa, $U as ra, WU as sa, GU as ta, qB as ua, Mg as va, YU as wa, KU as xa, UT as ya, QU as za, KB as Aa, ZU as Ba, e9 as Ca, QB as Da, r9 as Ea, i9 as Fa, i$ as Ga, u9 as Ha, p9 as Ia, m9 as Ja, y9 as Ka, C9 as La, Tu as Ma, V9 as Na, $9 as Oa, H9 as Pa, Y9 as Qa, es as Ra, J9 as Sa, c7 as Ta, u7 as Ua, f7 as Va, d7 as Wa, h7 as Xa };
//# sourceMappingURL=chunk-NV2CJCYN.mjs.map
